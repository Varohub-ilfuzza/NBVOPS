<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>OPS Center â€” AirNubeiro</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#e0a348">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg0: #060910; --bg1: #0b0f18; --bg2: #111722; --bg3: #0a0e17;
    --brd: #1c2333; --brd-f: #d4953a;
    --acc: #e0a348; --acc-d: #b07e2e; --acc-g: rgba(224,163,72,0.12);
    --tx1: #e6eaef; --tx2: #7d8aa0; --tx3: #4a5568;
    --ok: #34d399; --err: #f87171; --wrn: #fbbf24; --inf: #60a5fa; --cpdlc: #a78bfa;
    --ops: #f472b6;
    --mono: 'JetBrains Mono','Courier New',monospace;
    --sans: 'IBM Plex Sans',-apple-system,sans-serif;
  }
  html { font-size: 15px; }
  body { font-family: var(--sans); background: var(--bg0); color: var(--tx1); min-height: 100dvh; -webkit-font-smoothing: antialiased; }

  /* â”€â”€ Layout â”€â”€ */
  .app { max-width: 900px; margin: 0 auto; padding: 12px; min-height: 100dvh; display: flex; flex-direction: column; gap: 10px; }

  /* â”€â”€ Header â”€â”€ */
  .hdr { display: flex; align-items: center; justify-content: space-between; padding: 10px 0 8px; border-bottom: 1px solid var(--brd); }
  .hdr-l { display: flex; align-items: center; gap: 10px; }
  .hdr-ico { width: 38px; height: 38px; background: var(--ops); border-radius: 8px; display: flex; align-items: center; justify-content: center; font: 700 14px/1 var(--mono); color: var(--bg0); letter-spacing: -0.5px; }
  .hdr-t h1 { font: 600 1.05rem/1.2 var(--mono); color: var(--tx1); letter-spacing: -0.3px; }
  .hdr-t .sub { font: 400 0.62rem var(--mono); color: var(--tx3); letter-spacing: 0.5px; }
  .hdr-r { display: flex; gap: 5px; align-items: center; }

  .ib { background: 0; border: 1px solid var(--brd); color: var(--tx2); height: 36px; padding: 0 12px; border-radius: 6px; cursor: pointer; font: 600 0.7rem var(--mono); display: flex; align-items: center; justify-content: center; gap: 5px; transition: .15s; }
  .ib:hover { border-color: var(--acc-d); color: var(--acc); }
  .ib.on { border-color: var(--ok); color: var(--ok); background: rgba(52,211,153,.08); }
  .ib.stop { border-color: var(--err); color: var(--err); }

  .dot-live { width: 8px; height: 8px; background: var(--ok); border-radius: 50%; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0%,100%{ opacity:1 } 50%{ opacity:.3 } }

  /* â”€â”€ Config â”€â”€ */
  .cfg { display: none; background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; padding: 14px; }
  .cfg.v { display: block; }
  .cfg h3 { font: 600 0.72rem var(--mono); color: var(--acc); letter-spacing: 1px; margin-bottom: 10px; text-transform: uppercase; }
  .cfg-g { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .f { display: flex; flex-direction: column; gap: 3px; }
  .f label { font: 500 0.62rem var(--mono); color: var(--tx3); letter-spacing: .6px; text-transform: uppercase; }
  .f input, .f select, .f textarea { background: var(--bg3); border: 1px solid var(--brd); border-radius: 5px; padding: 8px 10px; color: var(--tx1); font: 400 0.82rem var(--mono); outline: 0; transition: border .15s; }
  .f input:focus, .f select:focus { border-color: var(--brd-f); }
  .uc { text-transform: uppercase; }

  /* â”€â”€ Status bar â”€â”€ */
  .sb { display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 6px; font: 500 0.72rem var(--mono); }
  .sb .d { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
  .sb.idle { background: var(--bg2); color: var(--tx3); } .sb.idle .d { background: var(--tx3); }
  .sb.ok { background: rgba(52,211,153,.06); color: var(--ok); } .sb.ok .d { background: var(--ok); }
  .sb.snd { background: var(--acc-g); color: var(--acc); } .sb.snd .d { background: var(--acc); }
  .sb.err { background: rgba(248,113,113,.06); color: var(--err); } .sb.err .d { background: var(--err); }
  .sb.live { background: rgba(244,114,182,.06); color: var(--ops); } .sb.live .d { background: var(--ops); animation: pulse 1.5s infinite; }

  /* â”€â”€ Roster â”€â”€ */
  .roster { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; padding: 14px; }
  .roster h3 { font: 600 0.72rem var(--mono); color: var(--ops); letter-spacing: 1px; margin-bottom: 8px; text-transform: uppercase; }
  .roster-help { font: 400 0.68rem var(--sans); color: var(--tx3); margin-bottom: 10px; line-height: 1.4; }
  .roster-row { display: flex; gap: 6px; align-items: center; margin-bottom: 5px; }
  .roster-row input { flex: 1; }
  .roster-row .rm { background: none; border: 1px solid var(--brd); color: var(--tx3); width: 28px; height: 28px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; justify-content: center; }
  .roster-row .rm:hover { border-color: var(--err); color: var(--err); }
  .roster-add { background: rgba(244,114,182,.08); border: 1px dashed rgba(244,114,182,.3); color: var(--ops); padding: 6px; border-radius: 5px; width: 100%; font: 500 0.68rem var(--mono); cursor: pointer; transition: .12s; }
  .roster-add:hover { background: rgba(244,114,182,.15); }

  /* â”€â”€ Dashboard â”€â”€ */
  .dash { display: flex; flex-direction: column; gap: 8px; }
  .dash-empty { text-align: center; padding: 30px; color: var(--tx3); font: 400 0.8rem var(--mono); }

  .flt-card { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; padding: 12px; display: grid; grid-template-columns: auto 1fr auto; gap: 10px; align-items: center; transition: border-color .2s; }
  .flt-card.ph-preflight { border-left: 3px solid var(--wrn); }
  .flt-card.ph-enroute { border-left: 3px solid var(--inf); }
  .flt-card.ph-descent { border-left: 3px solid var(--cpdlc); }
  .flt-card.ph-landed { border-left: 3px solid var(--ok); }

  .flt-cs { font: 700 1rem var(--mono); color: var(--acc); }
  .flt-route { font: 500 0.72rem var(--mono); color: var(--tx2); margin-top: 2px; }
  .flt-ac { font: 400 0.65rem var(--mono); color: var(--tx3); }

  .flt-data { display: flex; flex-wrap: wrap; gap: 4px 12px; }
  .flt-d { font: 400 0.65rem var(--mono); color: var(--tx3); }
  .flt-d span { color: var(--tx1); font-weight: 600; }

  .flt-phase { padding: 4px 10px; border-radius: 4px; font: 700 0.62rem var(--mono); letter-spacing: .8px; text-align: center; white-space: nowrap; }
  .flt-phase.preflight { background: rgba(251,191,36,.1); color: var(--wrn); }
  .flt-phase.enroute { background: rgba(96,165,250,.1); color: var(--inf); }
  .flt-phase.descent { background: rgba(167,139,250,.1); color: var(--cpdlc); }
  .flt-phase.landed { background: rgba(52,211,153,.1); color: var(--ok); }

  .flt-msgs { grid-column: 1 / -1; display: flex; gap: 4px; flex-wrap: wrap; margin-top: 4px; }
  .flt-msg { padding: 2px 8px; border-radius: 3px; font: 500 0.58rem var(--mono); letter-spacing: .3px; }
  .flt-msg.sent { background: rgba(52,211,153,.1); color: var(--ok); }
  .flt-msg.pending { background: rgba(125,138,160,.1); color: var(--tx3); }
  .flt-msg.sending { background: rgba(224,163,72,.1); color: var(--acc); }
  .flt-msg.error { background: rgba(248,113,113,.1); color: var(--err); }

  /* â”€â”€ Stats bar â”€â”€ */
  .stats { display: flex; gap: 12px; flex-wrap: wrap; padding: 8px 0; }
  .stat { display: flex; align-items: center; gap: 5px; font: 400 0.68rem var(--mono); color: var(--tx3); }
  .stat .n { font-weight: 700; font-size: 1rem; }
  .stat .n.wrn { color: var(--wrn); }
  .stat .n.inf { color: var(--inf); }
  .stat .n.cpdlc { color: var(--cpdlc); }
  .stat .n.ok { color: var(--ok); }
  .stat .n.acc { color: var(--acc); }

  /* â”€â”€ Log â”€â”€ */
  .log { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; max-height: 260px; overflow-y: auto; }
  .log::-webkit-scrollbar { width: 4px; } .log::-webkit-scrollbar-thumb { background: var(--brd); border-radius: 2px; }
  .log-h { font: 600 0.66rem var(--mono); color: var(--tx3); letter-spacing: 1px; text-transform: uppercase; padding: 10px 12px 6px; position: sticky; top: 0; background: var(--bg1); display: flex; justify-content: space-between; align-items: center; }
  .log-h button { background: none; border: none; color: var(--tx3); font: 400 0.6rem var(--mono); cursor: pointer; } .log-h button:hover { color: var(--err); }
  .log-e { padding: 4px 12px; font: 400 0.65rem/1.5 var(--mono); border-bottom: 1px solid rgba(28,35,51,.5); display: flex; gap: 8px; }
  .log-e:last-child { border-bottom: none; }
  .log-e .lt { color: var(--tx3); flex-shrink: 0; }
  .log-e .lm { color: var(--tx2); }
  .log-e.ok .lm { color: var(--ok); }
  .log-e.err .lm { color: var(--err); }
  .log-e.wrn .lm { color: var(--wrn); }
  .log-e.ops .lm { color: var(--ops); }
  .log-empty { text-align: center; padding: 16px; color: var(--tx3); font: 400 0.7rem var(--mono); }

  /* â”€â”€ Sections â”€â”€ */
  .sec-h { font: 600 0.66rem var(--mono); color: var(--tx3); letter-spacing: 1px; text-transform: uppercase; padding: 4px 0; }

  /* â”€â”€ Tooltip â”€â”€ */
  .hi { position: relative; display: inline-flex; align-items: center; justify-content: center; width: 14px; height: 14px; background: var(--bg3); border: 1px solid var(--brd); border-radius: 50%; font: 500 0.5rem var(--mono); color: var(--tx3); cursor: help; margin-left: 4px; }
  .hi:hover .tt, .hi:focus .tt { display: block; }
  .tt { display: none; position: absolute; bottom: 120%; left: 50%; transform: translateX(-50%); background: var(--bg2); border: 1px solid var(--brd); border-radius: 6px; padding: 8px; font: 400 0.62rem/1.4 var(--sans); color: var(--tx2); width: 220px; z-index: 10; white-space: normal; }

  /* â”€â”€ Footer â”€â”€ */
  .ftr { text-align: center; padding: 12px 0; margin-top: auto; }
  .ftr .br { font: 600 0.62rem var(--mono); color: var(--tx3); letter-spacing: 1.5px; text-transform: uppercase; }
  .ftr .lg { font: 400 0.56rem var(--sans); color: var(--tx3); margin-top: 4px; opacity: .6; }

  /* â”€â”€ Responsive â”€â”€ */
  @media (max-width: 600px) {
    html { font-size: 14px; }
    .app { padding: 8px; }
    .cfg-g { grid-template-columns: 1fr; }
    .flt-card { grid-template-columns: 1fr; }
    .flt-phase { justify-self: start; }
    .stats { gap: 8px; }
  }

  /* â”€â”€ Roster Chips â”€â”€ */
  #rosterChips span { background: var(--bg2); border: 1px solid var(--brd); border-radius: 4px; padding: 1px 6px; font-size: .56rem; }
  #rosterChips .rc-mapped { border-color: rgba(52,199,89,.3); color: #34c759; }
  #rosterChips .rc-unmapped { border-color: var(--brd); color: var(--tx3); }
  /* â”€â”€ AOC Fullscreen â”€â”€ */
  .aoc-overlay { position: fixed; inset: 0; z-index: 9999; background: #080c14; display: flex; flex-direction: column; overflow: hidden; }
  .aoc-header { display: flex; align-items: center; gap: 20px; padding: 10px 20px; background: linear-gradient(180deg, #0d1220 0%, #0a0e1a 100%); border-bottom: 1px solid #1a2236; flex-shrink: 0; }
  .aoc-brand { display: flex; align-items: center; gap: 10px; }
  .aoc-logo { font-size: 1.6rem; }
  .aoc-title { font: 700 1rem var(--mono); color: #e2e8f0; letter-spacing: 2px; }
  .aoc-sub { font: 400 .58rem var(--mono); color: #64748b; letter-spacing: 1px; }
  .aoc-clock { font: 700 1.4rem var(--mono); color: #38bdf8; letter-spacing: 2px; margin-left: auto; }
  .aoc-stats { display: flex; gap: 12px; margin-left: 20px; }
  .aoc-st { font: 600 .6rem var(--mono); color: #94a3b8; text-align: center; }
  .aoc-st span { display: block; font-size: 1.1rem; font-weight: 700; color: #e2e8f0; }
  .aoc-close { font: 600 .65rem var(--mono); background: rgba(239,68,68,.1); color: #f87171; border: 1px solid rgba(239,68,68,.3); border-radius: 6px; padding: 6px 14px; cursor: pointer; margin-left: 16px; }
  .aoc-close:hover { background: rgba(239,68,68,.2); }
  .aoc-board { flex: 1; overflow-y: auto; padding: 8px 16px; }
  .aoc-tbl { width: 100%; border-collapse: collapse; font: .65rem var(--mono); }
  .aoc-tbl th { background: #111827; color: #64748b; padding: 8px 10px; text-align: left; border-bottom: 2px solid #1e293b; position: sticky; top: 0; z-index: 1; letter-spacing: 1px; font-weight: 600; font-size: .58rem; }
  .aoc-tbl td { padding: 7px 10px; border-bottom: 1px solid #1e293b; color: #cbd5e1; vertical-align: middle; }
  .aoc-tbl tr:hover td { background: rgba(56,189,248,.03); }
  .aoc-tbl .aoc-cs { font-weight: 700; color: #f1f5f9; font-size: .72rem; }
  .aoc-tbl .aoc-ph { display: inline-block; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: .56rem; letter-spacing: .5px; }
  .aoc-ph.pre { background: rgba(250,204,21,.1); color: #facc15; }
  .aoc-ph.enr { background: rgba(56,189,248,.1); color: #38bdf8; }
  .aoc-ph.dsc { background: rgba(167,139,250,.1); color: #a78bfa; }
  .aoc-ph.lnd { background: rgba(52,199,89,.1); color: #34c759; }
  .aoc-empty { text-align: center; padding: 60px 20px; font: .75rem var(--mono); color: #475569; }
  .aoc-footer { text-align: center; padding: 8px; font: .55rem var(--mono); color: #334155; border-top: 1px solid #1e293b; flex-shrink: 0; }
  .aoc-msg { display: inline-block; padding: 1px 5px; border-radius: 3px; font-size: .5rem; font-weight: 600; margin: 1px; }
  .aoc-msg.sent { background: rgba(52,199,89,.15); color: #34c759; }
  .aoc-msg.sending { background: rgba(56,189,248,.15); color: #38bdf8; }
  .aoc-msg.pending { background: rgba(250,204,21,.15); color: #facc15; }
  .aoc-msg.error { background: rgba(239,68,68,.15); color: #f87171; }
  /* â”€â”€ Message History â”€â”€ */
  .mh { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; overflow: hidden; }
  .mh-h { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; border-bottom: 1px solid var(--brd); cursor: pointer; }
  .mh-h span { font: 600 .68rem var(--mono); color: var(--tx2); letter-spacing: .5px; }
  .mh-h .mh-cnt { font: 700 .62rem var(--mono); background: var(--acc); color: var(--bg0); border-radius: 4px; padding: 1px 6px; margin-left: 6px; }
  .mh-h button { font: 400 .6rem var(--mono); background: 0; border: 1px solid var(--brd); color: var(--tx3); border-radius: 4px; padding: 2px 8px; cursor: pointer; }
  .mh-body { max-height: 300px; overflow-y: auto; display: none; }
  .mh-body.open { display: block; }
  .mh-tbl { width: 100%; border-collapse: collapse; font: .6rem var(--mono); }
  .mh-tbl th { background: var(--bg2); color: var(--tx3); padding: 4px 6px; text-align: left; position: sticky; top: 0; font-weight: 600; letter-spacing: .5px; }
  .mh-tbl td { padding: 3px 6px; border-top: 1px solid var(--brd); color: var(--tx2); vertical-align: top; }
  .mh-tbl tr:hover td { background: rgba(255,255,255,.03); }
  .mh-st { display: inline-block; padding: 1px 5px; border-radius: 3px; font-size: .55rem; font-weight: 600; }
  .mh-st.sent { background: rgba(52,199,89,.15); color: #34c759; }
  .mh-st.error { background: rgba(255,69,58,.15); color: #ff453a; }
  .mh-st.skip { background: rgba(142,142,147,.15); color: #8e8e93; }
</style>
</head>
<body>
<div class="app">

  <!-- â•â•â• HEADER â•â•â• -->
  <div class="hdr">
    <div class="hdr-l">
      <div class="hdr-ico">OPS</div>
      <div class="hdr-t">
        <h1>OPS Center</h1>
        <div class="sub">AirNubeiro â€” Dispatch Automatizado</div>
      </div>
    </div>
    <div class="hdr-r">
      <button class="ib" id="btnMonitor" onclick="toggleMonitor()">
        <span id="monIco">â–¶</span> <span id="monTxt">INICIAR</span>
      </button>
      <button class="ib" id="btnAoc" onclick="toggleAoc()" title="Pantalla AOC">ğŸ–¥</button>
      <button class="ib" id="btnCfg" onclick="toggleCfg()">âš™</button>
    </div>
  </div>

  <!-- â•â•â• CONFIG â•â•â• -->
  <div class="cfg" id="cfgP">
    <h3>ConfiguraciÃ³n</h3>
    <div class="cfg-g">
      <div class="f"><label>LOGON CODE (Hoppie)</label><input type="text" id="cL" placeholder="Tu cÃ³digo Hoppie" autocomplete="off" spellcheck="false"></div>
      <div class="f"><label>CALLSIGN ESTACIÃ“N</label><input type="text" id="cS" class="uc" placeholder="NBV_OPS" maxlength="12" autocomplete="off" spellcheck="false"></div>
      <div class="f"><label>PREFIJO AEROLÃNEA
        <span class="hi" tabindex="0">?<span class="tt">Se buscarÃ¡n todos los pilotos en IVAO cuyo callsign empiece con este prefijo.</span></span>
      </label><input type="text" id="cA" class="uc" value="NBV" maxlength="6" autocomplete="off" spellcheck="false"></div>
      <div class="f"><label>INTERVALO SCAN (seg)</label><input type="number" id="cI" value="45" min="15" max="180" step="5"></div>
      <div class="f"><label>ROUTE INFO
        <span class="hi" tabindex="0">?<span class="tt">Timing inteligente: 1er aviso ~15min tras despegue (si hay info), 2Âº a mitad del vuelo (siempre). Calcula automÃ¡ticamente desde EET del plan de vuelo IVAO.</span></span>
      </label>
        <select id="cRI">
          <option value="smart">Inteligente (15min + mitad vuelo)</option>
          <option value="10">Fijo cada 10 min</option>
          <option value="15">Fijo cada 15 min</option>
          <option value="20">Fijo cada 20 min</option>
          <option value="30">Fijo cada 30 min</option>
        </select>
      </div>
      <div class="f"><label>CORS PROXY</label><input type="text" id="cP" value="https://corsproxy.io/?" spellcheck="false"></div>
      <div class="f"><label>AUTO-SEND MENSAJES
        <span class="hi" tabindex="0">?<span class="tt">Si desactivado, los mensajes se generan pero hay que enviarlos manualmente desde cada tarjeta de vuelo.</span></span>
      </label>
        <select id="cAuto">
          <option value="1">AutomÃ¡tico (enviar al detectar fase)</option>
          <option value="0">Manual (solo generar, envÃ­o manual)</option>
        </select>
      </div>
    </div>
  </div>

  <!-- â•â•â• ROSTER â•â•â• -->
  <div class="roster" id="rosterP">
    <h3>Roster pilotos â€” SimBrief</h3>
    <div class="roster-help">Asocia callsigns NBV a usernames de SimBrief para enviar loadsheets automÃ¡ticos. Los pilotos sin mapping reciben solo WX y trÃ¡fico.</div>
    <div id="rosterList"></div>
    <button class="roster-add" onclick="addRosterRow()">+ AÃ±adir piloto</button>
  </div>

  <!-- â•â•â• STATUS â•â•â• -->
  <div class="sb idle" id="sBar"><div class="d"></div><span id="sTxt">Configurar y pulsar INICIAR</span></div>

  <!-- â•â•â• STATS â•â•â• -->
  <div class="stats" id="statsBar" style="display:none">
    <div class="stat"><span class="n acc" id="stTotal">0</span> activos</div>
    <div class="stat"><span class="n wrn" id="stPre">0</span> preflight</div>
    <div class="stat"><span class="n inf" id="stEnr">0</span> en ruta</div>
    <div class="stat"><span class="n cpdlc" id="stDsc">0</span> descenso</div>
    <div class="stat"><span class="n ok" id="stLnd">0</span> landed</div>
    <div class="stat"><span class="n acc" id="stMsgs">0</span> TELEXs</div>
  </div>
  <!-- Roster summary: visible pilots with SimBrief mapping -->
  <div id="rosterChips" style="display:none;padding:4px 0;font:.58rem var(--mono);color:var(--tx3);flex-wrap:wrap;gap:4px;align-items:center"></div>

  <!-- â•â•â• DASHBOARD â•â•â• -->
  <div class="sec-h">VUELOS ACTIVOS</div>
  <div class="dash" id="dashboard">
    <div class="dash-empty" id="dashEmpty">NingÃºn vuelo NBV detectado â€” inicia el monitor</div>
  </div>

  <!-- â•â•â• LOG â•â•â• -->
  <div class="log" id="logBox">
    <div class="log-h"><span>Actividad</span><button onclick="clearLog()">Limpiar</button></div>
    <div class="log-empty" id="logEmpty">Sin actividad</div>
  </div>

  <!-- â•â•â• MESSAGE HISTORY â•â•â• -->
  <div class="mh" id="msgHistory">
    <div class="mh-h" onclick="toggleMsgHistory()">
      <span>ğŸ“‹ HISTORIAL DE MENSAJES <span class="mh-cnt" id="mhCount">0</span></span>
      <button onclick="event.stopPropagation();clearMsgHistory()">Limpiar</button>
    </div>
    <div class="mh-body" id="mhBody">
      <table class="mh-tbl">
        <thead><tr><th>HORA</th><th>CALLSIGN</th><th>TIPO</th><th>MSG</th><th>ESTADO</th></tr></thead>
        <tbody id="mhRows"></tbody>
      </table>
      <div id="mhEmpty" style="text-align:center;padding:12px;color:var(--tx3);font:.62rem var(--mono)">Sin mensajes enviados</div>
    </div>
  </div>

  <!-- â•â•â• AOC FULLSCREEN OVERLAY â•â•â• -->
  <div id="aocOverlay" class="aoc-overlay" style="display:none">
    <div class="aoc-header">
      <div class="aoc-brand">
        <span class="aoc-logo">âœˆ</span>
        <div><div class="aoc-title">AirNubeiro AOC</div><div class="aoc-sub">Operations Control Center</div></div>
      </div>
      <div class="aoc-clock" id="aocClock">00:00:00Z</div>
      <div class="aoc-stats">
        <div class="aoc-st"><span id="aocTotal">0</span> ACTIVOS</div>
        <div class="aoc-st"><span id="aocPre">0</span> PRE</div>
        <div class="aoc-st"><span id="aocEnr">0</span> ENR</div>
        <div class="aoc-st"><span id="aocDsc">0</span> DSC</div>
        <div class="aoc-st"><span id="aocLnd">0</span> LND</div>
      </div>
      <button class="aoc-close" onclick="toggleAoc()">âœ• CERRAR</button>
    </div>
    <div class="aoc-board" id="aocBoard">
      <table class="aoc-tbl">
        <thead>
          <tr><th>CALLSIGN</th><th>ACFT</th><th>DEP</th><th>ARR</th><th>FL</th><th>GS</th><th>HDG</th><th>FASE</th><th>EET</th><th>ENR</th><th>PARKING</th><th>MSGS</th></tr>
        </thead>
        <tbody id="aocRows"></tbody>
      </table>
      <div class="aoc-empty" id="aocEmpty">Ningun vuelo NBV detectado â€” inicia el monitor</div>
    </div>
    <div class="aoc-footer">AirNubeiro OPS Center v4.0 â€” Dispatch Automatizado</div>
  </div>

  <!-- â•â•â• FOOTER â•â•â• -->
  <div class="ftr">
    <div class="br">âœˆ AirNubeiro OPS Center</div>
    <div class="lg">Creado por Varo para AirNubeiro â€” Todos los derechos reservados Â© 2026</div>
  </div>

</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  OPS CENTER â€” AirNubeiro
//  MonitorizaciÃ³n automÃ¡tica IVAO + Dispatch TELEX
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const HURL = 'http://www.hoppie.nl/acars/system/connect.html';
const IVAO_WHAZZUP = 'https://api.ivao.aero/v2/tracker/whazzup';
const SIMBRIEF_API = 'https://www.simbrief.com/api/xml.fetcher.php';
const METAR_API = 'https://aviationweather.gov/api/data/metar';
const TAF_API = 'https://aviationweather.gov/api/data/taf';
const SIGMET_API = 'https://aviationweather.gov/api/data/airsigmet';
const PIREP_API = 'https://aviationweather.gov/api/data/pirep';

const $ = id => document.getElementById(id);
let monitorInterval = null;
let flights = {}; // callsign â†’ flight state object
let roster = {};  // callsign â†’ simbriefUser
let totalMsgsSent = 0;
let lastIvaoData = null; // cached for route info

// â”€â”€ Audio â”€â”€
let audioCtx;
function beep(freq = 880, dur = 0.15, vol = 0.25) {
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = freq; g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  } catch(e) {}
}
function notifySound() { beep(800, 0.12); setTimeout(() => beep(1100, 0.15), 160); }

// â”€â”€ Config â”€â”€
function saveCfg() {
  try { localStorage.setItem('an_ops', JSON.stringify({
    l: $('cL').value, s: $('cS').value, a: $('cA').value,
    p: $('cP').value, i: $('cI').value, ri: $('cRI').value, auto: $('cAuto').value, roster
  })); } catch(e) {}
}
function loadCfg() {
  try {
    const c = JSON.parse(localStorage.getItem('an_ops'));
    if (c) {
      $('cL').value = c.l||''; $('cS').value = c.s||''; $('cA').value = c.a||'NBV';
      if(c.p) $('cP').value = c.p; if(c.i) $('cI').value = c.i; if(c.ri) $('cRI').value = c.ri; if(c.auto) $('cAuto').value = c.auto;
      if(c.roster) roster = c.roster;
    }
  } catch(e) {}
}
['cL','cS','cA','cP','cI','cRI','cAuto'].forEach(id => $(id).addEventListener('change', saveCfg));

function toggleCfg() { $('cfgP').classList.toggle('v'); $('rosterP').classList.toggle('v'); $('btnCfg').classList.toggle('on'); }

// â”€â”€ Roster management â”€â”€
function renderRoster() {
  const list = $('rosterList');
  list.innerHTML = '';
  Object.entries(roster).forEach(([cs, sb]) => {
    const row = document.createElement('div');
    row.className = 'roster-row';
    row.innerHTML = `
      <input type="text" class="uc" value="${esc(cs)}" placeholder="NBV123" maxlength="10" onchange="updateRoster(this)" data-old="${esc(cs)}">
      <input type="text" value="${esc(sb)}" placeholder="SimBrief user" onchange="updateRoster(this)">
      <button class="rm" onclick="removeRoster('${esc(cs)}')" title="Eliminar">âœ•</button>`;
    list.appendChild(row);
  });
}
function addRosterRow() {
  roster[''] = '';
  renderRoster();
  const inputs = $('rosterList').querySelectorAll('input');
  if (inputs.length) inputs[inputs.length-2].focus();
}
function updateRoster(el) {
  const row = el.closest('.roster-row');
  const inputs = row.querySelectorAll('input');
  const oldCs = inputs[0].dataset.old;
  const newCs = inputs[0].value.trim().toUpperCase();
  const newSb = inputs[1].value.trim();
  if (oldCs !== newCs) delete roster[oldCs];
  if (newCs) roster[newCs] = newSb;
  inputs[0].dataset.old = newCs;
  saveCfg();
  renderRosterChips();
}
function removeRoster(cs) { delete roster[cs]; renderRoster(); saveCfg(); renderRosterChips(); }

// â”€â”€ Helpers â”€â”€
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
function ts() { return new Date().toISOString().replace('T',' ').substring(0,19) + 'Z'; }
function tsShort() { return new Date().toISOString().substring(11,19); }
function ss(c, t) { $('sBar').className = 'sb ' + c; $('sTxt').textContent = t; }
function proxy(url) { const p = $('cP').value.trim(); return p ? `${p}${encodeURIComponent(url)}` : url; }

document.querySelectorAll('.uc').forEach(e => e.addEventListener('input', () => { e.value = e.value.toUpperCase(); }));

// â”€â”€ Hoppie request â”€â”€
async function hReq(to, type, packet) {
  const url = proxy(HURL);
  const r = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ logon: $('cL').value.trim(), from: $('cS').value.trim().toUpperCase(), to, type, packet }).toString()
  });
  return (await r.text()).trim();
}

// â”€â”€ Send TELEX with chunking â”€â”€
// Hoppie only supports ASCII â€” strip accents/Ã± before sending
function sanitizeForHoppie(txt) {
  if (!txt) return '';
  return txt
    .replace(/[Ã¡Ã Ã¢Ã¤]/gi, m => m === m.toUpperCase() ? 'A' : 'a')
    .replace(/[Ã©Ã¨ÃªÃ«]/gi, m => m === m.toUpperCase() ? 'E' : 'e')
    .replace(/[Ã­Ã¬Ã®Ã¯]/gi, m => m === m.toUpperCase() ? 'I' : 'i')
    .replace(/[Ã³Ã²Ã´Ã¶]/gi, m => m === m.toUpperCase() ? 'O' : 'o')
    .replace(/[ÃºÃ¹Ã»Ã¼]/gi, m => m === m.toUpperCase() ? 'U' : 'u')
    .replace(/Ã±/g, 'n').replace(/Ã‘/g, 'N')
    .replace(/Â¿/g, '').replace(/Â¡/g, '')
    .replace(/[^\x00-\x7F]/g, ''); // strip any remaining non-ASCII
}
async function sendTelex(to, body) {
  const clean = sanitizeForHoppie(body);
  const chunks = splitMsg(clean, 480);
  for (let i = 0; i < chunks.length; i++) {
    const prefix = chunks.length > 1 ? `[${i+1}/${chunks.length}] ` : '';
    const raw = await hReq(to, 'telex', prefix + chunks[i]);
    if (!raw.toLowerCase().startsWith('ok')) throw new Error(raw);
    if (i < chunks.length - 1) await sleep(500);
  }
  totalMsgsSent++;
  return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MESSAGE HISTORY & ANTI-DUPLICATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const SENT_STORAGE_KEY = 'an_ops_sent_registry';
const HIST_STORAGE_KEY = 'an_ops_msg_history';
let sentRegistry = {};   // { "callsign_dep_arr_phase": timestamp }
let msgHistory = [];      // [{ time, callsign, phase, msgId, status, label }]

function loadSentRegistry() {
  try {
    const s = localStorage.getItem(SENT_STORAGE_KEY);
    if (s) sentRegistry = JSON.parse(s);
    const h = localStorage.getItem(HIST_STORAGE_KEY);
    if (h) msgHistory = JSON.parse(h);
    // Prune entries older than 6 hours
    const cutoff = Date.now() - 6 * 3600000;
    let pruned = 0;
    for (const k in sentRegistry) { if (sentRegistry[k] < cutoff) { delete sentRegistry[k]; pruned++; } }
    msgHistory = msgHistory.filter(m => m.ts > cutoff);
    saveSentRegistry();
    const keys = Object.keys(sentRegistry).length;
    if (keys > 0) log(`DEDUP: ${keys} registros cargados de sesion anterior (${pruned} expirados)`, 'ops');
  } catch(e) { sentRegistry = {}; msgHistory = []; log(`DEDUP: error cargando registros: ${e.message}`, 'err'); }
  renderMsgHistory();
}
function saveSentRegistry() {
  try {
    localStorage.setItem(SENT_STORAGE_KEY, JSON.stringify(sentRegistry));
    localStorage.setItem(HIST_STORAGE_KEY, JSON.stringify(msgHistory));
  } catch(e) {}
}

// Build dedup key: callsign + phase only (dep/arr can change between scans)
function dedupKey(cs, dep, arr, phase) {
  return `${cs}_${phase}`;
}

// Check if this message was already sent recently
function wasSentRecently(cs, dep, arr, phase, maxAgeMs) {
  const key = dedupKey(cs, dep, arr, phase);
  const t = sentRegistry[key];
  if (!t) return false;
  const age = Date.now() - t;
  if (age < maxAgeMs) {
    log(`DEDUP: ${key} enviado hace ${Math.round(age/60000)}min, omitiendo`, '');
    return true;
  }
  return false;
}

// Record a sent message
function recordSent(cs, dep, arr, phase, msgLabel, status) {
  const key = dedupKey(cs, dep, arr, phase);
  if (status === 'sent') {
    sentRegistry[key] = Date.now();
    // Also store generic phase key for dedup (e.g. routeinfo_2 -> routeinfo)
    const generic = phase.replace(/_\d+$/, '');
    if (generic !== phase) sentRegistry[dedupKey(cs, dep, arr, generic)] = Date.now();
    log(`DEDUP: registrado ${key}`, '');
  }
  msgHistory.push({ ts: Date.now(), cs, phase, label: msgLabel, status });
  if (msgHistory.length > 200) msgHistory = msgHistory.slice(-200);
  saveSentRegistry();
  renderMsgHistory();
}

// â”€â”€ History UI â”€â”€
function toggleMsgHistory() {
  $('mhBody').classList.toggle('open');
}
function clearMsgHistory() {
  msgHistory = [];
  sentRegistry = {};
  saveSentRegistry();
  renderMsgHistory();
}
function renderMsgHistory() {
  const rows = $('mhRows');
  const empty = $('mhEmpty');
  $('mhCount').textContent = msgHistory.length;
  if (!msgHistory.length) {
    rows.innerHTML = '';
    empty.style.display = 'block';
    return;
  }
  empty.style.display = 'none';
  // Show newest first
  const sorted = [...msgHistory].reverse();
  rows.innerHTML = sorted.map(m => {
    const t = new Date(m.ts).toISOString().substring(11,19);
    const stCls = m.status === 'sent' ? 'sent' : (m.status === 'skip' ? 'skip' : 'error');
    const stLabel = m.status === 'sent' ? 'âœ“ ENVIADO' : (m.status === 'skip' ? 'âŠ˜ OMITIDO' : 'âœ— ERROR');
    return `<tr><td>${esc(t)}</td><td>${esc(m.cs)}</td><td>${esc(m.phase)}</td><td>${esc(m.label)}</td><td><span class="mh-st ${stCls}">${stLabel}</span></td></tr>`;
  }).join('');
}
function splitMsg(txt, max) {
  if (txt.length <= max) return [txt];
  const chunks = []; let pos = 0;
  while (pos < txt.length) {
    let end = Math.min(pos + max, txt.length);
    if (end < txt.length) { const nl = txt.lastIndexOf('\n', end); if (nl > pos + 50) end = nl; }
    chunks.push(txt.substring(pos, end).trim());
    pos = end;
  }
  return chunks;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// â”€â”€ Log â”€â”€
function log(msg, cls = '') {
  $('logEmpty').style.display = 'none';
  const e = document.createElement('div');
  e.className = `log-e ${cls}`;
  e.innerHTML = `<span class="lt">${tsShort()}</span><span class="lm">${esc(msg)}</span>`;
  const box = $('logBox');
  box.insertBefore(e, box.children[1]); // after header
  // Keep max 200 entries
  while (box.children.length > 202) box.removeChild(box.lastChild);
}
function clearLog() {
  $('logBox').querySelectorAll('.log-e').forEach(e => e.remove());
  $('logEmpty').style.display = 'block';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FLIGHT STATE MACHINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Phases: PREFLIGHT â†’ ENROUTE â†’ DESCENT â†’ LANDED
// Thresholds tuned for flight sim

function detectPhase(pilot, prev) {
  // Extract tracking data safely â€” IVAO v2 may nest objects
  const track = pilot.lastTrack || {};
  const onGround = track.onGround === true || track.onGround === 1;
  const gs = typeof track.groundSpeed === 'number' ? track.groundSpeed : (typeof track.groundSpeed === 'object' ? 0 : parseInt(track.groundSpeed) || 0);
  const alt = typeof track.altitude === 'number' ? track.altitude : (typeof track.altitude === 'object' ? 0 : parseInt(track.altitude) || 0);
  const prevAlt = prev ? prev.alt : alt;
  const prevPhase = prev ? prev.phase : null;

  // LANDED: was airborne (ENROUTE or DESCENT) and now on ground
  if (onGround && (prevPhase === 'ENROUTE' || prevPhase === 'DESCENT')) {
    return 'LANDED';
  }

  // PREFLIGHT: on ground and never was airborne (or first detection)
  if (onGround && (!prevPhase || prevPhase === 'PREFLIGHT')) {
    return 'PREFLIGHT';
  }

  // If already landed, stay landed
  if (prevPhase === 'LANDED') return 'LANDED';

  // DESCENT: was enroute/descent, altitude dropping > 300ft between scans
  if (!onGround && (prevPhase === 'ENROUTE' || prevPhase === 'DESCENT')) {
    if (prevAlt - alt > 300) return 'DESCENT';
    if (prevPhase === 'DESCENT' && prevAlt - alt >= -200) return 'DESCENT'; // still descending or small level-off
  }

  // ENROUTE: airborne and not previously LANDED
  if (!onGround && prevPhase !== 'LANDED') return 'ENROUTE';

  // Fallback: on ground after unknown state
  if (onGround && gs < 5) return 'PREFLIGHT';

  return prevPhase || 'PREFLIGHT';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MESSAGE GENERATORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function genPreflight(flt) {
  const msgs = [];
  const dep = flt.dep || '????';
  const arr = flt.arr || '????';

  // 1. Try loadsheet from SimBrief if roster mapping exists
  const sbUser = roster[flt.callsign];
  if (sbUser) {
    try {
      const isNum = /^\d+$/.test(sbUser);
      const param = isNum ? `userid=${sbUser}` : `username=${encodeURIComponent(sbUser)}`;
      const resp = await fetch(proxy(`${SIMBRIEF_API}?${param}&json=1`), { signal: AbortSignal.timeout(10000) });
      if (resp.ok) {
        const o = await resp.json();
        if (o.origin && !o.fetch?.status?.includes?.('Error')) {
          const unit = o.params?.units === 'lbs' ? 'LBS' : 'KG';
          const load = [
            `=== LOADSHEET ${flt.callsign} ===`,
            `${o.origin.icao_code}/${o.destination.icao_code} ALT:${o.alternate?.icao_code||'N/A'}`,
            `ACFT:${o.aircraft?.icaocode||'?'} CI:${o.general?.costindex||'?'}`,
            `PAX:${o.weights?.pax_count||0} CARGO:${Number(o.weights?.cargo||0).toLocaleString()}${unit}`,
            `ZFW:${Number(o.weights?.est_zfw||0).toLocaleString()} TOW:${Number(o.weights?.est_tow||0).toLocaleString()} LDW:${Number(o.weights?.est_ldw||0).toLocaleString()} ${unit}`,
            `FUEL BLK:${Number(o.fuel?.plan_ramp||0).toLocaleString()} TRIP:${Number(o.fuel?.enroute_burn||0).toLocaleString()} RSV:${Number(o.fuel?.reserve||0).toLocaleString()} ${unit}`,
          ].join('\n');
          msgs.push({ id: 'loadsheet', label: 'LOADSHEET', body: load });
        }
      }
    } catch(e) {
      log(`SimBrief error para ${flt.callsign}: ${e.message}`, 'wrn');
    }
  }

  // 2. WX Briefing: METAR for dep, arr, alternate
  try {
    const icaos = [dep, arr].filter(x => x !== '????');
    if (icaos.length) {
      const mResp = await fetch(proxy(`${METAR_API}?ids=${icaos.join(',')}&format=raw&hours=2`), { signal: AbortSignal.timeout(8000) });
      const mTxt = await mResp.text();
      const tResp = await fetch(proxy(`${TAF_API}?ids=${icaos.join(',')}&format=raw&hours=6`), { signal: AbortSignal.timeout(8000) });
      const tTxt = await tResp.text();
      const wx = `=== WX BRIEFING ${flt.callsign} ===\n${dep}â†’${arr}\nMETAR:\n${mTxt.trim()}\nTAF:\n${tTxt.trim().substring(0,400)}`;
      msgs.push({ id: 'wx_brief', label: 'WX BRIEF', body: wx });
    }
  } catch(e) {
    log(`WX error para ${flt.callsign}: ${e.message}`, 'wrn');
  }

  return msgs;
}

async function genEnroute(flt) {
  const arr = flt.arr || '????';
  const msgs = [];

  // 1. Traffic at destination
  try {
    const resp = await fetch(proxy(IVAO_WHAZZUP), { signal: AbortSignal.timeout(10000) });
    const data = await resp.json();
    const pilots = data.clients?.pilots || [];
    const arriving = pilots.filter(p => p.flightPlan?.arrivalId === arr);
    const departing = pilots.filter(p => p.flightPlan?.departureId === arr);
    const total = arriving.length + departing.length;
    const density = total === 0 ? 'NINGUNO' : total <= 3 ? 'BAJO' : total <= 8 ? 'MODERADO' : 'ALTO';

    let traf = `=== TRAFFIC ${arr} ===\n${density} (ARR:${arriving.length} DEP:${departing.length})\n`;
    for (const p of arriving.slice(0, 6)) {
      traf += `${p.callsign||'?'} ${p.flightPlan?.aircraftId||'?'} FROM ${p.flightPlan?.departureId||'?'} GS${p.lastTrack?.groundSpeed||0} FL${Math.round((p.lastTrack?.altitude||0)/100)}\n`;
    }
    // ATC â€” only relevant: dest TWR/APP + area CTR/FSS (exclude GND/DEL)
    const atcs = data.clients?.atcs || [];
    const prefix2 = arr.substring(0, 2);
    const destAtc = atcs.filter(a => {
      if (!a.callsign) return false;
      const cs = a.callsign.toUpperCase();
      if (cs.includes('_GND') || cs.includes('_DEL')) return false;
      if (cs.startsWith(arr)) return true;
      if ((cs.includes('_FSS') || cs.includes('_CTR')) && cs.startsWith(prefix2)) return true;
      return false;
    });
    if (destAtc.length) {
      traf += `ATC: ${destAtc.map(a => a.callsign).join(', ')}\n`;
    } else {
      traf += `NO ATC ONLINE ${arr}\n`;
    }
    msgs.push({ id: 'traffic', label: 'TRAFFIC', body: traf });
  } catch(e) {
    log(`Traffic error ${flt.callsign}: ${e.message}`, 'wrn');
  }

  // 2. WX en-route: current METAR destination only (hours=1)
  try {
    const mResp = await fetch(proxy(`${METAR_API}?ids=${arr}&format=raw&hours=1`), { signal: AbortSignal.timeout(6000) });
    const mTxt = await mResp.text();
    if (mTxt.trim()) {
      // Only take first METAR line (most recent)
      const firstMetar = mTxt.trim().split('\n')[0];
      msgs.push({ id: 'wx_enroute', label: 'WX ENRTE', body: `=== WX EN-ROUTE ${flt.callsign} ===\nDEST ${arr} METAR:\n${firstMetar}` });
    }
  } catch(e) {}

  return msgs;
}

async function genDescent(flt) {
  const arr = flt.arr || '????';
  const msgs = [];

  // ATIS/METAR destination updated
  try {
    let atisText = '';
    try {
      const raw = await hReq('SERVER', 'inforeq', `IVAOATIS ${arr}`);
      if (raw.toLowerCase().startsWith('ok') && raw.length > 5) {
        atisText = `ATIS ${arr}: ${raw.substring(2).trim()}\n`;
      }
    } catch(e) {}

    const mResp = await fetch(proxy(`${METAR_API}?ids=${arr}&format=raw&hours=1`), { signal: AbortSignal.timeout(6000) });
    const mTxt = await mResp.text();
    const firstMetar = mTxt.trim().split('\n')[0] || '';

    const body = `=== ARRIVAL INFO ${flt.callsign} ===\n${arr}\n${atisText}METAR:\n${firstMetar}`;
    msgs.push({ id: 'arrival_info', label: 'ARR INFO', body });
  } catch(e) {
    log(`Descent WX error ${flt.callsign}: ${e.message}`, 'wrn');
  }

  // ATC congestion check â€” warn if high traffic at destination
  try {
    const ivao = lastIvaoData;
    if (ivao) {
      const pilots = ivao.clients?.pilots || [];
      const atcs = ivao.clients?.atcs || [];
      const arriving = pilots.filter(p => p.flightPlan?.arrivalId === arr);
      const departing = pilots.filter(p => p.flightPlan?.departureId === arr);
      const prefix2 = arr.substring(0, 2);
      const destAtc = atcs.filter(a => {
        if (!a.callsign) return false;
        const cs = a.callsign.toUpperCase();
        return cs.startsWith(arr) || ((cs.includes('_FSS') || cs.includes('_CTR')) && cs.startsWith(prefix2));
      });
      const hasApp = destAtc.some(a => a.callsign.includes('_APP') || a.callsign.includes('_DEP'));
      const hasTwr = destAtc.some(a => a.callsign.includes('_TWR'));
      const total = arriving.length + departing.length;

      // High traffic: >8 aircraft AND ATC present (controlled = sequencing = delays)
      // Very high: >12 aircraft
      if (total > 8 && destAtc.length > 0) {
        let warn = `=== ATC ADVISORY ${arr} ===\n`;
        if (total > 12) {
          warn += `âš  TRAFICO MUY ALTO - ${total} ACFT (${arriving.length} ARR/${departing.length} DEP)\n`;
          warn += `POSIBLE ATC DELAY EN LLEGADA\n`;
          warn += `Espere vectores extendidos o holdings.\n`;
          if (hasApp) warn += `APP activo â€” secuenciacion probable.\n`;
        } else {
          warn += `âš  TRAFICO ALTO - ${total} ACFT (${arriving.length} ARR/${departing.length} DEP)\n`;
          warn += `POSIBLE SECUENCIACION EN LLEGADA\n`;
          if (hasApp) warn += `APP activo â€” posibles vectores de separacion.\n`;
        }
        warn += `ATC: ${destAtc.map(a => a.callsign).join(', ')}\n`;
        msgs.push({ id: 'atc_delay', label: 'ATC ADVSY', body: warn });
      }
    }
  } catch(e) {
    log(`ATC check error ${flt.callsign}: ${e.message}`, 'wrn');
  }

  // Passenger connections at destination
  const connMsg = genPaxConnections(arr);
  if (connMsg) {
    msgs.push({ id: 'pax_conn', label: 'PAX CONN', body: connMsg });
  }

  return msgs;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AIRLINE & AIRPORT DATABASE (for connections, crew rotation)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Airlines by ICAO country prefix â€” mix of real low-cost, flag carriers, regional
const AIRLINES_BY_PREFIX = {
  'LE':['NBV','IBE','VLG','AEA','RYR','ANE','ELY'],         // Spain
  'LP':['NBV','TAP','NTP','RYR'],                             // Portugal
  'LF':['NBV','AFR','EZY','TVF','BEE','HOP'],                // France
  'EG':['NBV','BAW','EZY','RYR','TOM','LOG','VIR'],          // UK
  'ED':['NBV','DLH','EWG','CFG','RYR','SXS'],                // Germany
  'LI':['NBV','AZA','RYR','EZY','NOS','VOE'],                // Italy
  'EH':['NBV','KLM','TRA','EZY','RYR'],                      // Netherlands
  'EB':['NBV','BEL','TUI','RYR'],                             // Belgium
  'EI':['NBV','EIN','RYR','ASL'],                             // Ireland
  'ES':['NBV','SAS','NAX','RYR'],                             // Sweden
  'EN':['NBV','SAS','NAX','WIF'],                             // Norway
  'EK':['NBV','SAS','NAX','RYR'],                             // Denmark
  'LO':['NBV','AUA','RYR','EZY','LWG'],                      // Austria
  'LS':['NBV','SWR','EZY','EZS'],                             // Switzerland
  'LK':['NBV','CSA','TVS','RYR'],                             // Czech Republic
  'EP':['NBV','LOT','RYR','WZZ'],                             // Poland
  'LG':['NBV','AEE','RYR','OAL'],                             // Greece
  'LT':['NBV','THY','PGT','SXS','AJA'],                      // Turkey
  'LC':['NBV','CYP','RYR'],                                    // Cyprus
  'LH':['NBV','HVA','WZZ'],                                    // Hungary
  'LR':['NBV','ROT','WZZ'],                                    // Romania
  'LZ':['NBV','BUC','WZZ'],                                    // Slovakia/Bulgaria
};

// Destinations by ICAO prefix â€” major airports for connections
const DESTINATIONS_BY_PREFIX = {
  'LE':['LEMD','LEBL','LEPA','LEAL','LEMG','LEZL','LEBB','LEST','LEVC','LEXJ','GCXO','GCLP','GCFV','GCTS'],
  'LP':['LPPT','LPPR','LPFR','LPMA'],
  'LF':['LFPG','LFPO','LFBO','LFML','LFMN','LFLL','LFSB'],
  'EG':['EGLL','EGKK','EGSS','EGGW','EGCC','EGGP','EGPH','EGBB'],
  'ED':['EDDF','EDDM','EDDB','EDDL','EDDK','EDDS','EDDH'],
  'LI':['LIRF','LIMC','LIPZ','LIPE','LIMF','LIRN','LICC','LICJ'],
  'EH':['EHAM'],
  'EB':['EBBR','EBCI'],
  'EI':['EIDW','EICK'],
  'ES':['ESSA','ESGG','ESMS'],
  'EN':['ENGM','ENBR','ENZV'],
  'EK':['EKCH','EKBI'],
  'LO':['LOWW','LOWS','LOWG'],
  'LS':['LSZH','LSGG','LSZA'],
  'LK':['LKPR','LKTB'],
  'EP':['EPWA','EPKK','EPGD'],
  'LG':['LGAV','LGTS','LGIR','LGKR','LGSA'],
  'LT':['LTFM','LTAI','LTBS','LTFE'],
};

// Galician airports (AirNubeiro base)
const GALICIAN_BASES = ['LEST','LECO','LEVX'];

// Spanish domestic destinations (for next-flight national)
const SPAIN_DOMESTIC = ['LEMD','LEBL','LEPA','LEAL','LEMG','LEZL','LEBB','LEVC','LEXJ','LEZG','GCXO','GCLP','GCFV','GCTS'];

// European continental destinations (for next-flight continental)
const EUROPE_DEST = ['LFPG','EGLL','EDDF','LIRF','EHAM','EBBR','LPPT','LFBO','EDDM','LSZH','LOWW','LKPR','EPWA','EKCH','ENGM','LGAV','EIDW','ESSA'];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PAX CONNECTIONS GENERATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function genPaxConnections(arrIcao, arrivalTimeEstimate) {
  if (!arrIcao || arrIcao === '????') return '';

  // 40% probability: no connecting passengers
  if (Math.random() < 0.40) {
    return `=== CONEXIONES PAX ${arrIcao} ===\n0 PAX EN CONEXION\nNo hay pasajeros con enlaces en este vuelo.`;
  }

  const prefix = arrIcao.substring(0, 2);

  // Airlines operating at destination: own airline + country-based + some international
  const localAirlines = AIRLINES_BY_PREFIX[prefix] || ['NBV','RYR','EZY'];
  const intlAirlines = ['NBV','IBE','AFR','BAW','DLH','KLM']; // always possible
  const pool = [...new Set([...localAirlines, ...intlAirlines])];

  // Possible destinations from this airport
  const localDests = DESTINATIONS_BY_PREFIX[prefix] || [];
  const allDests = [...new Set([...localDests, ...EUROPE_DEST])].filter(d => d !== arrIcao);

  // Generate 2-4 connections
  const numConn = 2 + Math.floor(Math.random() * 3); // 2-4
  const connections = [];
  const usedDests = new Set();

  // Base departure time: ~45-120 min after estimated arrival
  const now = new Date();
  const baseMin = 45 + Math.floor(Math.random() * 75);

  for (let i = 0; i < numConn && allDests.length > 0; i++) {
    // Pick destination (no repeats)
    let dest;
    let attempts = 0;
    do {
      dest = allDests[Math.floor(Math.random() * allDests.length)];
      attempts++;
    } while (usedDests.has(dest) && attempts < 20);
    if (usedDests.has(dest)) continue;
    usedDests.add(dest);

    // Pick airline â€” 40% chance same airline (NBV), 60% local/intl
    const airline = Math.random() < 0.4 ? 'NBV' : pool[Math.floor(Math.random() * pool.length)];

    // Flight number
    const fltNum = `${airline}${String(Math.floor(Math.random() * 9000) + 1000)}`;

    // Gate â€” use real gate database
    const gate = genParking(arrIcao) || `GATE ${Math.floor(Math.random()*40)+1}`;

    // Departure time
    const depOffset = baseMin + i * (15 + Math.floor(Math.random() * 30)); // staggered
    const depTime = new Date(now.getTime() + depOffset * 60000);
    const depStr = `${String(depTime.getUTCHours()).padStart(2,'0')}:${String(depTime.getUTCMinutes()).padStart(2,'0')}z`;

    // Pax count
    const pax = Math.floor(Math.random() * 12) + 1;

    connections.push({ airline, fltNum, dest, gate, depStr, pax });
  }

  if (!connections.length) return '';

  let msg = `=== CONEXIONES PAX ${arrIcao} ===\n`;
  const totalPax = connections.reduce((s, c) => s + c.pax, 0);
  msg += `${totalPax} PAX EN CONEXION:\n`;
  for (const c of connections) {
    msg += `${c.fltNum} â†’ ${c.dest} GATE ${c.gate} ETD ${c.depStr} (${c.pax}pax)\n`;
  }

  return msg;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CREW ROTATION & NEXT FLIGHT GENERATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function genCrewInfo(flt) {
  const arr = flt.arr || '????';
  const now = new Date();
  const utcHour = now.getUTCHours();
  const utcMin = now.getUTCMinutes();

  // Estimate local hour (rough offset from ICAO prefix)
  const localOffset = getLocalOffset(arr);
  const localHour = (utcHour + localOffset + 24) % 24;
  const localMin = utcMin;

  const isBase = GALICIAN_BASES.includes(arr);
  let crewChange;
  let reason;
  let isLastFlightGoodnight = false;

  // Late night: local time >= 00:30 â†’ last flight, buenas noches
  if (localHour >= 0 && localHour < 5 && (localHour > 0 || localMin >= 30)) {
    crewChange = true;
    isLastFlightGoodnight = true;
    reason = 'ULTIMO VUELO DEL DIA';
  } else if (utcHour >= 21 || localHour >= 23) {
    crewChange = true;
    reason = 'ULTIMO VUELO DEL DIA';
  } else if (utcHour >= 19 || localHour >= 21) {
    crewChange = Math.random() < (isBase ? 0.5 : 0.7);
    reason = crewChange ? 'VUELO NOCTURNO - RELEVO PROGRAMADO' : null;
  } else {
    crewChange = Math.random() < (isBase ? 0.1 : 0.2);
    reason = crewChange ? 'RELEVO DE TRIPULACION PROGRAMADO' : null;
  }

  let msg = '';

  if (crewChange) {
    if (isLastFlightGoodnight) {
      msg += `--- TRIPULACION ---\n`;
      msg += `NO HAY MAS VUELOS PROGRAMADOS HOY\n`;
      msg += `Tripulacion libre de servicio.\n`;
      msg += `Buenas noches y buen descanso.\n`;
    } else {
      msg += `--- TRIPULACION ---\nCAMBIO DE TRIPULACION: ${reason}\n`;
      msg += `Tripulacion entrante reportar a briefing.\n`;
    }
  } else {
    msg += `--- TRIPULACION ---\nSIN CAMBIO - MISMA TRIPULACION CONTINUA\n`;

    // Generate next flight for this crew
    const nextFlt = genNextFlight(flt, arr);
    if (nextFlt) {
      msg += `PROXIMO VUELO: ${nextFlt.fltNum}\n`;
      msg += `${nextFlt.dep}â†’${nextFlt.dest} ETD ${nextFlt.etd}\n`;
      msg += `ACFT: ${flt.aircraft || '???'} GATE: ${nextFlt.gate}\n`;
      if (nextFlt.isReturn) msg += `(RETORNO A BASE)\n`;
      msg += `TURNAROUND: ${nextFlt.turnaround}min\n`;
    }
  }

  return msg;
}

// Rough UTC offset by ICAO prefix (for local time estimation)
function getLocalOffset(icao) {
  if (!icao || icao.length < 2) return 1;
  const pfx = icao.substring(0, 2);
  const offsets = {
    'LE':1,'LP':0,'LF':1,'EG':0,'ED':1,'LI':1,'EH':1,'EB':1,
    'EI':0,'ES':1,'EN':1,'EK':1,'LO':1,'LS':1,'LK':1,'EP':1,
    'LG':2,'LT':3,'LC':2,'LH':1,'LR':2,'LZ':2,
    'GC':0, // Canarias
  };
  // Canarias special case
  if (icao.startsWith('GC')) return 0;
  return offsets[pfx] ?? 1;
}

function genNextFlight(flt, currentAirport) {
  const now = new Date();
  const prefix = currentAirport.substring(0, 2);

  // Decision: return to base or continue to another destination?
  // 50% return to Galician base, 30% domestic Spain, 20% European
  const roll = Math.random();
  let dest, isReturn = false;

  if (roll < 0.50) {
    // Return to base â€” pick a Galician airport (not the current one)
    const bases = GALICIAN_BASES.filter(b => b !== currentAirport);
    dest = bases.length ? bases[Math.floor(Math.random() * bases.length)] : GALICIAN_BASES[0];
    isReturn = true;
  } else if (roll < 0.80) {
    // Domestic Spanish flight
    const domestic = SPAIN_DOMESTIC.filter(d => d !== currentAirport);
    dest = domestic[Math.floor(Math.random() * domestic.length)] || 'LEMD';
  } else {
    // European continental
    const euro = EUROPE_DEST.filter(d => d !== currentAirport);
    dest = euro[Math.floor(Math.random() * euro.length)] || 'LFPG';
  }

  // Turnaround time: 35-75 min
  const turnaround = 35 + Math.floor(Math.random() * 40);
  const etdDate = new Date(now.getTime() + turnaround * 60000);
  const etd = `${String(etdDate.getUTCHours()).padStart(2,'0')}:${String(etdDate.getUTCMinutes()).padStart(2,'0')}z`;

  // Flight number
  const fltNum = `NBV${String(Math.floor(Math.random() * 9000) + 1000)}`;

  // Gate
  const gate = genParking(currentAirport) || `STAND ${Math.floor(Math.random()*30)+1}`;

  return { fltNum, dep: currentAirport, dest, etd, gate, turnaround, isReturn };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PARKING / STAND GENERATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Generates a realistic random parking stand based on airport ICAO prefix
function genParking(icao) {
  if (!icao || icao === '????') return '';
  // AirNubeiro official stands from Manual de Procedimientos Operacionales
  const NBV_STANDS = {
    'LEST':['2','3','4','5','6','7','21','22'],'LEVX':['4','5','7'],'LEAS':['2','3'],
    'LECO':['1','3','12'],'LEXJ':['2','6'],'LEBB':['4','6','16'],
    'LEBL':['236','238','240','242','248'],'LEVC':['4','6','42'],
    'LEAL':['29','31'],'LEPA':['84','86','88','48','66'],'LEMG':['24','26','28'],
    'LEMD':['T27','T28','T29','T32','T18'],'LEIB':['18','25','27','28'],
    'LEZL':['6','7'],'GCFV':['21','22','23'],'GCLA':['7','9'],
    'GCXO':['T1','T4'],'GCRR':['T1','T3'],'GCLP':['T05','T06'],'GCTS':['14','16'],
  };
  const REAL_GATES = {
    'EGLL':['A5','A7','A10','A14','A18','A22','B32','B34','B36','B38','B42','B44','B46','C54','C56','C60','C62','301','305','307','340','501','503','505','510','520','525','544','546','555','562'],
    'LFPG':['E40','E42','E44','E46','E48','E50','K21','K24','K30','K36','L40','L42','L44','M30','M32','M34','M36','A22','A24','A26','A30','D51','D53','D55','F32','F34','F36','F38'],
    'EDDF':['A15','A17','A21','A24','A26','A50','A52','A60','A62','B20','B22','B24','B28','B30','B40','B42','B44','C14','C15','D2','D4','D6','D8','E4','E6','E8','E12','E15','E21'],
    'EHAM':['B18','B20','B22','B24','B28','C8','C10','C12','D18','D20','D22','D51','D53','D57','D59','E18','E20','E22','E24','F3','F5','F7','F9','G3','G5','G9','H1','H3','H5','H7'],
    'LIRF':['B1','B3','B5','B7','B11','B13','B15','B17','B19','B21','D1','D3','D5','D7','E1','E3','E5','E7','E11','E13','E15','E17','E19','E21','E23','E25','G1','G3','G5','G7','G9'],
    'EBBR':['A26','A28','A30','A32','A34','A40','A42','A44','A46','B50','B52','B54','B56','B58','B60','B62','B64'],
    'EIDW':['101','102','103','104','105','201','202','203','301','302','303','304','305','306','307','308'],
    'LPPT':['14','16','18','20','22','24','26','28','30','32','34','36','38','40','42','44','46','48','50','52','54','56','58'],
    'LPPR':['3','5','7','9','11','13','15','17','19','21','23','25'],
    'LOWW':['B14','B16','B18','B20','B22','B24','C28','C30','C32','C34','D42','D44','D46','D48','D50','D52','F68','F70','F72','F74','F76','G81','G83','G85'],
    'LSZH':['A10','A12','A14','A16','A20','A22','A24','A26','A28','A30','A32','A34','B51','B53','B55','B57','B59','B61','B63','B65','D31','D33','D35','D37','D39','D41','E54','E56','E58','E60','E62','E64'],
    'EKCH':['A1','A2','A3','A4','A5','A7','B5','B6','B7','B8','B9','B10','C22','C24','C26','C28','C30','C32','C34'],
    'ESSA':['1','2','3','4','5','6','7','8','10','12','14','16','18','20','22','24','26','28','30','32','34','36','38','40'],
    'ENGM':['A11','A12','A13','A14','A15','A16','B22','B24','B26','B28','B30','B32','B34','C36','C38','C40','C42','C44','D50','D52','D54','D56'],
    'LKPR':['A2','A4','A6','A8','A10','B15','B17','B19','B21','B23','B25','C30','C32','C34','C36','C38','C40'],
    'EPWA':['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29'],
    'LGAV':['A1','A2','A3','A4','A5','A6','A7','A8','A9','A10','A11','B15','B16','B17','B18','B19','B20','B21','B22','B23','B24','B25','B26'],
    'LTFM':['D201','D203','D205','D207','D209','F101','F103','F105','F107','G301','G303','G305','G307','G309'],
    'LIMC':['A1','A3','A5','A7','A9','A11','B15','B17','B19','B21','B23','B25','B27','C1','C3','C5','C7','C9'],
    'EGKK':['1','2','3','4','5','6','10','11','12','13','14','15','21','22','23','24','25','26','31','32','33','34','35','36','51','52','53','54','55','56','101','102','103'],
  };
  if (NBV_STANDS[icao]) { const sl = NBV_STANDS[icao]; return `STAND ${sl[Math.floor(Math.random()*sl.length)]}`; }
  if (REAL_GATES[icao]) { const gl = REAL_GATES[icao]; return `GATE ${gl[Math.floor(Math.random()*gl.length)]}`; }
  const prefix = icao.substring(0,2);
  const ranges = {'LE':[1,50],'LP':[1,40],'LF':[1,60],'EG':[1,60],'ED':[1,50],'LI':[1,40],'EH':[1,70],'EB':[1,60],'EI':[1,40],'ES':[1,50],'EN':[1,60],'EK':[1,40],'LO':[1,50],'LS':[1,50],'LK':[1,40],'EP':[1,30],'LG':[1,30],'LT':[1,50]};
  const r = ranges[prefix] || [1,30];
  return `STAND ${Math.floor(Math.random()*(r[1]-r[0]+1))+r[0]}`;
}

async function genLanded(flt) {
  const dep = flt.dep || '????';
  const arr = flt.arr || '????';
  const flightMin = flt.enrouteStart ? Math.round((Date.now() - flt.enrouteStart) / 60000) : 0;
  const monitorMin = flt.firstSeen ? Math.round((Date.now() - flt.firstSeen) / 60000) : 0;
  const stand = flt.assignedParking || genParking(arr);
  const msgs = [];

  // Welcome message with flight time
  const welcome = [
    `=== BIENVENIDO ${arr} ===`,
    `${flt.callsign} â€” ${dep}/${arr} (${flt.aircraft})`,
    flightMin > 0 ? `TIEMPO DE VUELO: ${Math.floor(flightMin/60)}h${String(flightMin%60).padStart(2,'0')}m` : '',
    monitorMin > flightMin + 5 ? `TIEMPO TOTAL: ${Math.floor(monitorMin/60)}h${String(monitorMin%60).padStart(2,'0')}m` : '',
    stand ? `PARKING: ${stand}` : '',
    `Gracias por volar con AirNubeiro.`,
    `Buen servicio, cielos limpios.`,
  ].filter(Boolean).join('\n');
  msgs.push({ id: 'welcome', label: 'WELCOME', body: welcome });

  // Delay report â€” check if departure was late vs planned
  const delayMsg = genDelayReport(flt);
  if (delayMsg) {
    msgs.push({ id: 'delay', label: 'DELAY RPT', body: delayMsg });
  }

  // Crew rotation + next flight
  const crewMsg = genCrewInfo(flt);
  if (crewMsg) {
    msgs.push({ id: 'crew', label: 'CREW INFO', body: `=== CREW ${flt.callsign} ===\n${arr}\n${crewMsg}` });
  }

  return msgs;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DELAY DETECTION & REPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function genDelayReport(flt) {
  // IVAO flightPlan.departureTime is typically HHMM in UTC
  // Compare with actual enrouteStart (real takeoff)
  if (!flt.plannedDepTime || !flt.enrouteStart) return null;

  let plannedMin = 0;
  const pdt = flt.plannedDepTime;

  // Parse planned departure time â€” could be HHMM, epoch seconds, or string
  if (typeof pdt === 'number') {
    if (pdt > 100000) {
      // Epoch seconds â†’ extract HHMM
      const d = new Date(pdt * 1000);
      plannedMin = d.getUTCHours() * 60 + d.getUTCMinutes();
    } else {
      // HHMM format
      plannedMin = Math.floor(pdt / 100) * 60 + (pdt % 100);
    }
  } else if (typeof pdt === 'string') {
    const m = pdt.match(/(\d{1,2}):?(\d{2})/);
    if (m) plannedMin = parseInt(m[1]) * 60 + parseInt(m[2]);
    else return null;
  } else return null;

  // Actual departure in minutes since midnight UTC
  const actualDep = new Date(flt.enrouteStart);
  const actualMin = actualDep.getUTCHours() * 60 + actualDep.getUTCMinutes();

  // Calculate delay (handle midnight crossover)
  let delayMin = actualMin - plannedMin;
  if (delayMin < -720) delayMin += 1440; // crossed midnight
  if (delayMin > 720) delayMin -= 1440;

  // Only report if delay > 15 minutes
  if (delayMin <= 15) return null;

  // Pick one of 3 delay report templates
  const templates = [
    [
      `=== DELAY REPORT ${flt.callsign} ===`,
      `${flt.dep}â†’${flt.arr}`,
      `ETD PLANIFICADO: ${String(Math.floor(plannedMin/60)).padStart(2,'0')}${String(plannedMin%60).padStart(2,'0')}z`,
      `SALIDA REAL: ${String(actualDep.getUTCHours()).padStart(2,'0')}${String(actualDep.getUTCMinutes()).padStart(2,'0')}z`,
      `DELAY: +${delayMin} MIN`,
      `---`,
      `ACCION REQUERIDA:`,
      `Reportar motivo del retraso a OPS.`,
      `Codigo delay IATA requerido.`,
      `Contactar jefe de operaciones antes`,
      `de iniciar siguiente rotacion.`,
    ],
    [
      `=== DELAY REPORT ${flt.callsign} ===`,
      `${flt.dep}â†’${flt.arr}`,
      `RETRASO DETECTADO: +${delayMin} MIN`,
      `ETD ${String(Math.floor(plannedMin/60)).padStart(2,'0')}${String(plannedMin%60).padStart(2,'0')}z â†’ REAL ${String(actualDep.getUTCHours()).padStart(2,'0')}${String(actualDep.getUTCMinutes()).padStart(2,'0')}z`,
      `---`,
      `DOCUMENTACION PENDIENTE:`,
      `Completar formulario de incidencia`,
      `operacional post-vuelo.`,
      `Incluir codigo IATA y descripcion`,
      `del motivo del retraso.`,
      `Entregar en briefing room o via email`,
      `a ops@airnubeiro.va`,
    ],
    [
      `=== DELAY REPORT ${flt.callsign} ===`,
      `${flt.dep}â†’${flt.arr} â€” DELAY +${delayMin}MIN`,
      `PLAN: ${String(Math.floor(plannedMin/60)).padStart(2,'0')}${String(plannedMin%60).padStart(2,'0')}z / REAL: ${String(actualDep.getUTCHours()).padStart(2,'0')}${String(actualDep.getUTCMinutes()).padStart(2,'0')}z`,
      `---`,
      `PAPERWORK REQUERIDO:`,
      `Se requiere informe de retraso.`,
      `Rellenar delay report antes de`,
      `abandonar la aeronave.`,
      `Motivo + codigo IATA + firma PIC.`,
      `Copia a dispatch y crew planning.`,
    ],
  ];

  const tpl = templates[Math.floor(Math.random() * templates.length)];
  return tpl.join('\n');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROUTE INFO â€” ATCs, SIGMETs, PIREPs, METAR en ruta
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Haversine distance in nautical miles
function haversineNm(lat1, lon1, lat2, lon2) {
  const R = 3440.065; // Earth radius in nm
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// Bearing from point 1 to point 2 (degrees)
function bearing(lat1, lon1, lat2, lon2) {
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
  const x = Math.cos(lat1*Math.PI/180) * Math.sin(lat2*Math.PI/180) - Math.sin(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.cos(dLon);
  return ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;
}

// Check if a point is roughly "ahead" of pilot (within Â±100Â° of heading)
function isAhead(pilotLat, pilotLon, pilotHdg, targetLat, targetLon) {
  const brg = bearing(pilotLat, pilotLon, targetLat, targetLon);
  let diff = Math.abs(brg - pilotHdg);
  if (diff > 180) diff = 360 - diff;
  return diff < 100;
}

// Format IVAO frequency (stored as Hz integer â†’ MHz string)
function fmtFreq(f) {
  if (!f) return '---';
  if (f > 100000) return (f / 1000000).toFixed(3);
  if (f > 100) return (f / 1000).toFixed(3);
  return String(f);
}

// Determine ATC position type from callsign
function atcType(cs) {
  if (cs.includes('_DEL')) return 'DEL';
  if (cs.includes('_GND')) return 'GND';
  if (cs.includes('_TWR')) return 'TWR';
  if (cs.includes('_APP') || cs.includes('_DEP')) return 'APP';
  if (cs.includes('_CTR')) return 'CTR';
  if (cs.includes('_FSS')) return 'FSS';
  return 'ATC';
}

async function genRouteInfo(flt) {
  const msgs = [];
  const ivao = lastIvaoData;
  if (!ivao) return msgs;

  const pLat = flt.lat, pLon = flt.lng;
  if (!pLat && !pLon) return msgs;

  const hdg = flt.heading || 0;
  const RADIUS_NM = 400;
  let body = `=== ROUTE INFO ${flt.callsign} ===\n${flt.dep}â†’${flt.arr} FL${Math.round(flt.alt/100)} GS${flt.gs}\n`;

  // â”€â”€ 1. ATCs in corridor â”€â”€
  // En route: only CTR and FSS
  // Destination area: include APP/TWR for arrival airport
  const atcs = ivao.clients?.atcs || [];
  const enrouteAtc = [];
  const destAtc = [];
  const arrPrefix = (flt.arr || '').substring(0, 4);
  for (const a of atcs) {
    if (!a.callsign || !a.lastTrack) continue;
    const aLat = a.lastTrack.latitude, aLon = a.lastTrack.longitude;
    if (!aLat && !aLon) continue;
    const type = atcType(a.callsign.toUpperCase());
    if (type === 'GND' || type === 'DEL') continue;
    const dist = haversineNm(pLat, pLon, aLat, aLon);
    if (dist > RADIUS_NM) continue;
    const ahead = isAhead(pLat, pLon, hdg, aLat, aLon);
    const freq = a.atcSession?.frequency || a.frequency || null;
    const entry = { cs: a.callsign, type, freq: fmtFreq(freq), dist: Math.round(dist), ahead };
    // Destination ATC: callsign starts with arrival ICAO
    const csUp = a.callsign.toUpperCase();
    if (arrPrefix && csUp.startsWith(arrPrefix)) {
      destAtc.push(entry);
    } else if (type === 'CTR' || type === 'FSS') {
      if (ahead || dist <= 200) enrouteAtc.push(entry);
    }
  }
  enrouteAtc.sort((a, b) => (b.ahead - a.ahead) || (a.dist - b.dist));
  destAtc.sort((a, b) => a.dist - b.dist);

  if (enrouteAtc.length) {
    body += `--- ATC EN RUTA (CTR/FSS) ---\n`;
    for (const a of enrouteAtc.slice(0, 8)) {
      body += `${a.cs} ${a.freq} ${a.type} ${a.dist}nm\n`;
    }
  }
  if (destAtc.length) {
    body += `--- ATC DESTINO ${flt.arr} ---\n`;
    for (const a of destAtc.slice(0, 6)) {
      body += `${a.cs} ${a.freq} ${a.type}\n`;
    }
  }
  if (!enrouteAtc.length && !destAtc.length) {
    body += `NO ATC ACTIVO EN RUTA/DESTINO\n`;
  }

  // Keep relevantAtc reference for SIGMET prefix matching
  const relevantAtc = [...enrouteAtc, ...destAtc];

  // â”€â”€ 2. SIGMETs â”€â”€
  try {
    const sResp = await fetch(proxy(`${SIGMET_API}?format=json`), { signal: AbortSignal.timeout(8000) });
    const sData = await sResp.json();
    const relevantSig = [];
    if (Array.isArray(sData)) {
      for (const s of sData) {
        // Check if SIGMET has coordinate info and is near route
        const sLat = s.lat || (s.coords?.[0]?.lat);
        const sLon = s.lon || (s.coords?.[0]?.lon);
        if (sLat && sLon) {
          const dist = haversineNm(pLat, pLon, sLat, sLon);
          if (dist < RADIUS_NM) {
            relevantSig.push({ raw: s.rawAirSigmet || s.rawSigmet || `${s.hazard||'?'} ${s.severity||''} ${s.icaoId||''}`, dist: Math.round(dist) });
          }
        } else if (s.rawAirSigmet || s.rawSigmet) {
          // No coords â€” include if ICAO prefix matches route area
          const raw = s.rawAirSigmet || s.rawSigmet || '';
          const icao = s.icaoId || '';
          const depPfx = flt.dep.substring(0, 2);
          const arrPfx = flt.arr.substring(0, 2);
          if (icao.startsWith(depPfx) || icao.startsWith(arrPfx)) {
            relevantSig.push({ raw: raw.substring(0, 160), dist: null });
          }
        }
      }
    }
    if (relevantSig.length) {
      body += `--- SIGMET ---\n`;
      for (const s of relevantSig.slice(0, 5)) {
        body += `${s.raw.substring(0,140)}${s.dist ? ` (${s.dist}nm)` : ''}\n`;
      }
    }
  } catch(e) {
    log(`SIGMET fetch error: ${e.message}`, 'wrn');
  }

  // â”€â”€ 3. PIREPs â”€â”€
  try {
    const pResp = await fetch(proxy(`${PIREP_API}?format=json&age=4`), { signal: AbortSignal.timeout(8000) });
    const pData = await pResp.json();
    const relevantPirep = [];
    if (Array.isArray(pData)) {
      for (const p of pData) {
        const prLat = p.lat || p.latitude;
        const prLon = p.lon || p.longitude;
        if (!prLat || !prLon) continue;
        const dist = haversineNm(pLat, pLon, prLat, prLon);
        if (dist > RADIUS_NM) continue;
        // Only include if has significant info (turbulence, icing)
        const turb = p.turbulenceCondition || p.tbInt || p.turbulence || '';
        const ice = p.icingCondition || p.icInt || p.icing || '';
        if (!turb && !ice) continue;
        const alt = p.altitude || p.fltlvl || '???';
        relevantPirep.push({ raw: p.rawOb || `FL${alt} TURB:${turb||'NIL'} ICE:${ice||'NIL'}`, dist: Math.round(dist) });
      }
    }
    if (relevantPirep.length) {
      body += `--- PIREP ---\n`;
      for (const p of relevantPirep.slice(0, 5)) {
        body += `${p.raw.substring(0,140)} (${p.dist}nm)\n`;
      }
    }
  } catch(e) {
    log(`PIREP fetch error: ${e.message}`, 'wrn');
  }

  // â”€â”€ 4. METAR destino â”€â”€
  try {
    if (flt.arr && flt.arr !== '????') {
      const mResp = await fetch(proxy(`${METAR_API}?ids=${flt.arr}&format=raw&hours=1`), { signal: AbortSignal.timeout(6000) });
      const mTxt = await mResp.text();
      if (mTxt.trim()) {
        const firstMetar = mTxt.trim().split('\n')[0];
        body += `--- METAR DESTINO ---\n${firstMetar}\n`;
      }
    }
  } catch(e) {}

  // Assign parking stand (generate once, reuse)
  if (!flt.assignedParking) flt.assignedParking = genParking(flt.arr);
  if (flt.assignedParking) {
    body += `--- PARKING ASIGNADO ---\n${flt.arr}: ${flt.assignedParking}\n`;
  }

  msgs.push({ id: 'route_info', label: 'ROUTE INFO', body });
  return msgs;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EET ESTIMATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function estimateEnrouteMin(pilot, flt) {
  // Strategy 1: IVAO flight plan EET
  const fp = pilot.flightPlan;
  if (fp?.eet) {
    const eet = parseInt(fp.eet);
    if (eet > 0) {
      // IVAO EET can be in seconds (large numbers) or HHMM format
      if (eet > 10000) return Math.round(eet / 60); // seconds â†’ minutes
      if (eet > 100) {
        // HHMM format: 0130 = 1h30m
        const h = Math.floor(eet / 100);
        const m = eet % 100;
        return h * 60 + m;
      }
      return eet; // assume minutes
    }
  }

  // Strategy 2: SimBrief (if roster mapping exists)
  const sbUser = roster[flt.callsign];
  if (sbUser && flt._sbEet) return flt._sbEet; // cached from preflight fetch

  // Strategy 3: Distance / groundspeed
  if (flt.dep !== '????' && flt.arr !== '????' && flt.lat && flt.lng) {
    // Approximate: use depâ†’arr distance / avg cruise speed
    // We don't have arr coordinates directly, but we can estimate
    // from current GS. Typical jet cruise: 420-480kt
    const gs = flt.gs > 100 ? flt.gs : 440; // use current GS or typical
    // Use remaining distance estimate: if we have dep/arr lat/lng we could compute
    // For now, use a simpler heuristic from EET or typical flight durations
    // Short haul (same country prefix): ~90min, medium: ~180min, long: ~360min
    const depPfx = flt.dep.substring(0, 1);
    const arrPfx = flt.arr.substring(0, 1);
    const samePfx2 = flt.dep.substring(0, 2) === flt.arr.substring(0, 2);
    if (samePfx2) return 75; // domestic ~1h15
    if (depPfx === arrPfx) return 150; // same region ~2h30
    return 300; // intercontinental ~5h
  }

  return 0; // cannot estimate
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MONITOR LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function scan() {
  const prefix = $('cA').value.trim().toUpperCase();
  if (!prefix) return;

  try {
    // Cache-busting: append timestamp to prevent CORS proxy caching stale data
    const ivaoUrl = `${IVAO_WHAZZUP}?_t=${Date.now()}`;
    const resp = await fetch(proxy(ivaoUrl), {
      signal: AbortSignal.timeout(25000),
      headers: { 'Cache-Control': 'no-cache', 'Pragma': 'no-cache' }
    });
    if (!resp.ok) throw new Error(`IVAO HTTP ${resp.status}`);
    const text = await resp.text();
    let data;
    try { data = JSON.parse(text); } catch(e) {
      log(`IVAO: respuesta truncada o invalida (${text.length} chars)`, 'err');
      return;
    }
    lastIvaoData = data; // cache for route info
    const allPilots = data.clients?.pilots || [];
    const allAtcs = data.clients?.atcs || [];
    log(`IVAO: ${allPilots.length} pilotos, ${allAtcs.length} ATCs`, '');
    const nbvPilots = allPilots.filter(p => p.callsign && p.callsign.toUpperCase().startsWith(prefix));
    if (nbvPilots.length > 0) {
      log(`${prefix}: ${nbvPilots.length} detectados [${nbvPilots.map(p => {
        const ph = p.lastTrack?.onGround ? 'GND' : `FL${Math.round((p.lastTrack?.altitude||0)/100)}`;
        return `${p.callsign}(${ph})`;
      }).join(', ')}]`, 'ops');
    } else {
      log(`${prefix}: ningun piloto detectado`, '');
    }

    // Track which callsigns are still online
    const onlineCs = new Set(nbvPilots.map(p => p.callsign.toUpperCase()));

    // Mark offline flights (keep for 5 min then remove)
    for (const cs of Object.keys(flights)) {
      if (!onlineCs.has(cs)) {
        if (!flights[cs].offlineSince) {
          flights[cs].offlineSince = Date.now();
          log(`${cs} desconectado de IVAO`, 'wrn');
        } else if (Date.now() - flights[cs].offlineSince > 300000) {
          delete flights[cs];
        }
      }
    }

    // Process each NBV pilot
    for (const pilot of nbvPilots) {
      const cs = pilot.callsign.toUpperCase();
      const fp = pilot.flightPlan;
      const prev = flights[cs] || null;
      const track = pilot.lastTrack || {};

      // Safe extraction â€” IVAO v2 can return nested objects for some fields
      const safeNum = v => typeof v === 'number' ? v : (typeof v === 'object' ? 0 : parseFloat(v) || 0);
      const safeStr = v => typeof v === 'string' ? v : (typeof v === 'object' ? (v?.id || v?.code || '') : String(v || ''));

      const curAlt = safeNum(track.altitude);
      const curGs = safeNum(track.groundSpeed);
      const curLat = safeNum(track.latitude);
      const curLng = safeNum(track.longitude);
      const curHdg = safeNum(track.heading || track.transponderHeading);
      const curOnGnd = track.onGround === true || track.onGround === 1;
      const curAcft = safeStr(fp?.aircraftId);
      const curDep = safeStr(fp?.departureId);
      const curArr = safeStr(fp?.arrivalId);

      const newPhase = detectPhase(pilot, prev);
      const phaseChanged = prev && prev.phase !== newPhase;

      // Update or create flight record â€” ALL dynamic data refreshes every scan
      flights[cs] = {
        callsign: cs,
        phase: newPhase,
        prevPhase: prev?.phase || null,
        dep: curDep || prev?.dep || '????',
        arr: curArr || prev?.arr || '????',
        alt: curAlt,
        prevAlt: prev?.alt || curAlt,
        gs: curGs,
        heading: curHdg || prev?.heading || 0,
        onGround: curOnGnd,
        lat: curLat,
        lng: curLng,
        aircraft: curAcft || prev?.aircraft || '????',
        plannedDepTime: prev?.plannedDepTime || fp?.departureTime || null,
        firstSeen: prev?.firstSeen || Date.now(),
        lastSeen: Date.now(),
        // Route info smart timing
        enrouteStart: prev?.enrouteStart || 0,
        estEnrouteMin: prev?.estEnrouteMin || 0,
        riSent1: prev?.riSent1 || false,
        riSent2: prev?.riSent2 || false,
        assignedParking: prev?.assignedParking || null,
        lastRouteInfo: prev?.lastRouteInfo || 0,
        routeInfoCount: prev?.routeInfoCount || 0,
        offlineSince: null,
        sent: prev?.sent || { preflight: false, enroute: false, descent: false, landed: false },
        msgStatus: prev?.msgStatus || {},
      };

      const flt = flights[cs];

      // New flight detected
      if (!prev) {
        log(`âœˆ ${cs} detectado: ${flt.dep}â†’${flt.arr} (${flt.aircraft})`, 'ops');
        notifySound();
      }

      // Phase transition â†’ trigger messages
      if (phaseChanged) {
        log(`${cs}: ${prev.phase} â†’ ${newPhase}`, 'ops');
      }

      // On entering ENROUTE: estimate flight time and record start
      if (newPhase === 'ENROUTE' && !flt.enrouteStart) {
        flt.enrouteStart = Date.now();
        flt.estEnrouteMin = estimateEnrouteMin(pilot, flt);
        if (flt.estEnrouteMin > 0) {
          log(`${cs}: EET estimado ${Math.floor(flt.estEnrouteMin/60)}h${String(Math.round(flt.estEnrouteMin%60)).padStart(2,'0')}m`, '');
        }
      }

      // Auto-generate and optionally send messages on phase entry
      const autoSend = $('cAuto').value === '1';

      // Phase dedup: check both in-memory flag and localStorage registry
      // This prevents re-sending on page reload if same flight still active
      if (newPhase === 'PREFLIGHT' && !flt.sent.preflight) {
        if (wasSentRecently(cs, flt.dep, flt.arr, 'preflight', 90*60000)) {
          flt.sent.preflight = true; // mark in-memory to skip future checks
          log(`${cs}: preflight ya enviado (sesiÃ³n anterior), omitido`, '');
        } else {
          flt.sent.preflight = true;
          processMessages(flt, 'preflight', genPreflight, autoSend);
        }
      }
      if (newPhase === 'ENROUTE' && !flt.sent.enroute) {
        if (wasSentRecently(cs, flt.dep, flt.arr, 'enroute', 90*60000)) {
          flt.sent.enroute = true;
          log(`${cs}: enroute ya enviado (sesiÃ³n anterior), omitido`, '');
        } else {
          flt.sent.enroute = true;
          processMessages(flt, 'enroute', genEnroute, autoSend);
        }
      }
      if (newPhase === 'DESCENT' && !flt.sent.descent) {
        if (wasSentRecently(cs, flt.dep, flt.arr, 'descent', 60*60000)) {
          flt.sent.descent = true;
          log(`${cs}: descent ya enviado (sesiÃ³n anterior), omitido`, '');
        } else {
          flt.sent.descent = true;
          processMessages(flt, 'descent', genDescent, autoSend);
        }
      }
      if (newPhase === 'LANDED' && !flt.sent.landed) {
        if (wasSentRecently(cs, flt.dep, flt.arr, 'landed', 60*60000)) {
          flt.sent.landed = true;
          log(`${cs}: landed ya enviado (sesiÃ³n anterior), omitido`, '');
        } else {
          flt.sent.landed = true;
          processMessages(flt, 'landed', genLanded, autoSend);
        }
      }

      // Smart ROUTE INFO timing for ENROUTE/DESCENT flights
      if ((newPhase === 'ENROUTE' || newPhase === 'DESCENT') && flt.lat && flt.lng) {
        const riMode = $('cRI').value;
        const minSinceEnroute = flt.enrouteStart ? (Date.now() - flt.enrouteStart) / 60000 : 0;
        // Route info dedup: check if one was sent recently (prevents re-send on restart)
        const riDedupMs = riMode === 'smart' ? 12*60000 : Math.max(5, parseInt(riMode)||10)*60000;
        const riRecentlySent = wasSentRecently(cs, flt.dep, flt.arr, 'routeinfo', riDedupMs);

        // On restart: if route info was recently sent (from localStorage), restore in-memory flags
        if (riRecentlySent && !flt.riSent1) {
          flt.riSent1 = true;
          log(`${cs}: route info reciente (sesiÃ³n anterior), restaurando estado`, '');
        }

        if (riMode === 'smart') {
          // â”€â”€ Smart timing â”€â”€
          // RI #1: ~15 min after entering enroute (only if significant info available)
          if (!flt.riSent1 && minSinceEnroute >= 15) {
            flt.riSent1 = true;
            flt.routeInfoCount++;
            const riKey = `routeinfo_${flt.routeInfoCount}`;
            // Generate and check if there's significant content before sending
            processMessagesConditional(flt, riKey, genRouteInfo, autoSend, true);
          }
          // RI #2: midpoint of estimated enroute time (always send)
          if (!flt.riSent2 && flt.estEnrouteMin > 0) {
            const midpoint = flt.estEnrouteMin / 2;
            // Only if midpoint is at least 10 min after RI #1
            if (minSinceEnroute >= midpoint && midpoint >= 25) {
              flt.riSent2 = true;
              flt.routeInfoCount++;
              const riKey = `routeinfo_${flt.routeInfoCount}`;
              processMessages(flt, riKey, genRouteInfo, autoSend);
            }
          }
          // Fallback: if no EET estimated but >30min in cruise and only sent RI#1
          if (!flt.riSent2 && flt.estEnrouteMin === 0 && minSinceEnroute >= 30 && flt.riSent1) {
            flt.riSent2 = true;
            flt.routeInfoCount++;
            const riKey = `routeinfo_${flt.routeInfoCount}`;
            processMessages(flt, riKey, genRouteInfo, autoSend);
          }
        } else {
          // â”€â”€ Fixed interval mode â”€â”€
          const riMinutes = Math.max(5, parseInt(riMode) || 10);
          const elapsed = (Date.now() - flt.lastRouteInfo) / 60000;
          if (elapsed >= riMinutes) {
            flt.lastRouteInfo = Date.now();
            flt.routeInfoCount++;
            const riKey = `routeinfo_${flt.routeInfoCount}`;
            processMessages(flt, riKey, genRouteInfo, autoSend);
          }
        }
      }
    }

    updateDashboard();
    updateStats();
    updateAoc();
    renderRosterChips();

    const n = Object.keys(flights).filter(cs => !flights[cs].offlineSince).length;
    ss('live', `Monitor activo â€” ${n} vuelo(s) NBV â€” ${tsShort()}`);

  } catch(e) {
    log(`Scan error: ${e.message}`, 'err');
    ss('err', `âœ— Error: ${e.message}`);
  }
}

async function processMessages(flt, phase, generatorFn, autoSend) {
  try {
    const msgs = await generatorFn(flt);
    for (const m of msgs) {
      const key = `${phase}_${m.id}`;
      flt.msgStatus[key] = autoSend ? 'sending' : 'pending';
      flt['msg_' + key] = m.body; // store body for manual send
      updateDashboard();

      if (autoSend) {
        try {
          await sendTelex(flt.callsign, m.body);
          flt.msgStatus[key] = 'sent';
          log(`âœ“ ${m.label} â†’ ${flt.callsign}`, 'ok');
          recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'sent');
          await sleep(800); // rate limit between messages
        } catch(e) {
          flt.msgStatus[key] = 'error';
          log(`âœ— ${m.label} â†’ ${flt.callsign}: ${e.message}`, 'err');
          recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'error');
        }
      } else {
        log(`${m.label} generado para ${flt.callsign} (envÃ­o manual)`, '');
      }
    }
    updateDashboard();
    updateStats();
  } catch(e) {
    log(`Error generando msgs ${phase} para ${flt.callsign}: ${e.message}`, 'err');
  }
}

// Conditional version: only sends if the message body contains significant info
// (SIGMETs, PIREPs, or notable ATC changes). Used for 15min post-departure check.
async function processMessagesConditional(flt, phase, generatorFn, autoSend, requireSignificant) {
  try {
    const msgs = await generatorFn(flt);
    for (const m of msgs) {
      // Check if content is "significant" â€” has SIGMETs, PIREPs, or many ATCs
      const hasSignificant = !requireSignificant ||
        m.body.includes('SIGMET') ||
        m.body.includes('PIREP') ||
        (m.body.match(/ATC EN RUTA/i) && (m.body.match(/\n/g)||[]).length > 8);

      if (!hasSignificant) {
        log(`${m.label} ${flt.callsign}: sin info significativa, omitido`, '');
        recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'skip');
        continue;
      }

      const key = `${phase}_${m.id}`;
      flt.msgStatus[key] = autoSend ? 'sending' : 'pending';
      flt['msg_' + key] = m.body;
      updateDashboard();

      if (autoSend) {
        try {
          await sendTelex(flt.callsign, m.body);
          flt.msgStatus[key] = 'sent';
          log(`âœ“ ${m.label} â†’ ${flt.callsign} (significativo)`, 'ok');
          recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'sent');
          await sleep(800);
        } catch(e) {
          flt.msgStatus[key] = 'error';
          log(`âœ— ${m.label} â†’ ${flt.callsign}: ${e.message}`, 'err');
          recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'error');
        }
      } else {
        log(`${m.label} generado para ${flt.callsign} (envÃ­o manual)`, '');
      }
    }
    updateDashboard();
    updateStats();
  } catch(e) {
    log(`Error generando msgs ${phase} para ${flt.callsign}: ${e.message}`, 'err');
  }
}

// Manual send from dashboard
async function manualSend(cs, key) {
  const flt = flights[cs];
  if (!flt) return;
  const body = flt['msg_' + key];
  if (!body) return;
  flt.msgStatus[key] = 'sending';
  updateDashboard();
  try {
    await sendTelex(cs, body);
    flt.msgStatus[key] = 'sent';
    log(`âœ“ ${key} â†’ ${cs} (manual)`, 'ok');
  } catch(e) {
    flt.msgStatus[key] = 'error';
    log(`âœ— ${key} â†’ ${cs}: ${e.message}`, 'err');
  }
  updateDashboard();
  updateStats();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DASHBOARD RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateDashboard() {
  const dash = $('dashboard');
  const activeFlights = Object.values(flights).filter(f => !f.offlineSince);

  if (activeFlights.length === 0) {
    dash.innerHTML = '<div class="dash-empty" id="dashEmpty">NingÃºn vuelo NBV detectado</div>';
    return;
  }

  // Sort: preflight first, then enroute, descent, landed
  const order = { PREFLIGHT: 0, ENROUTE: 1, DESCENT: 2, LANDED: 3 };
  activeFlights.sort((a, b) => (order[a.phase]||9) - (order[b.phase]||9));

  dash.innerHTML = '';
  for (const f of activeFlights) {
    const card = document.createElement('div');
    card.className = `flt-card ph-${f.phase.toLowerCase()}`;

    const phaseLabel = { PREFLIGHT: 'PREFLIGHT', ENROUTE: 'EN RUTA', DESCENT: 'DESCENSO', LANDED: 'LANDED' }[f.phase] || f.phase;

    // Message badges
    let msgsHtml = '';
    for (const [key, status] of Object.entries(f.msgStatus)) {
      const label = key.replace(/_/g, ' ').toUpperCase();
      const clickable = status === 'pending' || status === 'error';
      const onclick = clickable ? `onclick="manualSend('${esc(f.callsign)}','${esc(key)}')"` : '';
      const cursor = clickable ? 'cursor:pointer;' : '';
      msgsHtml += `<span class="flt-msg ${status}" style="${cursor}" ${onclick} title="${status === 'pending' ? 'Click para enviar' : status}">${label}: ${status === 'sent' ? 'âœ“' : status === 'sending' ? 'â³' : status === 'error' ? 'âœ— retry' : 'ğŸ“¤'}</span>`;
    }

    card.innerHTML = `
      <div>
        <div class="flt-cs">${esc(f.callsign)}</div>
        <div class="flt-route">${esc(f.dep)} â†’ ${esc(f.arr)}</div>
        <div class="flt-ac">${esc(f.aircraft)}</div>
      </div>
      <div class="flt-data">
        <div class="flt-d">ALT <span>FL${Math.round(f.alt/100)}</span></div>
        <div class="flt-d">GS <span>${f.gs}kt</span></div>
        <div class="flt-d">GND <span>${f.onGround?'SI':'NO'}</span></div>
        ${f.estEnrouteMin > 0 ? `<div class="flt-d">EET <span>${Math.floor(f.estEnrouteMin/60)}h${String(Math.round(f.estEnrouteMin%60)).padStart(2,'0')}m</span></div>` : ''}
        ${f.enrouteStart ? `<div class="flt-d">ENR <span>${Math.round((Date.now()-f.enrouteStart)/60000)}min</span></div>` : ''}
        ${f.routeInfoCount > 0 ? `<div class="flt-d">RI <span>Ã—${f.routeInfoCount}</span></div>` : ''}
      </div>
      <div class="flt-phase ${f.phase.toLowerCase()}">${phaseLabel}</div>
      ${msgsHtml ? `<div class="flt-msgs">${msgsHtml}</div>` : ''}`;

    dash.appendChild(card);
  }
}

function updateStats() {
  const active = Object.values(flights).filter(f => !f.offlineSince);
  $('stTotal').textContent = active.length;
  $('stPre').textContent = active.filter(f => f.phase === 'PREFLIGHT').length;
  $('stEnr').textContent = active.filter(f => f.phase === 'ENROUTE').length;
  $('stDsc').textContent = active.filter(f => f.phase === 'DESCENT').length;
  $('stLnd').textContent = active.filter(f => f.phase === 'LANDED').length;
  $('stMsgs').textContent = totalMsgsSent;
  $('statsBar').style.display = 'flex';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MONITOR CONTROL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toggleMonitor() {
  if (monitorInterval) {
    clearInterval(monitorInterval);
    monitorInterval = null;
    $('btnMonitor').classList.remove('on');
    $('btnMonitor').classList.remove('stop');
    $('monIco').textContent = 'â–¶';
    $('monTxt').textContent = 'INICIAR';
    ss('ok', 'Monitor detenido');
    log('Monitor detenido', 'wrn');
  } else {
    if (!$('cL').value.trim() || !$('cS').value.trim()) {
      ss('err', 'âœ— Configura logon y callsign');
      return;
    }
    const iv = Math.max(15, parseInt($('cI').value) || 45) * 1000;
    log(`Monitor iniciado â€” scan cada ${iv/1000}s â€” prefijo: ${$('cA').value.toUpperCase()}`, 'ops');
    ss('snd', 'Escaneando IVAO...');
    scan(); // immediate first scan
    monitorInterval = setInterval(scan, iv);
    $('btnMonitor').classList.add('on');
    $('monIco').innerHTML = '<span class="dot-live"></span>';
    $('monTxt').textContent = 'DETENER';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AOC FULLSCREEN MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let aocOpen = false;
let aocClockInterval = null;

function toggleAoc() {
  aocOpen = !aocOpen;
  $('aocOverlay').style.display = aocOpen ? 'flex' : 'none';
  if (aocOpen) {
    updateAoc();
    aocClockInterval = setInterval(() => { updateAocClock(); updateAoc(); }, 1000);
    updateAocClock();
    // Try native fullscreen
    try { document.documentElement.requestFullscreen?.(); } catch(e) {}
  } else {
    if (aocClockInterval) clearInterval(aocClockInterval);
    try { if (document.fullscreenElement) document.exitFullscreen?.(); } catch(e) {}
  }
}

function updateAocClock() {
  const now = new Date();
  $('aocClock').textContent = now.toISOString().substring(11, 19) + 'Z';
}

function updateAoc() {
  if (!aocOpen) return;
  const active = Object.values(flights).filter(f => !f.offlineSince);
  $('aocTotal').textContent = active.length;
  $('aocPre').textContent = active.filter(f => f.phase === 'PREFLIGHT').length;
  $('aocEnr').textContent = active.filter(f => f.phase === 'ENROUTE').length;
  $('aocDsc').textContent = active.filter(f => f.phase === 'DESCENT').length;
  $('aocLnd').textContent = active.filter(f => f.phase === 'LANDED').length;

  const rows = $('aocRows');
  const empty = $('aocEmpty');

  if (!active.length) {
    rows.innerHTML = '';
    empty.style.display = 'block';
    return;
  }
  empty.style.display = 'none';
  const order = { PREFLIGHT: 0, ENROUTE: 1, DESCENT: 2, LANDED: 3 };
  active.sort((a, b) => (order[a.phase] || 9) - (order[b.phase] || 9));

  rows.innerHTML = active.map(f => {
    const phCls = { PREFLIGHT: 'pre', ENROUTE: 'enr', DESCENT: 'dsc', LANDED: 'lnd' }[f.phase] || '';
    const phTxt = { PREFLIGHT: 'PREFLIGHT', ENROUTE: 'EN RUTA', DESCENT: 'DESCENSO', LANDED: 'LANDED' }[f.phase] || f.phase;
    const eet = f.estEnrouteMin > 0 ? `${Math.floor(f.estEnrouteMin / 60)}h${String(Math.round(f.estEnrouteMin % 60)).padStart(2, '0')}` : '-';
    const enr = f.enrouteStart ? `${Math.round((Date.now() - f.enrouteStart) / 60000)}m` : '-';
    const park = f.assignedParking || '-';
    const sbUser = roster[f.callsign];
    const sbTag = sbUser ? `<span style="color:#34c759;font-size:.5rem" title="SB: ${esc(sbUser)}">SB</span>` : '';
    let msgBadges = '';
    for (const [key, status] of Object.entries(f.msgStatus)) {
      const label = key.replace(/_/g, ' ').substring(0, 10);
      msgBadges += `<span class="aoc-msg ${status}">${label}</span>`;
    }
    return `<tr>
      <td class="aoc-cs">${esc(f.callsign)} ${sbTag}</td>
      <td>${esc(f.aircraft)}</td>
      <td>${esc(f.dep)}</td>
      <td>${esc(f.arr)}</td>
      <td>FL${Math.round(f.alt / 100)}</td>
      <td>${f.gs}kt</td>
      <td>${Math.round(f.heading)}${'Â°'}</td>
      <td><span class="aoc-ph ${phCls}">${phTxt}</span></td>
      <td>${eet}</td>
      <td>${enr}</td>
      <td>${park}</td>
      <td>${msgBadges || '-'}</td>
    </tr>`;
  }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROSTER CHIPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderRosterChips() {
  const el = $('rosterChips');
  const entries = Object.entries(roster);
  if (!entries.length) { el.style.display = 'none'; return; }
  el.style.display = 'flex';
  el.innerHTML = '<span style="color:var(--tx3);margin-right:2px">ROSTER:</span>' +
    entries.map(([cs, sb]) => {
      const isActive = !!flights[cs.toUpperCase()];
      const cls = sb ? (isActive ? 'rc-mapped' : 'rc-mapped') : 'rc-unmapped';
      const dot = isActive ? '<span style="color:var(--ok)">â—</span> ' : '';
      return `<span class="${cls}">${dot}${esc(cs)}${sb ? ' (SB:'+esc(sb)+')' : ''}</span>`;
    }).join('');
}

// â”€â”€ Init â”€â”€
loadCfg(); renderRoster(); loadSentRegistry(); renderRosterChips();
if (!$('cL').value.trim()) { $('cfgP').classList.add('v'); $('rosterP').classList.add('v'); $('btnCfg').classList.add('on'); }
else ss('ok', `OPS ${$('cS').value||'???'} â€” listo`);

// PWA
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(e => {});
}
</script>
</body>
</html>
