<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>OPS Center ‚Äî AirNubeiro</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0062B8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg0: #050a14; --bg1: #0a1222; --bg2: #0f1830; --bg3: #071018;
    --brd: #162240; --brd-f: #2e8cf0;
    --acc: #2e8cf0; --acc-d: #1a6bc4; --acc-g: rgba(46,140,240,0.10);
    --tx1: #e2eaf4; --tx2: #7d8faa; --tx3: #3e5170;
    --ok: #34d399; --err: #f87171; --wrn: #fbbf24; --inf: #60a5fa; --cpdlc: #a78bfa;
    --ops: #38bdf8;
    --mono: 'JetBrains Mono','Courier New',monospace;
    --sans: 'IBM Plex Sans',-apple-system,sans-serif;
  }
  html { font-size: 15px; }
  body { font-family: var(--sans); background: var(--bg0); color: var(--tx1); min-height: 100dvh; -webkit-font-smoothing: antialiased; }

  /* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
  .app { max-width: 900px; margin: 0 auto; padding: 12px; min-height: 100dvh; display: flex; flex-direction: column; gap: 10px; }

  /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
  .hdr { display: flex; align-items: center; justify-content: space-between; padding: 10px 0 8px; border-bottom: 1px solid var(--brd); }
  .hdr-l { display: flex; align-items: center; gap: 10px; }
  .hdr-ico { width: 38px; height: 38px; background: linear-gradient(135deg, #0062B8 0%, #2e8cf0 100%); border-radius: 8px; display: flex; align-items: center; justify-content: center; font: 700 14px/1 var(--mono); color: #fff; letter-spacing: -0.5px; }
  .hdr-t h1 { font: 600 1.05rem/1.2 var(--mono); color: var(--tx1); letter-spacing: -0.3px; }
  .hdr-t .sub { font: 400 0.62rem var(--mono); color: var(--tx3); letter-spacing: 0.5px; }
  .hdr-r { display: flex; gap: 5px; align-items: center; }

  .ib { background: 0; border: 1px solid var(--brd); color: var(--tx2); height: 36px; padding: 0 12px; border-radius: 6px; cursor: pointer; font: 600 0.7rem var(--mono); display: flex; align-items: center; justify-content: center; gap: 5px; transition: .15s; }
  .ib:hover { border-color: var(--acc-d); color: var(--acc); }
  .ib.on { border-color: var(--ok); color: var(--ok); background: rgba(52,211,153,.08); }
  .ib.stop { border-color: var(--err); color: var(--err); }

  .dot-live { width: 8px; height: 8px; background: var(--ok); border-radius: 50%; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0%,100%{ opacity:1 } 50%{ opacity:.3 } }

  /* ‚îÄ‚îÄ Config ‚îÄ‚îÄ */
  .cfg { display: none; background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; padding: 14px; }
  .cfg.v { display: block; }
  .cfg h3 { font: 600 0.72rem var(--mono); color: var(--acc); letter-spacing: 1px; margin-bottom: 10px; text-transform: uppercase; }
  .cfg-g { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .f { display: flex; flex-direction: column; gap: 3px; }
  .f label { font: 500 0.62rem var(--mono); color: var(--tx3); letter-spacing: .6px; text-transform: uppercase; }
  .f input, .f select, .f textarea { background: var(--bg3); border: 1px solid var(--brd); border-radius: 5px; padding: 8px 10px; color: var(--tx1); font: 400 0.82rem var(--mono); outline: 0; transition: border .15s; }
  .f input:focus, .f select:focus { border-color: var(--brd-f); }
  .uc { text-transform: uppercase; }

  /* ‚îÄ‚îÄ Status bar ‚îÄ‚îÄ */
  .sb { display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 6px; font: 500 0.72rem var(--mono); }
  .sb .d { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
  .sb.idle { background: var(--bg2); color: var(--tx3); } .sb.idle .d { background: var(--tx3); }
  .sb.ok { background: rgba(52,211,153,.06); color: var(--ok); } .sb.ok .d { background: var(--ok); }
  .sb.snd { background: var(--acc-g); color: var(--acc); } .sb.snd .d { background: var(--acc); }
  .sb.err { background: rgba(248,113,113,.06); color: var(--err); } .sb.err .d { background: var(--err); }
  .sb.live { background: rgba(244,114,182,.06); color: var(--ops); } .sb.live .d { background: var(--ops); animation: pulse 1.5s infinite; }

  /* ‚îÄ‚îÄ M√≥dulos externos (FSUIPC / phpVMS / Discord) ‚îÄ‚îÄ */
  .cfg-module { margin-top: 8px; padding: 8px 10px; background: var(--bg3,#071018); border: 1px solid var(--brd); border-radius: 6px; }
  .cfg-mod-hdr { display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px; }
  .cfg-mod-ttl { font: 600 0.65rem var(--mono); letter-spacing: .5px; }
  .cfg-mod-ttl.fsuipc  { color: #34d399; }
  .cfg-mod-ttl.phpvms  { color: #a78bfa; }
  .cfg-mod-ttl.discord { color: #7289da; }
  .mod-toggle { display: flex; align-items: center; gap: 5px; cursor: pointer; font: 500 0.63rem var(--mono); color: var(--tx2); }
  .mod-toggle input[type=checkbox] { width: 12px; height: 12px; }
  .mod-toggle.fsuipc  input { accent-color: #34d399; }
  .mod-toggle.phpvms  input { accent-color: #a78bfa; }
  .mod-toggle.discord input { accent-color: #7289da; }
  .cfg-mod-fields { opacity: .45; pointer-events: none; margin-top: 4px; }
  .cfg-mod-fields.active { opacity: 1; pointer-events: auto; }
  .cfg-mod-status { font: 500 0.6rem var(--mono); color: var(--tx3); margin-top: 4px; }
  /* Badge de fuente en tarjetas de vuelo */
  .src-sim    { font: 700 0.52rem var(--mono); color: #34d399; background: rgba(52,211,153,.1); border: 1px solid rgba(52,211,153,.3); border-radius: 3px; padding: 1px 4px; }
  .src-phpvms { font: 700 0.52rem var(--mono); color: #a78bfa; background: rgba(167,139,250,.1); border: 1px solid rgba(167,139,250,.3); border-radius: 3px; padding: 1px 4px; }
  .src-ivao   { font: 700 0.52rem var(--mono); color: var(--tx3); background: var(--bg3,#071018); border: 1px solid var(--brd); border-radius: 3px; padding: 1px 4px; }
  /* FSUIPC header badge */
  .fsuipc-badge { display: inline-flex; align-items: center; gap: 3px; padding: 2px 6px; border-radius: 4px; font: 700 0.58rem var(--mono); letter-spacing: .5px; border: 1px solid; transition: all .3s; }
  .fsuipc-badge.src-ivao   { color: var(--tx3); border-color: var(--brd); background: transparent; }
  .fsuipc-badge.src-fsuipc { color: #34d399; border-color: rgba(52,211,153,.4); background: rgba(52,211,153,.08); }
  .fsuipc-badge.src-connecting { color: #fbbf24; border-color: rgba(251,191,36,.4); background: rgba(251,191,36,.06); animation: fblink 1.2s ease-in-out infinite; }
  @keyframes fblink { 0%,100%{opacity:1}50%{opacity:.4} }
  .fsuipc-badge .fd { width: 5px; height: 5px; border-radius: 50%; background: currentColor; }
  /* API Key encryption UI */
  .apikey-wrap { position: relative; }
  .apikey-wrap input { padding-right: 72px; }
  .apikey-actions { position: absolute; right: 4px; top: 50%; transform: translateY(-50%); display: flex; gap: 3px; }
  .apikey-btn { padding: 2px 7px; border-radius: 3px; font: 600 0.58rem var(--mono); cursor: pointer; border: 1px solid; transition: .12s; white-space: nowrap; }
  .apikey-btn.validate { background: rgba(167,139,250,.12); border-color: rgba(167,139,250,.4); color: #a78bfa; }
  .apikey-btn.validate:hover { background: rgba(167,139,250,.22); }
  .apikey-btn.clear { background: rgba(248,113,113,.08); border-color: rgba(248,113,113,.3); color: #f87171; }
  .apikey-badge { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; border-radius: 4px; font: 500 0.62rem var(--mono); }
  .apikey-badge.ok  { background: rgba(52,211,153,.1); border: 1px solid rgba(52,211,153,.3); color: #34d399; }
  .apikey-badge.err { background: rgba(248,113,113,.08); border: 1px solid rgba(248,113,113,.3); color: #f87171; }
  /* Discord events grid */
  .dc-events { display: grid; grid-template-columns: 1fr 1fr; gap: 3px 8px; margin-top: 3px; }
  .dc-events label { display: flex; align-items: center; gap: 4px; font: 500 0.62rem var(--mono); color: var(--tx2); cursor: pointer; }
  .dc-events input { accent-color: #7289da; width: 11px; height: 11px; }
  .dc-test-btn { margin-top: 5px; padding: 3px 9px; background: rgba(114,137,218,.12); border: 1px solid rgba(114,137,218,.3); color: #7289da; border-radius: 4px; font: 600 0.62rem var(--mono); cursor: pointer; }
  .dc-test-btn:hover { background: rgba(114,137,218,.22); }

  /* ‚îÄ‚îÄ Roster ‚îÄ‚îÄ */
  .roster { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; padding: 14px; }
  .roster h3 { font: 600 0.72rem var(--mono); color: var(--ops); letter-spacing: 1px; margin-bottom: 8px; text-transform: uppercase; }
  .roster-help { font: 400 0.68rem var(--sans); color: var(--tx3); margin-bottom: 10px; line-height: 1.4; }
  .roster-row { display: flex; gap: 6px; align-items: center; margin-bottom: 5px; }
  .roster-row input { flex: 1; }
  .roster-row .rm { background: none; border: 1px solid var(--brd); color: var(--tx3); width: 28px; height: 28px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; display: flex; align-items: center; justify-content: center; }
  .roster-row .rm:hover { border-color: var(--err); color: var(--err); }
  .roster-add { background: rgba(244,114,182,.08); border: 1px dashed rgba(244,114,182,.3); color: var(--ops); padding: 6px; border-radius: 5px; width: 100%; font: 500 0.68rem var(--mono); cursor: pointer; transition: .12s; }
  .roster-add:hover { background: rgba(244,114,182,.15); }

  /* ‚îÄ‚îÄ Dashboard ‚îÄ‚îÄ */
  .dash { display: flex; flex-direction: column; gap: 8px; }
  .dash-empty { text-align: center; padding: 30px; color: var(--tx3); font: 400 0.8rem var(--mono); }

  .flt-card { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; padding: 12px; display: grid; grid-template-columns: auto 1fr auto; gap: 10px; align-items: center; transition: border-color .2s; }
  .flt-card.ph-preflight { border-left: 3px solid var(--wrn); }
  .flt-card.ph-enroute { border-left: 3px solid var(--inf); }
  .flt-card.ph-descent { border-left: 3px solid var(--cpdlc); }
  .flt-card.ph-landed { border-left: 3px solid var(--ok); }

  .flt-cs { font: 700 1rem var(--mono); color: var(--acc); }
  .flt-route { font: 500 0.72rem var(--mono); color: var(--tx2); margin-top: 2px; }
  .flt-ac { font: 400 0.65rem var(--mono); color: var(--tx3); }

  .flt-data { display: flex; flex-wrap: wrap; gap: 4px 12px; }
  .flt-d { font: 400 0.65rem var(--mono); color: var(--tx3); }
  .flt-d span { color: var(--tx1); font-weight: 600; }

  .flt-phase { padding: 4px 10px; border-radius: 4px; font: 700 0.62rem var(--mono); letter-spacing: .8px; text-align: center; white-space: nowrap; }
  .flt-phase.preflight { background: rgba(251,191,36,.1); color: var(--wrn); }
  .flt-phase.enroute { background: rgba(96,165,250,.1); color: var(--inf); }
  .flt-phase.descent { background: rgba(167,139,250,.1); color: var(--cpdlc); }
  .flt-phase.landed { background: rgba(52,211,153,.1); color: var(--ok); }

  .flt-msgs { grid-column: 1 / -1; display: flex; gap: 4px; flex-wrap: wrap; margin-top: 4px; }
  .flt-msg { padding: 2px 8px; border-radius: 3px; font: 500 0.58rem var(--mono); letter-spacing: .3px; }
  .flt-msg.sent { background: rgba(52,211,153,.1); color: var(--ok); }
  .flt-msg.pending { background: rgba(125,138,160,.1); color: var(--tx3); }
  .flt-msg.sending { background: rgba(224,163,72,.1); color: var(--acc); }
  .flt-msg.error { background: rgba(248,113,113,.1); color: var(--err); }

  /* ‚îÄ‚îÄ Stats bar ‚îÄ‚îÄ */
  .stats { display: flex; gap: 12px; flex-wrap: wrap; padding: 8px 0; }
  .stat { display: flex; align-items: center; gap: 5px; font: 400 0.68rem var(--mono); color: var(--tx3); }
  .stat .n { font-weight: 700; font-size: 1rem; }
  .stat .n.wrn { color: var(--wrn); }
  .stat .n.inf { color: var(--inf); }
  .stat .n.cpdlc { color: var(--cpdlc); }
  .stat .n.ok { color: var(--ok); }
  .stat .n.acc { color: var(--acc); }

  /* ‚îÄ‚îÄ Log ‚îÄ‚îÄ */
  .log { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; max-height: 260px; overflow-y: auto; }
  .log::-webkit-scrollbar { width: 4px; } .log::-webkit-scrollbar-thumb { background: var(--brd); border-radius: 2px; }
  .log-h { font: 600 0.66rem var(--mono); color: var(--tx3); letter-spacing: 1px; text-transform: uppercase; padding: 10px 12px 6px; position: sticky; top: 0; background: var(--bg1); display: flex; justify-content: space-between; align-items: center; }
  .log-h button { background: none; border: none; color: var(--tx3); font: 400 0.6rem var(--mono); cursor: pointer; } .log-h button:hover { color: var(--err); }
  .log-e { padding: 4px 12px; font: 400 0.65rem/1.5 var(--mono); border-bottom: 1px solid rgba(28,35,51,.5); display: flex; gap: 8px; }
  .log-e:last-child { border-bottom: none; }
  .log-e .lt { color: var(--tx3); flex-shrink: 0; }
  .log-e .lm { color: var(--tx2); }
  .log-e.ok .lm { color: var(--ok); }
  .log-e.err .lm { color: var(--err); }
  .log-e.wrn .lm { color: var(--wrn); }
  .log-e.ops .lm { color: var(--ops); }
  .log-empty { text-align: center; padding: 16px; color: var(--tx3); font: 400 0.7rem var(--mono); }

  /* ‚îÄ‚îÄ Sections ‚îÄ‚îÄ */
  .sec-h { font: 600 0.66rem var(--mono); color: var(--tx3); letter-spacing: 1px; text-transform: uppercase; padding: 4px 0; }

  /* ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ */
  .hi { position: relative; display: inline-flex; align-items: center; justify-content: center; width: 14px; height: 14px; background: var(--bg3); border: 1px solid var(--brd); border-radius: 50%; font: 500 0.5rem var(--mono); color: var(--tx3); cursor: help; margin-left: 4px; }
  .hi:hover .tt, .hi:focus .tt { display: block; }
  .tt { display: none; position: absolute; bottom: 120%; left: 50%; transform: translateX(-50%); background: var(--bg2); border: 1px solid var(--brd); border-radius: 6px; padding: 8px; font: 400 0.62rem/1.4 var(--sans); color: var(--tx2); width: 220px; z-index: 10; white-space: normal; }

  /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
  .ftr { text-align: center; padding: 12px 0; margin-top: auto; }
  .ftr .br { font: 600 0.62rem var(--mono); color: var(--tx3); letter-spacing: 1.5px; text-transform: uppercase; }
  .ftr .lg { font: 400 0.56rem var(--sans); color: var(--tx3); margin-top: 4px; opacity: .6; }

  /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
  @media (max-width: 600px) {
    html { font-size: 14px; }
    .app { padding: 8px; }
    .cfg-g { grid-template-columns: 1fr; }
    .flt-card { grid-template-columns: 1fr; }
    .flt-phase { justify-self: start; }
    .stats { gap: 8px; }
  }

  /* ‚îÄ‚îÄ Roster Chips ‚îÄ‚îÄ */
  #rosterChips span { background: var(--bg2); border: 1px solid var(--brd); border-radius: 4px; padding: 1px 6px; font-size: .56rem; }
  #rosterChips .rc-mapped { border-color: rgba(52,199,89,.3); color: #34c759; }
  #rosterChips .rc-unmapped { border-color: var(--brd); color: var(--tx3); }
  /* ‚îÄ‚îÄ AOC Fullscreen ‚îÄ‚îÄ */
  .aoc-overlay { position: fixed; inset: 0; z-index: 9999; background: #040810; display: flex; flex-direction: column; overflow: hidden; }
  .aoc-header { display: flex; align-items: center; gap: 20px; padding: 12px 24px; background: linear-gradient(180deg, #0a1428 0%, #060e1c 100%); border-bottom: 2px solid #0062B8; flex-shrink: 0; }
  .aoc-brand { display: flex; align-items: center; gap: 12px; }
  .aoc-logo { font-size: 1.6rem; }
  .aoc-title { font: 700 1.1rem var(--mono); color: #ffffff; letter-spacing: 3px; text-transform: uppercase; }
  .aoc-sub { font: 400 .58rem var(--mono); color: #4a7bb5; letter-spacing: 1.5px; }
  .aoc-clock { font: 700 1.6rem var(--mono); color: #2e8cf0; letter-spacing: 3px; margin-left: auto; text-shadow: 0 0 20px rgba(46,140,240,.3); }
  .aoc-stats { display: flex; gap: 16px; margin-left: 24px; }
  .aoc-st { font: 600 .6rem var(--mono); color: #6b8ab5; text-align: center; padding: 4px 8px; background: rgba(46,140,240,.05); border: 1px solid rgba(46,140,240,.15); border-radius: 6px; }
  .aoc-st span { display: block; font-size: 1.2rem; font-weight: 700; color: #e2eaf4; }
  .aoc-close { font: 600 .65rem var(--mono); background: rgba(239,68,68,.08); color: #f87171; border: 1px solid rgba(239,68,68,.25); border-radius: 6px; padding: 6px 14px; cursor: pointer; margin-left: 16px; transition: .2s; }
  .aoc-close:hover { background: rgba(239,68,68,.15); }
  .aoc-board { flex: 1; overflow-y: auto; padding: 12px 20px; }
  .aoc-tbl { width: 100%; border-collapse: collapse; font: .68rem var(--mono); }
  .aoc-tbl th { background: #0c1628; color: #4a7bb5; padding: 10px 12px; text-align: left; border-bottom: 2px solid #162240; position: sticky; top: 0; z-index: 1; letter-spacing: 1.5px; font-weight: 600; font-size: .6rem; text-transform: uppercase; }
  .aoc-tbl td { padding: 8px 12px; border-bottom: 1px solid #0f1a30; color: #c0d0e4; vertical-align: middle; }
  .aoc-tbl tr:hover td { background: rgba(46,140,240,.04); }
  .aoc-tbl .aoc-cs { font-weight: 700; color: #ffffff; font-size: .75rem; letter-spacing: .5px; }
  .aoc-tbl .aoc-ph { display: inline-block; padding: 3px 10px; border-radius: 4px; font-weight: 700; font-size: .58rem; letter-spacing: .5px; }
  .aoc-ph.pre { background: rgba(250,204,21,.08); color: #facc15; border: 1px solid rgba(250,204,21,.2); }
  .aoc-ph.enr { background: rgba(46,140,240,.08); color: #2e8cf0; border: 1px solid rgba(46,140,240,.2); }
  .aoc-ph.dsc { background: rgba(167,139,250,.08); color: #a78bfa; border: 1px solid rgba(167,139,250,.2); }
  .aoc-ph.lnd { background: rgba(52,199,89,.08); color: #34c759; border: 1px solid rgba(52,199,89,.2); }
  .aoc-empty { text-align: center; padding: 80px 20px; font: .8rem var(--mono); color: #2a4060; }
  .aoc-footer { text-align: center; padding: 10px; font: .56rem var(--mono); color: #1a3050; border-top: 1px solid #0f1a30; flex-shrink: 0; letter-spacing: 1px; }
  .aoc-msg { display: inline-block; padding: 1px 5px; border-radius: 3px; font-size: .5rem; font-weight: 600; margin: 1px; }
  .aoc-msg.sent { background: rgba(52,199,89,.15); color: #34c759; }
  .aoc-msg.sending { background: rgba(56,189,248,.15); color: #38bdf8; }
  .aoc-msg.pending { background: rgba(250,204,21,.15); color: #facc15; }
  .aoc-msg.error { background: rgba(239,68,68,.15); color: #f87171; }
  /* ‚îÄ‚îÄ Message History ‚îÄ‚îÄ */
  .mh { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; overflow: hidden; }
  .mh-h { display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; border-bottom: 1px solid var(--brd); cursor: pointer; }
  .mh-h span { font: 600 .68rem var(--mono); color: var(--tx2); letter-spacing: .5px; }
  .mh-h .mh-cnt { font: 700 .62rem var(--mono); background: var(--acc); color: var(--bg0); border-radius: 4px; padding: 1px 6px; margin-left: 6px; }
  .mh-h button { font: 400 .6rem var(--mono); background: 0; border: 1px solid var(--brd); color: var(--tx3); border-radius: 4px; padding: 2px 8px; cursor: pointer; }
  .mh-body { max-height: 300px; overflow-y: auto; display: none; }
  .mh-body.open { display: block; }
  .mh-tbl { width: 100%; border-collapse: collapse; font: .6rem var(--mono); }
  .mh-tbl th { background: var(--bg2); color: var(--tx3); padding: 4px 6px; text-align: left; position: sticky; top: 0; font-weight: 600; letter-spacing: .5px; }
  .mh-tbl td { padding: 3px 6px; border-top: 1px solid var(--brd); color: var(--tx2); vertical-align: top; }
  .mh-tbl tr:hover td { background: rgba(255,255,255,.03); }
  .mh-st { display: inline-block; padding: 1px 5px; border-radius: 3px; font-size: .55rem; font-weight: 600; }
  .mh-st.sent { background: rgba(52,199,89,.15); color: #34c759; }
  .mh-st.error { background: rgba(255,69,58,.15); color: #ff453a; }
  .mh-st.skip { background: rgba(142,142,147,.15); color: #8e8e93; }
  .mh-clickable { cursor: pointer; }
  .mh-clickable:hover td { background: rgba(46,140,240,.06) !important; }
  .mh-expand { color: var(--acc); margin-right: 4px; font-size: .65rem; transition: transform .2s; display: inline-block; }
  .mh-body-row { display: none; }
  .mh-body-row.open { display: table-row; }
  .mh-body-row td { padding: 0 6px 6px 6px !important; border-top: none !important; }
  .mh-body-pre { white-space: pre-wrap; word-break: break-all; font: .56rem/1.5 var(--mono); color: var(--tx1); background: var(--bg0); border: 1px solid var(--brd); border-radius: 4px; padding: 6px 8px; margin: 2px 0 4px 0; max-height: 200px; overflow-y: auto; }
</style>
</head>
<body>
<div class="app">

  <!-- ‚ïê‚ïê‚ïê HEADER ‚ïê‚ïê‚ïê -->
  <div class="hdr">
    <div class="hdr-l">
      <div class="hdr-ico">OPS</div>
      <div class="hdr-t">
        <h1>OPS Center</h1>
        <div class="sub">AirNubeiro ‚Äî Dispatch Automatizado</div>
      </div>
    </div>
    <div class="hdr-r">
      <button class="ib" id="btnMonitor" onclick="toggleMonitor()">
        <span id="monIco">‚ñ∂</span> <span id="monTxt">INICIAR</span>
      </button>
      <span class="fsuipc-badge src-ivao" id="fsuipcBadge" title="Fuente: IVAO Whazzup"><span class="fd"></span>IVAO</span>
      <button class="ib" id="btnAoc" onclick="toggleAoc()" title="Pantalla AOC">üñ•</button>
      <button class="ib" id="btnCfg" onclick="toggleCfg()">‚öô</button>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê CONFIG ‚ïê‚ïê‚ïê -->
  <div class="cfg" id="cfgP">
    <h3>Configuraci√≥n</h3>
    <div class="cfg-g">
      <div class="f"><label>LOGON CODE (Hoppie)</label><input type="text" id="cL" placeholder="Tu c√≥digo Hoppie" autocomplete="off" spellcheck="false"></div>
      <div class="f"><label>CALLSIGN ESTACI√ìN</label><input type="text" id="cS" class="uc" placeholder="NBV_OPS" maxlength="12" autocomplete="off" spellcheck="false"></div>
      <div class="f"><label>PREFIJO AEROL√çNEA
        <span class="hi" tabindex="0">?<span class="tt">Se buscar√°n todos los pilotos en IVAO cuyo callsign empiece con este prefijo.</span></span>
      </label><input type="text" id="cA" class="uc" value="NBV" maxlength="6" autocomplete="off" spellcheck="false"></div>
      <div class="f"><label>INTERVALO SCAN (seg)</label><input type="number" id="cI" value="45" min="15" max="180" step="5"></div>
      <div class="f"><label>ROUTE INFO
        <span class="hi" tabindex="0">?<span class="tt">Timing inteligente: 1er aviso ~15min tras despegue (si hay info), 2¬∫ a mitad del vuelo (siempre). Calcula autom√°ticamente desde EET del plan de vuelo IVAO.</span></span>
      </label>
        <select id="cRI">
          <option value="smart">Inteligente (15min + mitad vuelo)</option>
          <option value="10">Fijo cada 10 min</option>
          <option value="15">Fijo cada 15 min</option>
          <option value="20">Fijo cada 20 min</option>
          <option value="30">Fijo cada 30 min</option>
        </select>
      </div>
      <div class="f"><label>CORS PROXY</label><input type="text" id="cP" value="https://corsproxy.io/?" spellcheck="false"></div>
      <div class="f"><label>AUTO-SEND MENSAJES
        <span class="hi" tabindex="0">?<span class="tt">Si desactivado, los mensajes se generan pero hay que enviarlos manualmente desde cada tarjeta de vuelo.</span></span>
      </label>
        <select id="cAuto">
          <option value="1">Autom√°tico (enviar al detectar fase)</option>
          <option value="0">Manual (solo generar, env√≠o manual)</option>
        </select>
      </div>
    </div>

    <!-- ‚îÄ‚îÄ phpVMS Integration ‚îÄ‚îÄ -->
    <div class="cfg-module">
      <div class="cfg-mod-hdr">
        <span class="cfg-mod-ttl phpvms">üóÑ phpVMS ‚Äî Pilotos AirNubeiro</span>
        <label class="mod-toggle phpvms"><input type="checkbox" id="phpvmsEn" onchange="phpvmsOnToggle()"><span>Activar</span></label>
      </div>
      <div class="cfg-mod-fields" id="phpvmsCfgFields">
        <div class="f"><label>URL phpVMS</label><input type="text" id="phpvmsUrl" value="https://operaciones.airnubeiro.es" spellcheck="false" autocomplete="off"></div>
        <div class="f"><label>API KEY phpVMS
          <span class="hi" tabindex="0">?<span class="tt">Pega tu API Key y pulsa VALIDAR. Se verificar√° contra /api/user y se guardar√° cifrada con AES-256. Nunca se almacena en claro.</span></span>
        </label>
          <div id="apikeyDisplay"></div>
          <div class="apikey-wrap" id="apikeyInputWrap" style="display:none">
            <input type="password" id="phpvmsKeyRaw" placeholder="Pega tu API Key aqu√≠" autocomplete="off" spellcheck="false" oninput="apikeyOnInput()">
            <div class="apikey-actions">
              <button class="apikey-btn validate" id="apikeyValidateBtn" onclick="apikeyValidateAndSave()" style="display:none">‚úì VALIDAR</button>
            </div>
          </div>
        </div>
        <div class="f"><label>POLL (seg)</label><input type="number" id="phpvmsPoll" value="30" min="15" max="120" step="5"></div>
      </div>
      <div class="cfg-mod-status" id="phpvmsStatus">Desactivado</div>
    </div>

    <!-- ‚îÄ‚îÄ FSUIPC WebSocket ‚îÄ‚îÄ -->
    <div class="cfg-module">
      <div class="cfg-mod-hdr">
        <span class="cfg-mod-ttl fsuipc">‚úà FSUIPC WebSocket ‚Äî Sim Local</span>
        <label class="mod-toggle fsuipc"><input type="checkbox" id="fsuipcEn" onchange="fsuipcOnToggle()"><span>Activar</span></label>
      </div>
      <div class="cfg-mod-fields" id="fsuipcCfgFields">
        <div class="f"><label>WS URL</label><input type="text" id="fsuipcUrl" value="ws://127.0.0.1:2048" spellcheck="false" autocomplete="off"></div>
        <div class="f"><label>MI CALLSIGN (piloto local)
          <span class="hi" tabindex="0">?<span class="tt">OPS usar√° datos del simulador para este callsign en lugar de IVAO Whazzup.</span></span>
        </label><input type="text" id="fsuipcCs" class="uc" placeholder="NBV101" maxlength="12" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>POLL (ms)</label><input type="number" id="fsuipcPoll" value="500" min="200" max="2000" step="100"></div>
      </div>
      <div class="cfg-mod-status" id="fsuipcStatus">Desactivado</div>
    </div>

    <!-- ‚îÄ‚îÄ Discord Webhook ‚îÄ‚îÄ -->
    <div class="cfg-module">
      <div class="cfg-mod-hdr">
        <span class="cfg-mod-ttl discord">üí¨ Discord Webhook ‚Äî Notificaciones</span>
        <label class="mod-toggle discord"><input type="checkbox" id="discordEn" onchange="discordOnToggle()"><span>Activar</span></label>
      </div>
      <div class="cfg-mod-fields" id="discordCfgFields">
        <div class="f"><label>WEBHOOK URL</label><input type="text" id="discordUrl" placeholder="https://discord.com/api/webhooks/..." spellcheck="false" autocomplete="off"></div>
        <div class="f"><label>NOTIFICAR EN</label>
          <div class="dc-events">
            <label><input type="checkbox" id="dcEvFlight" checked> Vuelo detectado</label>
            <label><input type="checkbox" id="dcEvPhase"  checked> Cambio de fase</label>
            <label><input type="checkbox" id="dcEvTelex"  checked> TELEX enviado</label>
            <label><input type="checkbox" id="dcEvAlert"  checked> Alertas OPS</label>
          </div>
        </div>
        <button class="dc-test-btn" onclick="discordTest()">‚ñ∂ Test webhook</button>
      </div>
      <div class="cfg-mod-status" id="discordStatus">Desactivado</div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê ROSTER ‚ïê‚ïê‚ïê -->
  <div class="roster" id="rosterP">
    <h3>Roster pilotos ‚Äî SimBrief</h3>
    <div class="roster-help">Asocia callsigns NBV a usernames de SimBrief para enviar loadsheets autom√°ticos. Los pilotos sin mapping reciben solo WX y tr√°fico.</div>
    <div id="rosterList"></div>
    <button class="roster-add" onclick="addRosterRow()">+ A√±adir piloto</button>
  </div>

  <!-- ‚ïê‚ïê‚ïê STATUS ‚ïê‚ïê‚ïê -->
  <div class="sb idle" id="sBar"><div class="d"></div><span id="sTxt">Configurar y pulsar INICIAR</span></div>

  <!-- ‚ïê‚ïê‚ïê STATS ‚ïê‚ïê‚ïê -->
  <div class="stats" id="statsBar" style="display:none">
    <div class="stat"><span class="n acc" id="stTotal">0</span> activos</div>
    <div class="stat"><span class="n wrn" id="stPre">0</span> preflight</div>
    <div class="stat"><span class="n inf" id="stEnr">0</span> en ruta</div>
    <div class="stat"><span class="n cpdlc" id="stDsc">0</span> descenso</div>
    <div class="stat"><span class="n ok" id="stLnd">0</span> landed</div>
    <div class="stat"><span class="n acc" id="stMsgs">0</span> TELEXs</div>
  </div>
  <!-- Roster summary: visible pilots with SimBrief mapping -->
  <div id="rosterChips" style="display:none;padding:4px 0;font:.58rem var(--mono);color:var(--tx3);flex-wrap:wrap;gap:4px;align-items:center"></div>

  <!-- ‚ïê‚ïê‚ïê DASHBOARD ‚ïê‚ïê‚ïê -->
  <div class="sec-h">VUELOS ACTIVOS</div>
  <div class="dash" id="dashboard">
    <div class="dash-empty" id="dashEmpty">Ning√∫n vuelo NBV detectado ‚Äî inicia el monitor</div>
  </div>

  <!-- ‚ïê‚ïê‚ïê LOG ‚ïê‚ïê‚ïê -->
  <div class="log" id="logBox">
    <div class="log-h"><span>Actividad</span><button onclick="clearLog()">Limpiar</button></div>
    <div class="log-empty" id="logEmpty">Sin actividad</div>
  </div>

  <!-- ‚ïê‚ïê‚ïê MESSAGE HISTORY ‚ïê‚ïê‚ïê -->
  <div class="mh" id="msgHistory">
    <div class="mh-h" onclick="toggleMsgHistory()">
      <span>üìã HISTORIAL DE MENSAJES <span class="mh-cnt" id="mhCount">0</span></span>
      <button onclick="event.stopPropagation();clearMsgHistory()">Limpiar</button>
    </div>
    <div class="mh-body" id="mhBody">
      <table class="mh-tbl">
        <thead><tr><th>HORA</th><th>CALLSIGN</th><th>TIPO</th><th>MSG</th><th>ESTADO</th></tr></thead>
        <tbody id="mhRows"></tbody>
      </table>
      <div id="mhEmpty" style="text-align:center;padding:12px;color:var(--tx3);font:.62rem var(--mono)">Sin mensajes enviados</div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê AOC FULLSCREEN OVERLAY ‚ïê‚ïê‚ïê -->
  <div id="aocOverlay" class="aoc-overlay" style="display:none">
    <div class="aoc-header">
      <div class="aoc-brand">
        <span class="aoc-logo" style="font-size:1.8rem;filter:drop-shadow(0 0 8px rgba(46,140,240,.4))">‚úà</span>
        <div><div class="aoc-title">AirNubeiro AOC</div><div class="aoc-sub">Operations Control Center ‚Äî Dispatch Automatizado</div></div>
      </div>
      <div class="aoc-clock" id="aocClock">00:00:00Z</div>
      <div class="aoc-stats">
        <div class="aoc-st"><span id="aocTotal">0</span> ACTIVOS</div>
        <div class="aoc-st"><span id="aocPre">0</span> PRE</div>
        <div class="aoc-st"><span id="aocEnr">0</span> ENR</div>
        <div class="aoc-st"><span id="aocDsc">0</span> DSC</div>
        <div class="aoc-st"><span id="aocLnd">0</span> LND</div>
      </div>
      <button class="aoc-close" onclick="toggleAoc()">‚úï CERRAR</button>
    </div>
    <div class="aoc-board" id="aocBoard">
      <table class="aoc-tbl">
        <thead>
          <tr><th>CALLSIGN</th><th>ACFT</th><th>DEP</th><th>ARR</th><th>FL</th><th>GS</th><th>HDG</th><th>FASE</th><th>EET</th><th>ENR</th><th>PARKING</th><th>MSGS</th></tr>
        </thead>
        <tbody id="aocRows"></tbody>
      </table>
      <div class="aoc-empty" id="aocEmpty">Ningun vuelo NBV detectado ‚Äî inicia el monitor</div>
    </div>
    <div class="aoc-footer">AirNubeiro OPS Center v4.2 ‚Äî Dispatch Automatizado</div>
  </div>

  <!-- ‚ïê‚ïê‚ïê FOOTER ‚ïê‚ïê‚ïê -->
  <div class="ftr">
    <div class="br">‚úà AirNubeiro OPS Center</div>
    <div class="lg">Creado por Varo para AirNubeiro ‚Äî Todos los derechos reservados ¬© 2026</div>
  </div>

</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  OPS CENTER ‚Äî AirNubeiro
//  Monitorizaci√≥n autom√°tica IVAO + Dispatch TELEX
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const HURL = 'http://www.hoppie.nl/acars/system/connect.html';
const IVAO_WHAZZUP = 'https://api.ivao.aero/v2/tracker/whazzup';
const SIMBRIEF_API = 'https://www.simbrief.com/api/xml.fetcher.php';
const METAR_API = 'https://aviationweather.gov/api/data/metar';
const TAF_API = 'https://aviationweather.gov/api/data/taf';
const SIGMET_API = 'https://aviationweather.gov/api/data/airsigmet';
const PIREP_API = 'https://aviationweather.gov/api/data/pirep';

const $ = id => document.getElementById(id);
let monitorInterval = null;
let flights = {}; // callsign ‚Üí flight state object
let roster = {};  // callsign ‚Üí simbriefUser
let totalMsgsSent = 0;
let lastIvaoData = null; // cached for route info

// ‚îÄ‚îÄ Audio ‚îÄ‚îÄ
let audioCtx;
function beep(freq = 880, dur = 0.15, vol = 0.25) {
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = freq; g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  } catch(e) {}
}
function notifySound() { beep(800, 0.12); setTimeout(() => beep(1100, 0.15), 160); }

// ‚îÄ‚îÄ Config ‚îÄ‚îÄ
function saveCfg() {
  try { localStorage.setItem('an_ops', JSON.stringify({
    l: $('cL').value, s: $('cS').value, a: $('cA').value,
    p: $('cP').value, i: $('cI').value, ri: $('cRI').value, auto: $('cAuto').value, roster,
    fsuipcEn:   $('fsuipcEn')?.checked  || false,
    fsuipcUrl:  $('fsuipcUrl')?.value   || 'ws://127.0.0.1:2048',
    fsuipcCs:   $('fsuipcCs')?.value    || '',
    fsuipcPoll: $('fsuipcPoll')?.value  || '500',
    phpvmsEn:   $('phpvmsEn')?.checked  || false,
    phpvmsUrl:  $('phpvmsUrl')?.value   || 'https://operaciones.airnubeiro.es',
    phpvmsPoll: $('phpvmsPoll')?.value  || '30',
    discordEn:  $('discordEn')?.checked || false,
    discordUrl: $('discordUrl')?.value  || '',
    dcEvFlight: $('dcEvFlight')?.checked ?? true,
    dcEvPhase:  $('dcEvPhase')?.checked  ?? true,
    dcEvTelex:  $('dcEvTelex')?.checked  ?? true,
    dcEvAlert:  $('dcEvAlert')?.checked  ?? true,
  })); } catch(e) {}
}
function loadCfg() {
  try {
    const c = JSON.parse(localStorage.getItem('an_ops'));
    if (c) {
      $('cL').value = c.l||''; $('cS').value = c.s||''; $('cA').value = c.a||'NBV';
      if(c.p) $('cP').value = c.p; if(c.i) $('cI').value = c.i; if(c.ri) $('cRI').value = c.ri; if(c.auto) $('cAuto').value = c.auto;
      if(c.roster) roster = c.roster;
      // FSUIPC
      if(c.fsuipcUrl  && $('fsuipcUrl'))  $('fsuipcUrl').value  = c.fsuipcUrl;
      if(c.fsuipcCs   && $('fsuipcCs'))   $('fsuipcCs').value   = c.fsuipcCs;
      if(c.fsuipcPoll && $('fsuipcPoll')) $('fsuipcPoll').value = c.fsuipcPoll;
      if(c.fsuipcEn) { $('fsuipcEn').checked = true; $('fsuipcCfgFields').classList.add('active'); fsuipcConnect(); }
      // phpVMS
      if(c.phpvmsUrl  && $('phpvmsUrl'))  $('phpvmsUrl').value  = c.phpvmsUrl;
      if(c.phpvmsPoll && $('phpvmsPoll')) $('phpvmsPoll').value = c.phpvmsPoll;
      if(c.phpvmsEn) { $('phpvmsEn').checked = true; $('phpvmsCfgFields').classList.add('active'); phpvmsStart(); }
      apikeyRenderState(); // renderizar estado de API key cifrada
      // Discord
      if(c.discordUrl && $('discordUrl')) $('discordUrl').value = c.discordUrl;
      if($('dcEvFlight') && c.dcEvFlight !== undefined) $('dcEvFlight').checked = c.dcEvFlight;
      if($('dcEvPhase')  && c.dcEvPhase  !== undefined) $('dcEvPhase').checked  = c.dcEvPhase;
      if($('dcEvTelex')  && c.dcEvTelex  !== undefined) $('dcEvTelex').checked  = c.dcEvTelex;
      if($('dcEvAlert')  && c.dcEvAlert  !== undefined) $('dcEvAlert').checked  = c.dcEvAlert;
      if(c.discordEn) { $('discordEn').checked = true; $('discordCfgFields').classList.add('active'); discordSetStatus('Webhook activo', true); }
    }
  } catch(e) {}
}
['cL','cS','cA','cP','cI','cRI','cAuto'].forEach(id => $(id).addEventListener('change', saveCfg));

function toggleCfg() { $('cfgP').classList.toggle('v'); $('rosterP').classList.toggle('v'); $('btnCfg').classList.toggle('on'); }

// ‚îÄ‚îÄ Roster management ‚îÄ‚îÄ
function renderRoster() {
  const list = $('rosterList');
  list.innerHTML = '';
  Object.entries(roster).forEach(([cs, sb]) => {
    const row = document.createElement('div');
    row.className = 'roster-row';
    row.innerHTML = `
      <input type="text" class="uc" value="${esc(cs)}" placeholder="NBV123" maxlength="10" onchange="updateRoster(this)" data-old="${esc(cs)}">
      <input type="text" value="${esc(sb)}" placeholder="SimBrief user" onchange="updateRoster(this)">
      <button class="rm" onclick="removeRoster('${esc(cs)}')" title="Eliminar">‚úï</button>`;
    list.appendChild(row);
  });
}
function addRosterRow() {
  roster[''] = '';
  renderRoster();
  const inputs = $('rosterList').querySelectorAll('input');
  if (inputs.length) inputs[inputs.length-2].focus();
}
function updateRoster(el) {
  const row = el.closest('.roster-row');
  const inputs = row.querySelectorAll('input');
  const oldCs = inputs[0].dataset.old;
  const newCs = inputs[0].value.trim().toUpperCase();
  const newSb = inputs[1].value.trim();
  if (oldCs !== newCs) delete roster[oldCs];
  if (newCs) roster[newCs] = newSb;
  inputs[0].dataset.old = newCs;
  saveCfg();
  renderRosterChips();
}
function removeRoster(cs) { delete roster[cs]; renderRoster(); saveCfg(); renderRosterChips(); }

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
function ts() { return new Date().toISOString().replace('T',' ').substring(0,19) + 'Z'; }
function tsShort() { return new Date().toISOString().substring(11,19); }
function ss(c, t) { $('sBar').className = 'sb ' + c; $('sTxt').textContent = t; }
function proxy(url) { const p = $('cP').value.trim(); return p ? `${p}${encodeURIComponent(url)}` : url; }

document.querySelectorAll('.uc').forEach(e => e.addEventListener('input', () => { e.value = e.value.toUpperCase(); }));

// ‚îÄ‚îÄ Hoppie request ‚îÄ‚îÄ
async function hReq(to, type, packet) {
  const url = proxy(HURL);
  const r = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ logon: $('cL').value.trim(), from: $('cS').value.trim().toUpperCase(), to, type, packet }).toString()
  });
  return (await r.text()).trim();
}

// ‚îÄ‚îÄ Send TELEX with chunking ‚îÄ‚îÄ
// Hoppie only supports ASCII ‚Äî strip accents/√± before sending
function sanitizeForHoppie(txt) {
  if (!txt) return '';
  return txt
    .replace(/[√°√†√¢√§]/gi, m => m === m.toUpperCase() ? 'A' : 'a')
    .replace(/[√©√®√™√´]/gi, m => m === m.toUpperCase() ? 'E' : 'e')
    .replace(/[√≠√¨√Æ√Ø]/gi, m => m === m.toUpperCase() ? 'I' : 'i')
    .replace(/[√≥√≤√¥√∂]/gi, m => m === m.toUpperCase() ? 'O' : 'o')
    .replace(/[√∫√π√ª√º]/gi, m => m === m.toUpperCase() ? 'U' : 'u')
    .replace(/√±/g, 'n').replace(/√ë/g, 'N')
    .replace(/¬ø/g, '').replace(/¬°/g, '')
    .replace(/[^\x00-\x7F]/g, ''); // strip any remaining non-ASCII
}
async function sendTelex(to, body) {
  const clean = sanitizeForHoppie(body);
  const chunks = splitMsg(clean, 480);
  for (let i = 0; i < chunks.length; i++) {
    const prefix = chunks.length > 1 ? `[${i+1}/${chunks.length}] ` : '';
    const raw = await hReq(to, 'telex', prefix + chunks[i]);
    if (!raw.toLowerCase().startsWith('ok')) throw new Error(raw);
    if (i === 0) discordNotifyOpsMsg({ to, body, auto: true, ok: true });
    if (i < chunks.length - 1) await sleep(500);
  }
  totalMsgsSent++;
  return true;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MESSAGE HISTORY & ANTI-DUPLICATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const SENT_STORAGE_KEY = 'an_ops_sent_registry';
const HIST_STORAGE_KEY = 'an_ops_msg_history';
let sentRegistry = {};   // { "callsign_dep_arr_phase": timestamp }
let msgHistory = [];      // [{ time, callsign, phase, msgId, status, label }]

function loadSentRegistry() {
  try {
    const s = localStorage.getItem(SENT_STORAGE_KEY);
    if (s) sentRegistry = JSON.parse(s);
    const h = localStorage.getItem(HIST_STORAGE_KEY);
    if (h) msgHistory = JSON.parse(h);
    // Prune entries older than 6 hours
    const cutoff = Date.now() - 6 * 3600000;
    let pruned = 0;
    for (const k in sentRegistry) { if (sentRegistry[k] < cutoff) { delete sentRegistry[k]; pruned++; } }
    msgHistory = msgHistory.filter(m => m.ts > cutoff);
    saveSentRegistry();
    const keys = Object.keys(sentRegistry).length;
    if (keys > 0) log(`DEDUP: ${keys} registros cargados de sesion anterior (${pruned} expirados)`, 'ops');
  } catch(e) { sentRegistry = {}; msgHistory = []; log(`DEDUP: error cargando registros: ${e.message}`, 'err'); }
  renderMsgHistory();
}
function saveSentRegistry() {
  try {
    localStorage.setItem(SENT_STORAGE_KEY, JSON.stringify(sentRegistry));
    localStorage.setItem(HIST_STORAGE_KEY, JSON.stringify(msgHistory));
  } catch(e) {}
}

// Build dedup key: callsign + dep + arr + phase
// Use only callsign+phase as primary key when dep/arr unknown
function dedupKey(cs, dep, arr, phase) {
  const d = dep && dep !== '????' ? dep : '';
  const a = arr && arr !== '????' ? arr : '';
  return `${cs}_${d}_${a}_${phase}`.replace(/\s/g, '');
}

// Check if this message was already sent recently
function wasSentRecently(cs, dep, arr, phase, maxAgeMs) {
  const key = dedupKey(cs, dep, arr, phase);
  const t = sentRegistry[key];
  if (t && (Date.now() - t) < maxAgeMs) return true;
  // Also check callsign-only key (phase might have been recorded without route info)
  const fallbackKey = `${cs}___${phase}`;
  const t2 = sentRegistry[fallbackKey];
  if (t2 && (Date.now() - t2) < maxAgeMs) return true;
  return false;
}

// Record a sent message
function recordSent(cs, dep, arr, phase, msgLabel, status, msgBody) {
  const key = dedupKey(cs, dep, arr, phase);
  if (status === 'sent') {
    sentRegistry[key] = Date.now();
    // Store fallback key (cs+phase only) for restart dedup when dep/arr unknown
    sentRegistry[`${cs}___${phase}`] = Date.now();
    // Also store generic phase key for dedup (e.g. routeinfo_2 -> routeinfo)
    const generic = phase.replace(/_\d+$/, '');
    if (generic !== phase) {
      sentRegistry[dedupKey(cs, dep, arr, generic)] = Date.now();
      sentRegistry[`${cs}___${generic}`] = Date.now();
    }
    log(`DEDUP: registrado ${key}`, '');
  }
  msgHistory.push({ ts: Date.now(), cs, phase, label: msgLabel, status, body: msgBody || '' });
  if (msgHistory.length > 200) msgHistory = msgHistory.slice(-200);
  saveSentRegistry();
  renderMsgHistory();
}

// ‚îÄ‚îÄ History UI ‚îÄ‚îÄ
function toggleMsgHistory() {
  $('mhBody').classList.toggle('open');
}
function clearMsgHistory() {
  msgHistory = [];
  sentRegistry = {};
  saveSentRegistry();
  renderMsgHistory();
}
function toggleMsgBody(idx) {
  const el = document.getElementById('mh-body-' + idx);
  if (!el) return;
  el.classList.toggle('open');
  // Rotate expand arrow in the parent row
  const arrow = el.previousElementSibling?.querySelector('.mh-expand');
  if (arrow) arrow.textContent = el.classList.contains('open') ? '‚ñæ' : '‚ñ∏';
}
function renderMsgHistory() {
  const rows = $('mhRows');
  const empty = $('mhEmpty');
  $('mhCount').textContent = msgHistory.length;
  if (!msgHistory.length) {
    rows.innerHTML = '';
    empty.style.display = 'block';
    return;
  }
  empty.style.display = 'none';
  // Show newest first
  const sorted = [...msgHistory].reverse();
  rows.innerHTML = sorted.map((m, i) => {
    const t = new Date(m.ts).toISOString().substring(11,19);
    const stCls = m.status === 'sent' ? 'sent' : (m.status === 'skip' ? 'skip' : 'error');
    const stLabel = m.status === 'sent' ? '‚úì ENVIADO' : (m.status === 'skip' ? '‚äò OMITIDO' : '‚úó ERROR');
    const hasBody = m.body && m.body.trim().length > 0;
    const expandIcon = hasBody ? '<span class="mh-expand" title="Ver contenido">‚ñ∏</span>' : '';
    const bodyRow = hasBody ? `<tr id="mh-body-${i}" class="mh-body-row"><td colspan="5"><pre class="mh-body-pre">${esc(m.body)}</pre></td></tr>` : '';
    return `<tr class="${hasBody ? 'mh-clickable' : ''}" ${hasBody ? `onclick="toggleMsgBody(${i})"` : ''}><td>${expandIcon}${esc(t)}</td><td>${esc(m.cs)}</td><td>${esc(m.phase)}</td><td>${esc(m.label)}</td><td><span class="mh-st ${stCls}">${stLabel}</span></td></tr>${bodyRow}`;
  }).join('');
}
function splitMsg(txt, max) {
  if (txt.length <= max) return [txt];
  const chunks = []; let pos = 0;
  while (pos < txt.length) {
    let end = Math.min(pos + max, txt.length);
    if (end < txt.length) { const nl = txt.lastIndexOf('\n', end); if (nl > pos + 50) end = nl; }
    chunks.push(txt.substring(pos, end).trim());
    pos = end;
  }
  return chunks;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ‚îÄ‚îÄ Log ‚îÄ‚îÄ
function log(msg, cls = '') {
  $('logEmpty').style.display = 'none';
  const e = document.createElement('div');
  e.className = `log-e ${cls}`;
  e.innerHTML = `<span class="lt">${tsShort()}</span><span class="lm">${esc(msg)}</span>`;
  const box = $('logBox');
  box.insertBefore(e, box.children[1]); // after header
  // Keep max 200 entries
  while (box.children.length > 202) box.removeChild(box.lastChild);
}
function clearLog() {
  $('logBox').querySelectorAll('.log-e').forEach(e => e.remove());
  $('logEmpty').style.display = 'block';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FLIGHT STATE MACHINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Phases: PREFLIGHT ‚Üí ENROUTE ‚Üí DESCENT ‚Üí LANDED
// Thresholds tuned for flight sim

// detectPhase v2 ‚Äî usa estado nativo IVAO + arrivalDistance + phpVMS phase
function detectPhase(pilot, prev) {
  const track    = pilot.lastTrack || {};
  const onGround = track.onGround === true || track.onGround === 1;
  const gs       = typeof track.groundSpeed === 'number' ? track.groundSpeed : parseInt(track.groundSpeed) || 0;
  const alt      = typeof track.altitude    === 'number' ? track.altitude    : parseInt(track.altitude)    || 0;
  const altDiff  = typeof track.altitudeDifference === 'number' ? track.altitudeDifference : 0;
  const arrDist  = typeof track.arrivalDistance === 'number' ? track.arrivalDistance : null;
  const ivaoSt   = typeof track.state === 'string' ? track.state.toLowerCase() : '';
  const prevPhase = prev?.phase || null;

  // 1. phpVMS phase override (fuente m√°s fiable del servidor)
  if (pilot._phpvmsPhase) {
    const pm = { 'DEP':'PREFLIGHT','ENR':'ENROUTE','ARR':'LANDED','CMP':'LANDED','INP':'ENROUTE' };
    if (pm[pilot._phpvmsPhase]) return pm[pilot._phpvmsPhase];
  }

  // 2. IVAO state nativo (disponible en todos los pilotos del whazzup)
  if (ivaoSt) {
    if (ivaoSt.includes('boarding') || ivaoSt.includes('block') || ivaoSt.includes('departing') || ivaoSt.includes('taxi')) {
      return (prevPhase === 'ENROUTE' || prevPhase === 'DESCENT') ? 'LANDED' : 'PREFLIGHT';
    }
    if (ivaoSt.includes('initial climb') || ivaoSt.includes('climb')) return 'ENROUTE';
    if (ivaoSt.includes('en route') || ivaoSt === 'en route') return 'ENROUTE';
    if (ivaoSt.includes('approach') || ivaoSt.includes('landing')) return 'DESCENT';
    if (ivaoSt.includes('descend') || ivaoSt.includes('descent')) return 'DESCENT';
    if (ivaoSt.includes('landed') || ivaoSt.includes('on block') || ivaoSt.includes('arrived')) return 'LANDED';
  }

  // 3. arrivalDistance < 150nm + bajando ‚Üí DESCENT
  if (arrDist !== null && !onGround && prevPhase === 'ENROUTE' && arrDist < 150 && altDiff < -100) {
    return 'DESCENT';
  }

  // 4. Heur√≠stica legacy
  if (onGround) {
    if (prevPhase === 'ENROUTE' || prevPhase === 'DESCENT') return 'LANDED';
    if (prevPhase === 'LANDED') return 'LANDED';
    return 'PREFLIGHT';
  }
  if (prevPhase === 'LANDED') return 'LANDED';
  const prevAlt = prev?.alt || alt;
  if (!onGround && (prevPhase === 'ENROUTE' || prevPhase === 'DESCENT')) {
    if (prevAlt - alt > 300 || altDiff < -300) return 'DESCENT';
    if (prevPhase === 'DESCENT' && prevAlt - alt >= -200) return 'DESCENT';
  }
  if (!onGround && prevPhase !== 'LANDED') return 'ENROUTE';
  if (onGround && gs < 5) return 'PREFLIGHT';
  return prevPhase || 'PREFLIGHT';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MESSAGE GENERATORS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function genPreflight(flt) {
  const msgs = [];
  const dep = flt.dep || '????';
  const arr = flt.arr || '????';

  // 1. Try loadsheet from SimBrief if roster mapping exists
  const sbUser = roster[flt.callsign];
  if (sbUser) {
    try {
      const isNum = /^\d+$/.test(sbUser);
      const param = isNum ? `userid=${sbUser}` : `username=${encodeURIComponent(sbUser)}`;
      const resp = await fetch(proxy(`${SIMBRIEF_API}?${param}&json=1`), { signal: AbortSignal.timeout(10000) });
      if (resp.ok) {
        const o = await resp.json();
        if (o.origin && !o.fetch?.status?.includes?.('Error')) {
          const unit = o.params?.units === 'lbs' ? 'LBS' : 'KG';
          const load = [
            `=== LOADSHEET ${flt.callsign} ===`,
            `${o.origin.icao_code}/${o.destination.icao_code} ALT:${o.alternate?.icao_code||'N/A'}`,
            `ACFT:${o.aircraft?.icaocode||'?'} CI:${o.general?.costindex||'?'}`,
            `PAX:${o.weights?.pax_count||0} CARGO:${Number(o.weights?.cargo||0).toLocaleString()}${unit}`,
            `ZFW:${Number(o.weights?.est_zfw||0).toLocaleString()} TOW:${Number(o.weights?.est_tow||0).toLocaleString()} LDW:${Number(o.weights?.est_ldw||0).toLocaleString()} ${unit}`,
            `FUEL BLK:${Number(o.fuel?.plan_ramp||0).toLocaleString()} TRIP:${Number(o.fuel?.enroute_burn||0).toLocaleString()} RSV:${Number(o.fuel?.reserve||0).toLocaleString()} ${unit}`,
          ].join('\n');
          msgs.push({ id: 'loadsheet', label: 'LOADSHEET', body: load });
        }
      }
    } catch(e) {
      log(`SimBrief error para ${flt.callsign}: ${e.message}`, 'wrn');
    }
  }

  // 2. WX Briefing: METAR for dep, arr, alternate
  try {
    const icaos = [dep, arr].filter(x => x !== '????');
    if (icaos.length) {
      const mResp = await fetch(proxy(`${METAR_API}?ids=${icaos.join(',')}&format=raw&hours=2`), { signal: AbortSignal.timeout(8000) });
      const mTxt = await mResp.text();
      const tResp = await fetch(proxy(`${TAF_API}?ids=${icaos.join(',')}&format=raw&hours=6`), { signal: AbortSignal.timeout(8000) });
      const tTxt = await tResp.text();
      const wx = `=== WX BRIEFING ${flt.callsign} ===\n${dep}‚Üí${arr}\nMETAR:\n${mTxt.trim()}\nTAF:\n${tTxt.trim().substring(0,400)}`;
      msgs.push({ id: 'wx_brief', label: 'WX BRIEF', body: wx });
    }
  } catch(e) {
    log(`WX error para ${flt.callsign}: ${e.message}`, 'wrn');
  }

  return msgs;
}

async function genEnroute(flt) {
  const arr = flt.arr || '????';
  const msgs = [];

  // 1. Traffic at destination
  try {
    const resp = await fetch(proxy(IVAO_WHAZZUP), { signal: AbortSignal.timeout(10000) });
    const data = await resp.json();
    const pilots = data.clients?.pilots || [];
    const arriving = pilots.filter(p => p.flightPlan?.arrivalId === arr);
    const departing = pilots.filter(p => p.flightPlan?.departureId === arr);
    const total = arriving.length + departing.length;
    const density = total === 0 ? 'NINGUNO' : total <= 3 ? 'BAJO' : total <= 8 ? 'MODERADO' : 'ALTO';

    let traf = `=== TRAFFIC ${arr} ===\n${density} (ARR:${arriving.length} DEP:${departing.length})\n`;
    for (const p of arriving.slice(0, 6)) {
      traf += `${p.callsign||'?'} ${p.flightPlan?.aircraftId||'?'} FROM ${p.flightPlan?.departureId||'?'} GS${p.lastTrack?.groundSpeed||0} FL${Math.round((p.lastTrack?.altitude||0)/100)}\n`;
    }
    // ATC ‚Äî only relevant: dest TWR/APP + area CTR/FSS (exclude GND/DEL)
    const atcs = data.clients?.atcs || [];
    const prefix2 = arr.substring(0, 2);
    const destAtc = atcs.filter(a => {
      if (!a.callsign) return false;
      const cs = a.callsign.toUpperCase();
      if (cs.includes('_GND') || cs.includes('_DEL')) return false;
      if (cs.startsWith(arr)) return true;
      if ((cs.includes('_FSS') || cs.includes('_CTR')) && cs.startsWith(prefix2)) return true;
      return false;
    });
    if (destAtc.length) {
      traf += `ATC: ${destAtc.map(a => a.callsign).join(', ')}\n`;
    } else {
      traf += `NO ATC ONLINE ${arr}\n`;
    }
    msgs.push({ id: 'traffic', label: 'TRAFFIC', body: traf });
  } catch(e) {
    log(`Traffic error ${flt.callsign}: ${e.message}`, 'wrn');
  }

  // 2. WX en-route: current METAR destination only (hours=1)
  try {
    const mResp = await fetch(proxy(`${METAR_API}?ids=${arr}&format=raw&hours=1`), { signal: AbortSignal.timeout(6000) });
    const mTxt = await mResp.text();
    if (mTxt.trim()) {
      // Only take first METAR line (most recent)
      const firstMetar = mTxt.trim().split('\n')[0];
      msgs.push({ id: 'wx_enroute', label: 'WX ENRTE', body: `=== WX EN-ROUTE ${flt.callsign} ===\nDEST ${arr} METAR:\n${firstMetar}` });
    }
  } catch(e) {}

  return msgs;
}

async function genDescent(flt) {
  const arr = flt.arr || '????';
  const msgs = [];

  // ATIS/METAR destination updated
  try {
    let atisText = '';
    try {
      const raw = await hReq('SERVER', 'inforeq', `IVAOATIS ${arr}`);
      if (raw.toLowerCase().startsWith('ok') && raw.length > 5) {
        atisText = `ATIS ${arr}: ${raw.substring(2).trim()}\n`;
      }
    } catch(e) {}

    const mResp = await fetch(proxy(`${METAR_API}?ids=${arr}&format=raw&hours=1`), { signal: AbortSignal.timeout(6000) });
    const mTxt = await mResp.text();
    const firstMetar = mTxt.trim().split('\n')[0] || '';

    const body = `=== ARRIVAL INFO ${flt.callsign} ===\n${arr}\n${atisText}METAR:\n${firstMetar}`;
    msgs.push({ id: 'arrival_info', label: 'ARR INFO', body });
  } catch(e) {
    log(`Descent WX error ${flt.callsign}: ${e.message}`, 'wrn');
  }

  // ATC congestion check ‚Äî warn if high traffic at destination
  try {
    const ivao = lastIvaoData;
    if (ivao) {
      const pilots = ivao.clients?.pilots || [];
      const atcs = ivao.clients?.atcs || [];
      const arriving = pilots.filter(p => p.flightPlan?.arrivalId === arr);
      const departing = pilots.filter(p => p.flightPlan?.departureId === arr);
      const prefix2 = arr.substring(0, 2);
      const destAtc = atcs.filter(a => {
        if (!a.callsign) return false;
        const cs = a.callsign.toUpperCase();
        return cs.startsWith(arr) || ((cs.includes('_FSS') || cs.includes('_CTR')) && cs.startsWith(prefix2));
      });
      const hasApp = destAtc.some(a => a.callsign.includes('_APP') || a.callsign.includes('_DEP'));
      const hasTwr = destAtc.some(a => a.callsign.includes('_TWR'));
      const total = arriving.length + departing.length;

      // High traffic: >8 aircraft AND ATC present (controlled = sequencing = delays)
      // Very high: >12 aircraft
      if (total > 8 && destAtc.length > 0) {
        let warn = `=== ATC ADVISORY ${arr} ===\n`;
        if (total > 12) {
          warn += `‚ö† TRAFICO MUY ALTO - ${total} ACFT (${arriving.length} ARR/${departing.length} DEP)\n`;
          warn += `POSIBLE ATC DELAY EN LLEGADA\n`;
          warn += `Espere vectores extendidos o holdings.\n`;
          if (hasApp) warn += `APP activo ‚Äî secuenciacion probable.\n`;
        } else {
          warn += `‚ö† TRAFICO ALTO - ${total} ACFT (${arriving.length} ARR/${departing.length} DEP)\n`;
          warn += `POSIBLE SECUENCIACION EN LLEGADA\n`;
          if (hasApp) warn += `APP activo ‚Äî posibles vectores de separacion.\n`;
        }
        warn += `ATC: ${destAtc.map(a => a.callsign).join(', ')}\n`;
        msgs.push({ id: 'atc_delay', label: 'ATC ADVSY', body: warn });
        discordNotifyAlert(flt.callsign, 'ATC CONGESTION', `${flt.arr}: ${total} aeronaves (${arriving.length} ARR/${departing.length} DEP)`);
      }
    }
  } catch(e) {
    log(`ATC check error ${flt.callsign}: ${e.message}`, 'wrn');
  }

  // Passenger connections at destination
  const connMsg = genPaxConnections(arr);
  if (connMsg) {
    msgs.push({ id: 'pax_conn', label: 'PAX CONN', body: connMsg });
  }

  return msgs;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  AIRLINE & AIRPORT DATABASE (for connections, crew rotation)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Airlines by ICAO country prefix ‚Äî mix of real low-cost, flag carriers, regional
const AIRLINES_BY_PREFIX = {
  'LE':['NBV','IBE','VLG','AEA','RYR','ANE','ELY'],         // Spain
  'LP':['NBV','TAP','NTP','RYR'],                             // Portugal
  'LF':['NBV','AFR','EZY','TVF','BEE','HOP'],                // France
  'EG':['NBV','BAW','EZY','RYR','TOM','LOG','VIR'],          // UK
  'ED':['NBV','DLH','EWG','CFG','RYR','SXS'],                // Germany
  'LI':['NBV','AZA','RYR','EZY','NOS','VOE'],                // Italy
  'EH':['NBV','KLM','TRA','EZY','RYR'],                      // Netherlands
  'EB':['NBV','BEL','TUI','RYR'],                             // Belgium
  'EI':['NBV','EIN','RYR','ASL'],                             // Ireland
  'ES':['NBV','SAS','NAX','RYR'],                             // Sweden
  'EN':['NBV','SAS','NAX','WIF'],                             // Norway
  'EK':['NBV','SAS','NAX','RYR'],                             // Denmark
  'LO':['NBV','AUA','RYR','EZY','LWG'],                      // Austria
  'LS':['NBV','SWR','EZY','EZS'],                             // Switzerland
  'LK':['NBV','CSA','TVS','RYR'],                             // Czech Republic
  'EP':['NBV','LOT','RYR','WZZ'],                             // Poland
  'LG':['NBV','AEE','RYR','OAL'],                             // Greece
  'LT':['NBV','THY','PGT','SXS','AJA'],                      // Turkey
  'LC':['NBV','CYP','RYR'],                                    // Cyprus
  'LH':['NBV','HVA','WZZ'],                                    // Hungary
  'LR':['NBV','ROT','WZZ'],                                    // Romania
  'LZ':['NBV','BUC','WZZ'],                                    // Slovakia/Bulgaria
};

// Destinations by ICAO prefix ‚Äî major airports for connections
const DESTINATIONS_BY_PREFIX = {
  'LE':['LEMD','LEBL','LEPA','LEAL','LEMG','LEZL','LEBB','LEST','LEVC','LEXJ','GCXO','GCLP','GCFV','GCTS'],
  'LP':['LPPT','LPPR','LPFR','LPMA'],
  'LF':['LFPG','LFPO','LFBO','LFML','LFMN','LFLL','LFSB'],
  'EG':['EGLL','EGKK','EGSS','EGGW','EGCC','EGGP','EGPH','EGBB'],
  'ED':['EDDF','EDDM','EDDB','EDDL','EDDK','EDDS','EDDH'],
  'LI':['LIRF','LIMC','LIPZ','LIPE','LIMF','LIRN','LICC','LICJ'],
  'EH':['EHAM'],
  'EB':['EBBR','EBCI'],
  'EI':['EIDW','EICK'],
  'ES':['ESSA','ESGG','ESMS'],
  'EN':['ENGM','ENBR','ENZV'],
  'EK':['EKCH','EKBI'],
  'LO':['LOWW','LOWS','LOWG'],
  'LS':['LSZH','LSGG','LSZA'],
  'LK':['LKPR','LKTB'],
  'EP':['EPWA','EPKK','EPGD'],
  'LG':['LGAV','LGTS','LGIR','LGKR','LGSA'],
  'LT':['LTFM','LTAI','LTBS','LTFE'],
};

// Galician airports (AirNubeiro base)
const GALICIAN_BASES = ['LEST','LECO','LEVX'];

// Spanish domestic destinations (for next-flight national)
const SPAIN_DOMESTIC = ['LEMD','LEBL','LEPA','LEAL','LEMG','LEZL','LEBB','LEVC','LEXJ','LEZG','GCXO','GCLP','GCFV','GCTS'];

// European continental destinations (for next-flight continental)
const EUROPE_DEST = ['LFPG','EGLL','EDDF','LIRF','EHAM','EBBR','LPPT','LFBO','EDDM','LSZH','LOWW','LKPR','EPWA','EKCH','ENGM','LGAV','EIDW','ESSA'];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PAX CONNECTIONS GENERATOR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function genPaxConnections(arrIcao, arrivalTimeEstimate) {
  if (!arrIcao || arrIcao === '????') return '';

  // 40% probability: no connecting passengers
  if (Math.random() < 0.40) {
    return `=== CONEXIONES PAX ${arrIcao} ===\n0 PAX EN CONEXION\nNo hay pasajeros con enlaces en este vuelo.`;
  }

  const prefix = arrIcao.substring(0, 2);

  // Airlines operating at destination: own airline + country-based + some international
  const localAirlines = AIRLINES_BY_PREFIX[prefix] || ['NBV','RYR','EZY'];
  const intlAirlines = ['NBV','IBE','AFR','BAW','DLH','KLM']; // always possible
  const pool = [...new Set([...localAirlines, ...intlAirlines])];

  // Possible destinations from this airport
  const localDests = DESTINATIONS_BY_PREFIX[prefix] || [];
  const allDests = [...new Set([...localDests, ...EUROPE_DEST])].filter(d => d !== arrIcao);

  // Generate 2-4 connections
  const numConn = 2 + Math.floor(Math.random() * 3); // 2-4
  const connections = [];
  const usedDests = new Set();

  // Base departure time: ~45-120 min after estimated arrival
  const now = new Date();
  const baseMin = 45 + Math.floor(Math.random() * 75);

  for (let i = 0; i < numConn && allDests.length > 0; i++) {
    // Pick destination (no repeats)
    let dest;
    let attempts = 0;
    do {
      dest = allDests[Math.floor(Math.random() * allDests.length)];
      attempts++;
    } while (usedDests.has(dest) && attempts < 20);
    if (usedDests.has(dest)) continue;
    usedDests.add(dest);

    // Pick airline ‚Äî 40% chance same airline (NBV), 60% local/intl
    const airline = Math.random() < 0.4 ? 'NBV' : pool[Math.floor(Math.random() * pool.length)];

    // Flight number
    const fltNum = `${airline}${String(Math.floor(Math.random() * 9000) + 1000)}`;

    // Gate ‚Äî use real gate database
    const gate = genParking(arrIcao) || `GATE ${Math.floor(Math.random()*40)+1}`;

    // Departure time
    const depOffset = baseMin + i * (15 + Math.floor(Math.random() * 30)); // staggered
    const depTime = new Date(now.getTime() + depOffset * 60000);
    const depStr = `${String(depTime.getUTCHours()).padStart(2,'0')}:${String(depTime.getUTCMinutes()).padStart(2,'0')}z`;

    // Pax count
    const pax = Math.floor(Math.random() * 12) + 1;

    connections.push({ airline, fltNum, dest, gate, depStr, pax });
  }

  if (!connections.length) return '';

  let msg = `=== CONEXIONES PAX ${arrIcao} ===\n`;
  const totalPax = connections.reduce((s, c) => s + c.pax, 0);
  msg += `${totalPax} PAX EN CONEXION:\n`;
  for (const c of connections) {
    msg += `${c.fltNum} ‚Üí ${c.dest} GATE ${c.gate} ETD ${c.depStr} (${c.pax}pax)\n`;
  }

  return msg;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CREW ROTATION & NEXT FLIGHT GENERATOR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function genCrewInfo(flt) {
  const arr = flt.arr || '????';
  const now = new Date();
  const utcHour = now.getUTCHours();
  const utcMin = now.getUTCMinutes();

  // Estimate local hour (rough offset from ICAO prefix)
  const localOffset = getLocalOffset(arr);
  const localHour = (utcHour + localOffset + 24) % 24;
  const localMin = utcMin;

  const isBase = GALICIAN_BASES.includes(arr);
  let crewChange;
  let reason;
  let isLastFlightGoodnight = false;

  // Late night: local time >= 00:30 ‚Üí last flight, buenas noches
  if (localHour >= 0 && localHour < 5 && (localHour > 0 || localMin >= 30)) {
    crewChange = true;
    isLastFlightGoodnight = true;
    reason = 'ULTIMO VUELO DEL DIA';
  } else if (utcHour >= 21 || localHour >= 23) {
    crewChange = true;
    reason = 'ULTIMO VUELO DEL DIA';
  } else if (utcHour >= 19 || localHour >= 21) {
    crewChange = Math.random() < (isBase ? 0.5 : 0.7);
    reason = crewChange ? 'VUELO NOCTURNO - RELEVO PROGRAMADO' : null;
  } else {
    crewChange = Math.random() < (isBase ? 0.1 : 0.2);
    reason = crewChange ? 'RELEVO DE TRIPULACION PROGRAMADO' : null;
  }

  let msg = '';

  if (crewChange) {
    if (isLastFlightGoodnight) {
      msg += `--- TRIPULACION ---\n`;
      msg += `NO HAY MAS VUELOS PROGRAMADOS HOY\n`;
      msg += `Tripulacion libre de servicio.\n`;
      msg += `Buenas noches y buen descanso.\n`;
    } else {
      msg += `--- TRIPULACION ---\nCAMBIO DE TRIPULACION: ${reason}\n`;
      msg += `Tripulacion entrante reportar a briefing.\n`;
    }
  } else {
    msg += `--- TRIPULACION ---\nSIN CAMBIO - MISMA TRIPULACION CONTINUA\n`;

    // Generate next flight for this crew
    const nextFlt = genNextFlight(flt, arr);
    if (nextFlt) {
      msg += `PROXIMO VUELO: ${nextFlt.fltNum}\n`;
      msg += `${nextFlt.dep}‚Üí${nextFlt.dest} ETD ${nextFlt.etd}\n`;
      msg += `ACFT: ${flt.aircraft || '???'} GATE: ${nextFlt.gate}\n`;
      if (nextFlt.isReturn) msg += `(RETORNO A BASE)\n`;
      msg += `TURNAROUND: ${nextFlt.turnaround}min\n`;
    }
  }

  return msg;
}

// Rough UTC offset by ICAO prefix (for local time estimation)
function getLocalOffset(icao) {
  if (!icao || icao.length < 2) return 1;
  const pfx = icao.substring(0, 2);
  const offsets = {
    'LE':1,'LP':0,'LF':1,'EG':0,'ED':1,'LI':1,'EH':1,'EB':1,
    'EI':0,'ES':1,'EN':1,'EK':1,'LO':1,'LS':1,'LK':1,'EP':1,
    'LG':2,'LT':3,'LC':2,'LH':1,'LR':2,'LZ':2,
    'GC':0, // Canarias
  };
  // Canarias special case
  if (icao.startsWith('GC')) return 0;
  return offsets[pfx] ?? 1;
}

function genNextFlight(flt, currentAirport) {
  const now = new Date();
  const prefix = currentAirport.substring(0, 2);

  // Decision: return to base or continue to another destination?
  // 50% return to Galician base, 30% domestic Spain, 20% European
  const roll = Math.random();
  let dest, isReturn = false;

  if (roll < 0.50) {
    // Return to base ‚Äî pick a Galician airport (not the current one)
    const bases = GALICIAN_BASES.filter(b => b !== currentAirport);
    dest = bases.length ? bases[Math.floor(Math.random() * bases.length)] : GALICIAN_BASES[0];
    isReturn = true;
  } else if (roll < 0.80) {
    // Domestic Spanish flight
    const domestic = SPAIN_DOMESTIC.filter(d => d !== currentAirport);
    dest = domestic[Math.floor(Math.random() * domestic.length)] || 'LEMD';
  } else {
    // European continental
    const euro = EUROPE_DEST.filter(d => d !== currentAirport);
    dest = euro[Math.floor(Math.random() * euro.length)] || 'LFPG';
  }

  // Turnaround time: 35-75 min
  const turnaround = 35 + Math.floor(Math.random() * 40);
  const etdDate = new Date(now.getTime() + turnaround * 60000);
  const etd = `${String(etdDate.getUTCHours()).padStart(2,'0')}:${String(etdDate.getUTCMinutes()).padStart(2,'0')}z`;

  // Flight number
  const fltNum = `NBV${String(Math.floor(Math.random() * 9000) + 1000)}`;

  // Gate
  const gate = genParking(currentAirport) || `STAND ${Math.floor(Math.random()*30)+1}`;

  return { fltNum, dep: currentAirport, dest, etd, gate, turnaround, isReturn };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PARKING / STAND GENERATOR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Generates a realistic random parking stand based on airport ICAO prefix
function genParking(icao) {
  if (!icao || icao === '????') return '';
  // AirNubeiro official stands from Manual de Procedimientos Operacionales
  const NBV_STANDS = {
    'LEST':['2','3','4','5','6','7','21','22'],'LEVX':['4','5','7'],'LEAS':['2','3'],
    'LECO':['1','3','12'],'LEXJ':['2','6'],'LEBB':['4','6','16'],
    'LEBL':['236','238','240','242','248'],'LEVC':['4','6','42'],
    'LEAL':['29','31'],'LEPA':['84','86','88','48','66'],'LEMG':['24','26','28'],
    'LEMD':['T27','T28','T29','T32','T18'],'LEIB':['18','25','27','28'],
    'LEZL':['6','7'],'GCFV':['21','22','23'],'GCLA':['7','9'],
    'GCXO':['T1','T4'],'GCRR':['T1','T3'],'GCLP':['T05','T06'],'GCTS':['14','16'],
  };
  const REAL_GATES = {
    'EGLL':['A5','A7','A10','A14','A18','A22','B32','B34','B36','B38','B42','B44','B46','C54','C56','C60','C62','301','305','307','340','501','503','505','510','520','525','544','546','555','562'],
    'LFPG':['E40','E42','E44','E46','E48','E50','K21','K24','K30','K36','L40','L42','L44','M30','M32','M34','M36','A22','A24','A26','A30','D51','D53','D55','F32','F34','F36','F38'],
    'EDDF':['A15','A17','A21','A24','A26','A50','A52','A60','A62','B20','B22','B24','B28','B30','B40','B42','B44','C14','C15','D2','D4','D6','D8','E4','E6','E8','E12','E15','E21'],
    'EHAM':['B18','B20','B22','B24','B28','C8','C10','C12','D18','D20','D22','D51','D53','D57','D59','E18','E20','E22','E24','F3','F5','F7','F9','G3','G5','G9','H1','H3','H5','H7'],
    'LIRF':['B1','B3','B5','B7','B11','B13','B15','B17','B19','B21','D1','D3','D5','D7','E1','E3','E5','E7','E11','E13','E15','E17','E19','E21','E23','E25','G1','G3','G5','G7','G9'],
    'EBBR':['A26','A28','A30','A32','A34','A40','A42','A44','A46','B50','B52','B54','B56','B58','B60','B62','B64'],
    'EIDW':['101','102','103','104','105','201','202','203','301','302','303','304','305','306','307','308'],
    'LPPT':['14','16','18','20','22','24','26','28','30','32','34','36','38','40','42','44','46','48','50','52','54','56','58'],
    'LPPR':['3','5','7','9','11','13','15','17','19','21','23','25'],
    'LOWW':['B14','B16','B18','B20','B22','B24','C28','C30','C32','C34','D42','D44','D46','D48','D50','D52','F68','F70','F72','F74','F76','G81','G83','G85'],
    'LSZH':['A10','A12','A14','A16','A20','A22','A24','A26','A28','A30','A32','A34','B51','B53','B55','B57','B59','B61','B63','B65','D31','D33','D35','D37','D39','D41','E54','E56','E58','E60','E62','E64'],
    'EKCH':['A1','A2','A3','A4','A5','A7','B5','B6','B7','B8','B9','B10','C22','C24','C26','C28','C30','C32','C34'],
    'ESSA':['1','2','3','4','5','6','7','8','10','12','14','16','18','20','22','24','26','28','30','32','34','36','38','40'],
    'ENGM':['A11','A12','A13','A14','A15','A16','B22','B24','B26','B28','B30','B32','B34','C36','C38','C40','C42','C44','D50','D52','D54','D56'],
    'LKPR':['A2','A4','A6','A8','A10','B15','B17','B19','B21','B23','B25','C30','C32','C34','C36','C38','C40'],
    'EPWA':['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29'],
    'LGAV':['A1','A2','A3','A4','A5','A6','A7','A8','A9','A10','A11','B15','B16','B17','B18','B19','B20','B21','B22','B23','B24','B25','B26'],
    'LTFM':['D201','D203','D205','D207','D209','F101','F103','F105','F107','G301','G303','G305','G307','G309'],
    'LIMC':['A1','A3','A5','A7','A9','A11','B15','B17','B19','B21','B23','B25','B27','C1','C3','C5','C7','C9'],
    'EGKK':['1','2','3','4','5','6','10','11','12','13','14','15','21','22','23','24','25','26','31','32','33','34','35','36','51','52','53','54','55','56','101','102','103'],
  };
  if (NBV_STANDS[icao]) { const sl = NBV_STANDS[icao]; return `STAND ${sl[Math.floor(Math.random()*sl.length)]}`; }
  if (REAL_GATES[icao]) { const gl = REAL_GATES[icao]; return `GATE ${gl[Math.floor(Math.random()*gl.length)]}`; }
  const prefix = icao.substring(0,2);
  const ranges = {'LE':[1,50],'LP':[1,40],'LF':[1,60],'EG':[1,60],'ED':[1,50],'LI':[1,40],'EH':[1,70],'EB':[1,60],'EI':[1,40],'ES':[1,50],'EN':[1,60],'EK':[1,40],'LO':[1,50],'LS':[1,50],'LK':[1,40],'EP':[1,30],'LG':[1,30],'LT':[1,50]};
  const r = ranges[prefix] || [1,30];
  return `STAND ${Math.floor(Math.random()*(r[1]-r[0]+1))+r[0]}`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MENSAJES GALLEGOS ‚Äî Telex personalizado en llegada
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const GALICIAN_AIRPORTS = {
  'LEVX': {
    messages: [
      cs => `=== BENVIDO A VIGO ===\n${cs} / A CIDADE OLIVEIRA\n\nAterrado en Vigo-Peinador, porta de entrada as Rias Baixas.\nA ria de Vigo agarda con posta de sol entre as illas Ces.\n\nRecomendacion AirNubeiro:\n- Marisco nas Ruas do Berbes\n- Ruta pola Ponte de Rande\n- Visita as Illas Ces (Parque Nacional)\n\nBo descanso. Graza por volar con AirNubeiro. OPS NBV.`,
      cs => `=== VIGO CHEGADA ===\n${cs} / AEROPORTO VIGO-PEINADOR\n\nBenvido a capital da provincia de Pontevedra.\nEspecialidade local: zamburinas e mexillons da ria.\n\nCieus atlanticos, Cies no horizonte.\nVOO COMPLETADO. OPS NBV.`,
    ]
  },
  'LECO': {
    messages: [
      cs => `=== BENVIDO A CORUNA ===\n${cs} / AEROPORTO ALVEDRO\n\nAterrado na Cidade de Cristal.\nA Torre de Hercules ‚Äî faro romano, Patrimonio UNESCO ‚Äî\nvixa estas chegadas dende hai 2.000 anos.\n\nRecomendacion AirNubeiro:\n- Paseo maritimo dende Riazor ata o Parrote\n- Pulpo a feira no Mercado de Abastos\n\nVento atlantico garantido. Paraguas recomendado.\nOPS NBV.`,
      cs => `=== A CORUNA CHEGADA ===\n${cs}\n\nBenvido ao extremo noroeste de Europa.\nFinisterre espera ao suroeste.\n\nTripulacion: excelente voo. Descansen.\nAirNubeiro OPS.`,
    ]
  },
  'LEST': {
    messages: [
      cs => `=== BENVIDO A SANTIAGO ===\n${cs} / AEROPORTO ROSALIA DE CASTRO\n\nAterrado na capital de Galicia.\nA Catedral do Apostolo aguarda no centro historico.\n\nULTREIA ET SUSEIA ‚Äî Antiguo saludo peregrino\n"Adelante y hacia arriba"\n\n- Praza do Obradoiro ‚Äî imprescindible\n- Tarta de Santiago de postre\n\nBon Camino. AirNubeiro OPS.`,
      cs => `=== SANTIAGO CHEGADA ===\n${cs}\n\nBenvido ao fin do Camino de Santiago.\nO Casco Vello: Patrimonio da Humanidade UNESCO.\n\n"Aquel que ten saudade, nen come, nen durme, nen ri"\n‚Äî Rosalia de Castro\n\nOPS NBV ‚Äî Benvidos peregrinos do aire.`,
    ]
  },
};

function genGalicianWelcome(flt) {
  const apt = GALICIAN_AIRPORTS[flt.arr?.toUpperCase()];
  if (!apt) return null;
  const msgs = apt.messages;
  return msgs[Math.floor(Math.random() * msgs.length)](flt.callsign);
}

async function genLanded(flt) {
  const dep = flt.dep || '????';
  const arr = flt.arr || '????';
  const flightMin = flt.enrouteStart ? Math.round((Date.now() - flt.enrouteStart) / 60000) : 0;
  const monitorMin = flt.firstSeen ? Math.round((Date.now() - flt.firstSeen) / 60000) : 0;
  const stand = flt.assignedParking || genParking(arr);
  const msgs = [];

  // Mensaje gallego personalizado (si aplica) ‚Äî va primero
  const galMsg = genGalicianWelcome(flt);
  if (galMsg) msgs.push({ id: 'galician_welcome', label: 'GAL WELCOME', body: galMsg });

  // Welcome message with flight time
  const welcome = [
    `=== BIENVENIDO ${arr} ===`,
    `${flt.callsign} ‚Äî ${dep}/${arr} (${flt.aircraft})`,
    flightMin > 0 ? `TIEMPO DE VUELO: ${Math.floor(flightMin/60)}h${String(flightMin%60).padStart(2,'0')}m` : '',
    monitorMin > flightMin + 5 ? `TIEMPO TOTAL: ${Math.floor(monitorMin/60)}h${String(monitorMin%60).padStart(2,'0')}m` : '',
    stand ? `PARKING: ${stand}` : '',
    `Gracias por volar con AirNubeiro.`,
    `Buen servicio, cielos limpios.`,
  ].filter(Boolean).join('\n');
  msgs.push({ id: 'welcome', label: 'WELCOME', body: welcome });

  // Delay report ‚Äî check if departure was late vs planned
  const delayMsg = genDelayReport(flt);
  if (delayMsg) {
    msgs.push({ id: 'delay', label: 'DELAY RPT', body: delayMsg });
  }

  // Crew rotation + next flight
  const crewMsg = genCrewInfo(flt);
  if (crewMsg) {
    msgs.push({ id: 'crew', label: 'CREW INFO', body: `=== CREW ${flt.callsign} ===\n${arr}\n${crewMsg}` });
  }

  return msgs;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DELAY DETECTION & REPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function genDelayReport(flt) {
  // IVAO flightPlan.departureTime is typically HHMM in UTC
  // Compare with actual enrouteStart (real takeoff)
  if (!flt.plannedDepTime || !flt.enrouteStart) return null;

  let plannedMin = 0;
  const pdt = flt.plannedDepTime;

  // Parse planned departure time ‚Äî could be HHMM, epoch seconds, or string
  if (typeof pdt === 'number') {
    if (pdt > 100000) {
      // Epoch seconds ‚Üí extract HHMM
      const d = new Date(pdt * 1000);
      plannedMin = d.getUTCHours() * 60 + d.getUTCMinutes();
    } else {
      // HHMM format
      plannedMin = Math.floor(pdt / 100) * 60 + (pdt % 100);
    }
  } else if (typeof pdt === 'string') {
    const m = pdt.match(/(\d{1,2}):?(\d{2})/);
    if (m) plannedMin = parseInt(m[1]) * 60 + parseInt(m[2]);
    else return null;
  } else return null;

  // Actual departure in minutes since midnight UTC
  const actualDep = new Date(flt.enrouteStart);
  const actualMin = actualDep.getUTCHours() * 60 + actualDep.getUTCMinutes();

  // Calculate delay (handle midnight crossover)
  let delayMin = actualMin - plannedMin;
  if (delayMin < -720) delayMin += 1440; // crossed midnight
  if (delayMin > 720) delayMin -= 1440;

  // Only report if delay > 15 minutes
  if (delayMin <= 15) return null;

  // Pick one of 3 delay report templates
  const templates = [
    [
      `=== DELAY REPORT ${flt.callsign} ===`,
      `${flt.dep}‚Üí${flt.arr}`,
      `ETD PLANIFICADO: ${String(Math.floor(plannedMin/60)).padStart(2,'0')}${String(plannedMin%60).padStart(2,'0')}z`,
      `SALIDA REAL: ${String(actualDep.getUTCHours()).padStart(2,'0')}${String(actualDep.getUTCMinutes()).padStart(2,'0')}z`,
      `DELAY: +${delayMin} MIN`,
      `---`,
      `ACCION REQUERIDA:`,
      `Reportar motivo del retraso a OPS.`,
      `Codigo delay IATA requerido.`,
      `Contactar jefe de operaciones antes`,
      `de iniciar siguiente rotacion.`,
    ],
    [
      `=== DELAY REPORT ${flt.callsign} ===`,
      `${flt.dep}‚Üí${flt.arr}`,
      `RETRASO DETECTADO: +${delayMin} MIN`,
      `ETD ${String(Math.floor(plannedMin/60)).padStart(2,'0')}${String(plannedMin%60).padStart(2,'0')}z ‚Üí REAL ${String(actualDep.getUTCHours()).padStart(2,'0')}${String(actualDep.getUTCMinutes()).padStart(2,'0')}z`,
      `---`,
      `DOCUMENTACION PENDIENTE:`,
      `Completar formulario de incidencia`,
      `operacional post-vuelo.`,
      `Incluir codigo IATA y descripcion`,
      `del motivo del retraso.`,
      `Entregar en briefing room o via email`,
      `a ops@airnubeiro.va`,
    ],
    [
      `=== DELAY REPORT ${flt.callsign} ===`,
      `${flt.dep}‚Üí${flt.arr} ‚Äî DELAY +${delayMin}MIN`,
      `PLAN: ${String(Math.floor(plannedMin/60)).padStart(2,'0')}${String(plannedMin%60).padStart(2,'0')}z / REAL: ${String(actualDep.getUTCHours()).padStart(2,'0')}${String(actualDep.getUTCMinutes()).padStart(2,'0')}z`,
      `---`,
      `PAPERWORK REQUERIDO:`,
      `Se requiere informe de retraso.`,
      `Rellenar delay report antes de`,
      `abandonar la aeronave.`,
      `Motivo + codigo IATA + firma PIC.`,
      `Copia a dispatch y crew planning.`,
    ],
  ];

  const tpl = templates[Math.floor(Math.random() * templates.length)];
  return tpl.join('\n');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ROUTE INFO ‚Äî ATCs, SIGMETs, PIREPs, METAR en ruta
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Haversine distance in nautical miles
function haversineNm(lat1, lon1, lat2, lon2) {
  const R = 3440.065; // Earth radius in nm
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// Bearing from point 1 to point 2 (degrees)
function bearing(lat1, lon1, lat2, lon2) {
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
  const x = Math.cos(lat1*Math.PI/180) * Math.sin(lat2*Math.PI/180) - Math.sin(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.cos(dLon);
  return ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;
}

// Check if a point is roughly "ahead" of pilot (within ¬±100¬∞ of heading)
function isAhead(pilotLat, pilotLon, pilotHdg, targetLat, targetLon) {
  const brg = bearing(pilotLat, pilotLon, targetLat, targetLon);
  let diff = Math.abs(brg - pilotHdg);
  if (diff > 180) diff = 360 - diff;
  return diff < 100;
}

// Format IVAO frequency (stored as Hz integer ‚Üí MHz string)
function fmtFreq(f) {
  if (!f) return '---';
  if (f > 100000) return (f / 1000000).toFixed(3);
  if (f > 100) return (f / 1000).toFixed(3);
  return String(f);
}

// Determine ATC position type from callsign
function atcType(cs) {
  if (cs.includes('_DEL')) return 'DEL';
  if (cs.includes('_GND')) return 'GND';
  if (cs.includes('_TWR')) return 'TWR';
  if (cs.includes('_APP') || cs.includes('_DEP')) return 'APP';
  if (cs.includes('_CTR')) return 'CTR';
  if (cs.includes('_FSS')) return 'FSS';
  return 'ATC';
}

async function genRouteInfo(flt) {
  const msgs = [];
  const ivao = lastIvaoData;
  if (!ivao) return msgs;

  const pLat = flt.lat, pLon = flt.lng;
  if (!pLat && !pLon) return msgs;

  const hdg = flt.heading || 0;
  const RADIUS_NM = 400;
  let body = `=== ROUTE INFO ${flt.callsign} ===\n${flt.dep}‚Üí${flt.arr} FL${Math.round(flt.alt/100)} GS${flt.gs}\n`;

  // ‚îÄ‚îÄ 1. ATCs in corridor ‚îÄ‚îÄ
  // En route: only CTR and FSS
  // Destination area: include APP/TWR for arrival airport
  const atcs = ivao.clients?.atcs || [];
  const enrouteAtc = [];
  const destAtc = [];
  const arrPrefix = (flt.arr || '').substring(0, 4);
  for (const a of atcs) {
    if (!a.callsign || !a.lastTrack) continue;
    const aLat = a.lastTrack.latitude, aLon = a.lastTrack.longitude;
    if (!aLat && !aLon) continue;
    const type = atcType(a.callsign.toUpperCase());
    if (type === 'GND' || type === 'DEL') continue;
    const dist = haversineNm(pLat, pLon, aLat, aLon);
    if (dist > RADIUS_NM) continue;
    const ahead = isAhead(pLat, pLon, hdg, aLat, aLon);
    const freq = a.atcSession?.frequency || a.frequency || null;
    const entry = { cs: a.callsign, type, freq: fmtFreq(freq), dist: Math.round(dist), ahead };
    // Destination ATC: callsign starts with arrival ICAO
    const csUp = a.callsign.toUpperCase();
    if (arrPrefix && csUp.startsWith(arrPrefix)) {
      destAtc.push(entry);
    } else if (type === 'CTR' || type === 'FSS') {
      if (ahead || dist <= 200) enrouteAtc.push(entry);
    }
  }
  enrouteAtc.sort((a, b) => (b.ahead - a.ahead) || (a.dist - b.dist));
  destAtc.sort((a, b) => a.dist - b.dist);

  if (enrouteAtc.length) {
    body += `--- ATC EN RUTA (CTR/FSS) ---\n`;
    for (const a of enrouteAtc.slice(0, 8)) {
      body += `${a.cs} ${a.freq} ${a.type} ${a.dist}nm\n`;
    }
  }
  if (destAtc.length) {
    body += `--- ATC DESTINO ${flt.arr} ---\n`;
    for (const a of destAtc.slice(0, 6)) {
      body += `${a.cs} ${a.freq} ${a.type}\n`;
    }
  }
  if (!enrouteAtc.length && !destAtc.length) {
    body += `NO ATC ACTIVO EN RUTA/DESTINO\n`;
  }

  // Keep relevantAtc reference for SIGMET prefix matching
  const relevantAtc = [...enrouteAtc, ...destAtc];

  // ‚îÄ‚îÄ 2. SIGMETs ‚îÄ‚îÄ
  try {
    const sResp = await fetch(proxy(`${SIGMET_API}?format=json`), { signal: AbortSignal.timeout(8000) });
    const sData = await sResp.json();
    const relevantSig = [];
    if (Array.isArray(sData)) {
      for (const s of sData) {
        // Check if SIGMET has coordinate info and is near route
        const sLat = s.lat || (s.coords?.[0]?.lat);
        const sLon = s.lon || (s.coords?.[0]?.lon);
        if (sLat && sLon) {
          const dist = haversineNm(pLat, pLon, sLat, sLon);
          if (dist < RADIUS_NM) {
            relevantSig.push({ raw: s.rawAirSigmet || s.rawSigmet || `${s.hazard||'?'} ${s.severity||''} ${s.icaoId||''}`, dist: Math.round(dist) });
          }
        } else if (s.rawAirSigmet || s.rawSigmet) {
          // No coords ‚Äî include if ICAO prefix matches route area
          const raw = s.rawAirSigmet || s.rawSigmet || '';
          const icao = s.icaoId || '';
          const depPfx = flt.dep.substring(0, 2);
          const arrPfx = flt.arr.substring(0, 2);
          if (icao.startsWith(depPfx) || icao.startsWith(arrPfx)) {
            relevantSig.push({ raw: raw.substring(0, 160), dist: null });
          }
        }
      }
    }
    if (relevantSig.length) {
      body += `--- SIGMET ---\n`;
      for (const s of relevantSig.slice(0, 5)) {
        body += `${s.raw.substring(0,140)}${s.dist ? ` (${s.dist}nm)` : ''}\n`;
      }
    }
  } catch(e) {
    log(`SIGMET fetch error: ${e.message}`, 'wrn');
  }

  // ‚îÄ‚îÄ 3. PIREPs ‚îÄ‚îÄ
  try {
    const pResp = await fetch(proxy(`${PIREP_API}?format=json&age=4`), { signal: AbortSignal.timeout(8000) });
    const pData = await pResp.json();
    const relevantPirep = [];
    if (Array.isArray(pData)) {
      for (const p of pData) {
        const prLat = p.lat || p.latitude;
        const prLon = p.lon || p.longitude;
        if (!prLat || !prLon) continue;
        const dist = haversineNm(pLat, pLon, prLat, prLon);
        if (dist > RADIUS_NM) continue;
        // Only include if has significant info (turbulence, icing)
        const turb = p.turbulenceCondition || p.tbInt || p.turbulence || '';
        const ice = p.icingCondition || p.icInt || p.icing || '';
        if (!turb && !ice) continue;
        const alt = p.altitude || p.fltlvl || '???';
        relevantPirep.push({ raw: p.rawOb || `FL${alt} TURB:${turb||'NIL'} ICE:${ice||'NIL'}`, dist: Math.round(dist) });
      }
    }
    if (relevantPirep.length) {
      body += `--- PIREP ---\n`;
      for (const p of relevantPirep.slice(0, 5)) {
        body += `${p.raw.substring(0,140)} (${p.dist}nm)\n`;
      }
    }
  } catch(e) {
    log(`PIREP fetch error: ${e.message}`, 'wrn');
  }

  // ‚îÄ‚îÄ 4. METAR destino ‚îÄ‚îÄ
  try {
    if (flt.arr && flt.arr !== '????') {
      const mResp = await fetch(proxy(`${METAR_API}?ids=${flt.arr}&format=raw&hours=1`), { signal: AbortSignal.timeout(6000) });
      const mTxt = await mResp.text();
      if (mTxt.trim()) {
        const firstMetar = mTxt.trim().split('\n')[0];
        body += `--- METAR DESTINO ---\n${firstMetar}\n`;
      }
    }
  } catch(e) {}

  // Assign parking stand (generate once, reuse)
  if (!flt.assignedParking) flt.assignedParking = genParking(flt.arr);
  if (flt.assignedParking) {
    body += `--- PARKING ASIGNADO ---\n${flt.arr}: ${flt.assignedParking}\n`;
  }

  msgs.push({ id: 'route_info', label: 'ROUTE INFO', body });
  return msgs;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  EET ESTIMATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function estimateEnrouteMin(pilot, flt) {
  // Strategy 1: IVAO flight plan EET
  const fp = pilot.flightPlan;
  if (fp?.eet) {
    const eet = parseInt(fp.eet);
    if (eet > 0) {
      // IVAO EET can be in seconds (large numbers) or HHMM format
      if (eet > 10000) return Math.round(eet / 60); // seconds ‚Üí minutes
      if (eet > 100) {
        // HHMM format: 0130 = 1h30m
        const h = Math.floor(eet / 100);
        const m = eet % 100;
        return h * 60 + m;
      }
      return eet; // assume minutes
    }
  }

  // Strategy 2: SimBrief (if roster mapping exists)
  const sbUser = roster[flt.callsign];
  if (sbUser && flt._sbEet) return flt._sbEet; // cached from preflight fetch

  // Strategy 3: Distance / groundspeed
  if (flt.dep !== '????' && flt.arr !== '????' && flt.lat && flt.lng) {
    // Approximate: use dep‚Üíarr distance / avg cruise speed
    // We don't have arr coordinates directly, but we can estimate
    // from current GS. Typical jet cruise: 420-480kt
    const gs = flt.gs > 100 ? flt.gs : 440; // use current GS or typical
    // Use remaining distance estimate: if we have dep/arr lat/lng we could compute
    // For now, use a simpler heuristic from EET or typical flight durations
    // Short haul (same country prefix): ~90min, medium: ~180min, long: ~360min
    const depPfx = flt.dep.substring(0, 1);
    const arrPfx = flt.arr.substring(0, 1);
    const samePfx2 = flt.dep.substring(0, 2) === flt.arr.substring(0, 2);
    if (samePfx2) return 75; // domestic ~1h15
    if (depPfx === arrPfx) return 150; // same region ~2h30
    return 300; // intercontinental ~5h
  }

  return 0; // cannot estimate
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MONITOR LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function scan() {
  const prefix = $('cA').value.trim().toUpperCase();
  if (!prefix) return;

  try {
    // Robust cache-busting: unique param per scan to defeat any proxy caching
    const ivaoUrl = `${IVAO_WHAZZUP}?_t=${Date.now()}&_r=${Math.random().toString(36).substring(2,8)}`;
    const resp = await fetch(proxy(ivaoUrl), {
      signal: AbortSignal.timeout(30000),
      headers: { 'Cache-Control': 'no-cache, no-store, must-revalidate', 'Pragma': 'no-cache' }
    });
    if (!resp.ok) throw new Error(`IVAO HTTP ${resp.status}`);
    const text = await resp.text();
    let data;
    try { data = JSON.parse(text); } catch(e) {
      log(`IVAO: respuesta truncada o invalida (${text.length} chars)`, 'err');
      return;
    }
    lastIvaoData = data; // cache for route info
    const allPilots = data.clients?.pilots || [];
    const allAtcs = data.clients?.atcs || [];
    log(`IVAO: ${allPilots.length} pilotos totales, ${allAtcs.length} ATCs`, '');
    const nbvPilots = allPilots.filter(p => p.callsign && p.callsign.toUpperCase().startsWith(prefix));
    if (nbvPilots.length > 0) {
      log(`${prefix}: ${nbvPilots.length} detectado(s) [${nbvPilots.map(p => {
        const ph = p.lastTrack?.onGround ? 'GND' : `FL${Math.round((p.lastTrack?.altitude||0)/100)}`;
        const dep = p.flightPlan?.departureId || '?';
        const arr = p.flightPlan?.arrivalId || '?';
        return `${p.callsign}(${ph} ${dep}-${arr})`;
      }).join(', ')}]`, 'ops');
    } else {
      // Debug: log nearby callsigns to help diagnose
      const nearMatch = allPilots.filter(p => p.callsign && p.callsign.toUpperCase().includes('NBV')).map(p => p.callsign);
      log(`${prefix}: ningun piloto detectado${nearMatch.length ? ` (parcial: ${nearMatch.join(', ')})` : ''}`, '');
    }

    // Track which callsigns are still online
    const onlineCs = new Set(nbvPilots.map(p => p.callsign.toUpperCase()));

    // Mark offline flights (keep for 5 min then remove)
    for (const cs of Object.keys(flights)) {
      if (!onlineCs.has(cs)) {
        if (!flights[cs].offlineSince) {
          flights[cs].offlineSince = Date.now();
          log(`${cs} desconectado de IVAO`, 'wrn');
        } else if (Date.now() - flights[cs].offlineSince > 300000) {
          delete flights[cs];
        }
      }
    }

    // Process each NBV pilot
    for (const pilot of nbvPilots) {
      const cs = pilot.callsign.toUpperCase();
      const fp = pilot.flightPlan;
      const prev = flights[cs] || null;
      const track = pilot.lastTrack || {};

      // Safe extraction ‚Äî IVAO v2 can return nested objects for some fields
      const safeNum = v => typeof v === 'number' ? v : (typeof v === 'object' ? 0 : parseFloat(v) || 0);
      const safeStr = v => typeof v === 'string' ? v : (typeof v === 'object' ? (v?.id || v?.code || '') : String(v || ''));

      const curAlt = safeNum(track.altitude);
      const curGs = safeNum(track.groundSpeed);
      const curLat = safeNum(track.latitude);
      const curLng = safeNum(track.longitude);
      const curHdg = safeNum(track.heading || track.transponderHeading);
      const curOnGnd = track.onGround === true || track.onGround === 1;
      const curAcft = safeStr(fp?.aircraftId);
      const curDep = safeStr(fp?.departureId);
      const curArr = safeStr(fp?.arrivalId);

      // Adjuntar fase phpVMS al piloto para que detectPhase la use con prioridad
      const pvData = phpvmsActive[cs];
      if (pvData?.phpvmsPhase) pilot._phpvmsPhase = pvData.phpvmsPhase;

      const newPhase = detectPhase(pilot, prev);
      const phaseChanged = prev && prev.phase !== newPhase;

      // Update or create flight record ‚Äî ALL dynamic data refreshes every scan
      flights[cs] = {
        callsign: cs,
        phase: newPhase,
        prevPhase: prev?.phase || null,
        dep: curDep || prev?.dep || pvData?.dep || '????',
        arr: curArr || prev?.arr || pvData?.arr || '????',
        alt: curAlt,
        prevAlt: prev?.alt || curAlt,
        gs: curGs,
        heading: curHdg || prev?.heading || 0,
        onGround: curOnGnd,
        lat: curLat,
        lng: curLng,
        aircraft:    curAcft || prev?.aircraft || pvData?.aircraft || '????',
        ivaoState:   track.state || '',
        arrivalDist: typeof track.arrivalDistance === 'number' ? track.arrivalDistance : null,
        // Datos phpVMS ‚Äî persisten del scan anterior o se toman de phpvmsActive
        pilotName:   prev?.pilotName   || pvData?.pilotName   || '',
        pilotIdent:  prev?.pilotIdent  || pvData?.pilotIdent  || '',
        registration:prev?.registration|| pvData?.registration|| '',
        acName:      prev?.acName      || pvData?.acName      || '',
        phpvmsRoute: prev?.phpvmsRoute || pvData?.route       || '',
        planFL:      prev?.planFL      || pvData?.planFL      || 0,
        progressPct: pvData?.progressPct || prev?.progressPct || 0,
        arrLat:      prev?.arrLat  ?? pvData?.arrLat  ?? null,
        arrLon:      prev?.arrLon  ?? pvData?.arrLon  ?? null,
        pirepId:     prev?.pirepId || pvData?.pirepId || null,
        _phpvmsPhase:pvData?.phpvmsPhase || '',
        plannedDepTime: prev?.plannedDepTime || fp?.departureTime || null,
        firstSeen: prev?.firstSeen || Date.now(),
        lastSeen: Date.now(),
        // Route info smart timing
        enrouteStart: prev?.enrouteStart || 0,
        estEnrouteMin: prev?.estEnrouteMin || 0,
        riSent1: prev?.riSent1 || false,
        riSent2: prev?.riSent2 || false,
        assignedParking: prev?.assignedParking || null,
        lastRouteInfo: prev?.lastRouteInfo || 0,
        routeInfoCount: prev?.routeInfoCount || 0,
        offlineSince: null,
        sent: prev?.sent || { preflight: false, enroute: false, descent: false, landed: false },
        msgStatus: prev?.msgStatus || {},
      };

      const flt = flights[cs];

      // FSUIPC: inyectar datos del sim para el vuelo local
      fsuipcInjectIntoFlight(flt);

      // New flight detected
      if (!prev) {
        log(`‚úà ${cs} detectado: ${flt.dep}‚Üí${flt.arr} (${flt.aircraft})`, 'ops');
        notifySound();
        discordNotifyDetected(flt);
      }

      // Phase transition ‚Üí trigger messages + Discord
      if (phaseChanged) {
        log(`${cs}: ${prev.phase} ‚Üí ${newPhase}`, 'ops');
        discordNotifyPhase(flt, prev.phase, newPhase);
      }

      // On entering ENROUTE: estimate flight time and record start
      if (newPhase === 'ENROUTE' && !flt.enrouteStart) {
        flt.enrouteStart = Date.now();
        flt.estEnrouteMin = estimateEnrouteMin(pilot, flt);
        if (flt.estEnrouteMin > 0) {
          log(`${cs}: EET estimado ${Math.floor(flt.estEnrouteMin/60)}h${String(Math.round(flt.estEnrouteMin%60)).padStart(2,'0')}m`, '');
        }
      }

      // Auto-generate and optionally send messages on phase entry
      const autoSend = $('cAuto').value === '1';

      // Phase dedup: check both in-memory flag and localStorage registry
      // This prevents re-sending on page reload if same flight still active
      if (newPhase === 'PREFLIGHT' && !flt.sent.preflight) {
        if (wasSentRecently(cs, flt.dep, flt.arr, 'preflight', 90*60000)) {
          flt.sent.preflight = true; // mark in-memory to skip future checks
          log(`${cs}: preflight ya enviado (sesi√≥n anterior), omitido`, '');
        } else {
          flt.sent.preflight = true;
          processMessages(flt, 'preflight', genPreflight, autoSend);
        }
      }
      if (newPhase === 'ENROUTE' && !flt.sent.enroute) {
        if (wasSentRecently(cs, flt.dep, flt.arr, 'enroute', 90*60000)) {
          flt.sent.enroute = true;
          log(`${cs}: enroute ya enviado (sesi√≥n anterior), omitido`, '');
        } else {
          flt.sent.enroute = true;
          processMessages(flt, 'enroute', genEnroute, autoSend);
        }
      }
      if (newPhase === 'DESCENT' && !flt.sent.descent) {
        if (wasSentRecently(cs, flt.dep, flt.arr, 'descent', 60*60000)) {
          flt.sent.descent = true;
          log(`${cs}: descent ya enviado (sesi√≥n anterior), omitido`, '');
        } else {
          flt.sent.descent = true;
          processMessages(flt, 'descent', genDescent, autoSend);
        }
      }
      if (newPhase === 'LANDED' && !flt.sent.landed) {
        if (wasSentRecently(cs, flt.dep, flt.arr, 'landed', 60*60000)) {
          flt.sent.landed = true;
          log(`${cs}: landed ya enviado (sesi√≥n anterior), omitido`, '');
        } else {
          flt.sent.landed = true;
          processMessages(flt, 'landed', genLanded, autoSend);
        }
      }

      // Smart ROUTE INFO timing for ENROUTE/DESCENT flights
      if ((newPhase === 'ENROUTE' || newPhase === 'DESCENT') && flt.lat && flt.lng) {
        const riMode = $('cRI').value;
        const minSinceEnroute = flt.enrouteStart ? (Date.now() - flt.enrouteStart) / 60000 : 0;
        // Route info dedup: check if one was sent recently (prevents re-send on restart)
        const riDedupMs = riMode === 'smart' ? 12*60000 : Math.max(5, parseInt(riMode)||10)*60000;
        const riRecentlySent = wasSentRecently(cs, flt.dep, flt.arr, 'routeinfo', riDedupMs);

        // On restart: if route info was recently sent (from localStorage), restore in-memory flags
        if (riRecentlySent && !flt.riSent1) {
          flt.riSent1 = true;
          log(`${cs}: route info reciente (sesi√≥n anterior), restaurando estado`, '');
        }

        if (riMode === 'smart') {
          // ‚îÄ‚îÄ Smart timing ‚îÄ‚îÄ
          // RI #1: ~15 min after entering enroute (only if significant info available)
          if (!flt.riSent1 && minSinceEnroute >= 15) {
            flt.riSent1 = true;
            flt.routeInfoCount++;
            const riKey = `routeinfo_${flt.routeInfoCount}`;
            // Generate and check if there's significant content before sending
            processMessagesConditional(flt, riKey, genRouteInfo, autoSend, true);
          }
          // RI #2: midpoint of estimated enroute time (always send)
          if (!flt.riSent2 && flt.estEnrouteMin > 0) {
            const midpoint = flt.estEnrouteMin / 2;
            // Only if midpoint is at least 10 min after RI #1
            if (minSinceEnroute >= midpoint && midpoint >= 25) {
              flt.riSent2 = true;
              flt.routeInfoCount++;
              const riKey = `routeinfo_${flt.routeInfoCount}`;
              processMessages(flt, riKey, genRouteInfo, autoSend);
            }
          }
          // Fallback: if no EET estimated but >30min in cruise and only sent RI#1
          if (!flt.riSent2 && flt.estEnrouteMin === 0 && minSinceEnroute >= 30 && flt.riSent1) {
            flt.riSent2 = true;
            flt.routeInfoCount++;
            const riKey = `routeinfo_${flt.routeInfoCount}`;
            processMessages(flt, riKey, genRouteInfo, autoSend);
          }
        } else {
          // ‚îÄ‚îÄ Fixed interval mode ‚îÄ‚îÄ
          const riMinutes = Math.max(5, parseInt(riMode) || 10);
          const elapsed = (Date.now() - flt.lastRouteInfo) / 60000;
          if (elapsed >= riMinutes) {
            flt.lastRouteInfo = Date.now();
            flt.routeInfoCount++;
            const riKey = `routeinfo_${flt.routeInfoCount}`;
            processMessages(flt, riKey, genRouteInfo, autoSend);
          }
        }
      }
    }

    updateDashboard();
    updateStats();
    updateAoc();
    renderRosterChips();

    // ‚òÖ CRITICAL: Refresh dashboard + stats EVERY scan, not just on phase change
    updateDashboard();
    updateStats();

    const n = Object.keys(flights).filter(cs => !flights[cs].offlineSince).length;
    ss('live', `Monitor activo ‚Äî ${n} vuelo(s) NBV ‚Äî ${tsShort()}`);

  } catch(e) {
    log(`Scan error: ${e.message}`, 'err');
    ss('err', `‚úó Error: ${e.message}`);
  }
}

async function processMessages(flt, phase, generatorFn, autoSend) {
  try {
    const msgs = await generatorFn(flt);
    for (const m of msgs) {
      const key = `${phase}_${m.id}`;
      flt.msgStatus[key] = autoSend ? 'sending' : 'pending';
      flt['msg_' + key] = m.body; // store body for manual send
      updateDashboard();

      if (autoSend) {
        try {
          await sendTelex(flt.callsign, m.body);
          flt.msgStatus[key] = 'sent';
          log(`‚úì ${m.label} ‚Üí ${flt.callsign}`, 'ok');
          recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'sent', m.body);
          await sleep(800); // rate limit between messages
        } catch(e) {
          flt.msgStatus[key] = 'error';
          log(`‚úó ${m.label} ‚Üí ${flt.callsign}: ${e.message}`, 'err');
          recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'error', m.body);
        }
      } else {
        log(`${m.label} generado para ${flt.callsign} (env√≠o manual)`, '');
      }
    }
    updateDashboard();
    updateStats();
  } catch(e) {
    log(`Error generando msgs ${phase} para ${flt.callsign}: ${e.message}`, 'err');
  }
}

// Conditional version: only sends if the message body contains significant info
// (SIGMETs, PIREPs, or notable ATC changes). Used for 15min post-departure check.
async function processMessagesConditional(flt, phase, generatorFn, autoSend, requireSignificant) {
  try {
    const msgs = await generatorFn(flt);
    for (const m of msgs) {
      // Check if content is "significant" ‚Äî has SIGMETs, PIREPs, or many ATCs
      const hasSignificant = !requireSignificant ||
        m.body.includes('SIGMET') ||
        m.body.includes('PIREP') ||
        (m.body.match(/ATC EN RUTA/i) && (m.body.match(/\n/g)||[]).length > 8);

      if (!hasSignificant) {
        log(`${m.label} ${flt.callsign}: sin info significativa, omitido`, '');
        recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'skip', m.body);
        continue;
      }

      const key = `${phase}_${m.id}`;
      flt.msgStatus[key] = autoSend ? 'sending' : 'pending';
      flt['msg_' + key] = m.body;
      updateDashboard();

      if (autoSend) {
        try {
          await sendTelex(flt.callsign, m.body);
          flt.msgStatus[key] = 'sent';
          log(`‚úì ${m.label} ‚Üí ${flt.callsign} (significativo)`, 'ok');
          recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'sent', m.body);
          await sleep(800);
        } catch(e) {
          flt.msgStatus[key] = 'error';
          log(`‚úó ${m.label} ‚Üí ${flt.callsign}: ${e.message}`, 'err');
          recordSent(flt.callsign, flt.dep, flt.arr, phase, m.label, 'error', m.body);
        }
      } else {
        log(`${m.label} generado para ${flt.callsign} (env√≠o manual)`, '');
      }
    }
    updateDashboard();
    updateStats();
  } catch(e) {
    log(`Error generando msgs ${phase} para ${flt.callsign}: ${e.message}`, 'err');
  }
}

// Manual send from dashboard
async function manualSend(cs, key) {
  const flt = flights[cs];
  if (!flt) return;
  const body = flt['msg_' + key];
  if (!body) return;
  flt.msgStatus[key] = 'sending';
  updateDashboard();
  try {
    await sendTelex(cs, body);
    flt.msgStatus[key] = 'sent';
    log(`‚úì ${key} ‚Üí ${cs} (manual)`, 'ok');
  } catch(e) {
    flt.msgStatus[key] = 'error';
    log(`‚úó ${key} ‚Üí ${cs}: ${e.message}`, 'err');
  }
  // phpVMS: merge vuelos adicionales no detectados por IVAO
  if ($('phpvmsEn')?.checked) phpvmsMergeWithFlights();
  updateDashboard();
  updateStats();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DASHBOARD RENDERING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function updateDashboard() {
  const dash = $('dashboard');
  const activeFlights = Object.values(flights).filter(f => !f.offlineSince);

  if (activeFlights.length === 0) {
    dash.innerHTML = '<div class="dash-empty" id="dashEmpty">Ning√∫n vuelo NBV detectado</div>';
    return;
  }

  // Sort: preflight first, then enroute, descent, landed
  const order = { PREFLIGHT: 0, ENROUTE: 1, DESCENT: 2, LANDED: 3 };
  activeFlights.sort((a, b) => (order[a.phase]||9) - (order[b.phase]||9));

  dash.innerHTML = '';
  for (const f of activeFlights) {
    const card = document.createElement('div');
    card.className = `flt-card ph-${f.phase.toLowerCase()}`;

    const phaseLabel = { PREFLIGHT: 'PREFLIGHT', ENROUTE: 'EN RUTA', DESCENT: 'DESCENSO', LANDED: 'LANDED' }[f.phase] || f.phase;

    // Message badges
    let msgsHtml = '';
    for (const [key, status] of Object.entries(f.msgStatus)) {
      const label = key.replace(/_/g, ' ').toUpperCase();
      const clickable = status === 'pending' || status === 'error';
      const onclick = clickable ? `onclick="manualSend('${esc(f.callsign)}','${esc(key)}')"` : '';
      const cursor = clickable ? 'cursor:pointer;' : '';
      msgsHtml += `<span class="flt-msg ${status}" style="${cursor}" ${onclick} title="${status === 'pending' ? 'Click para enviar' : status}">${label}: ${status === 'sent' ? '‚úì' : status === 'sending' ? '‚è≥' : status === 'error' ? '‚úó retry' : 'üì§'}</span>`;
    }

    card.innerHTML = `
      <div>
        <div class="flt-cs">${esc(f.callsign)}</div>
        <div class="flt-route">${esc(f.dep)} ‚Üí ${esc(f.arr)}</div>
        <div class="flt-ac">${esc(f.aircraft)}${f.registration ? ` <span style="color:var(--tx3)">${esc(f.registration)}</span>` : ''}</div>
        ${f.pilotIdent || f.pilotName ? `<div class="flt-pilot" style="font:.4rem var(--mono);color:var(--tx3);margin-top:2px">${esc(f.pilotIdent||'')}${f.pilotName ? ' ¬∑ '+esc(f.pilotName) : ''}</div>` : ''}
        ${f.progressPct > 0 ? `<div class="flt-progress" style="margin-top:4px">
          <div style="background:var(--bg3);border-radius:3px;height:3px;overflow:hidden">
            <div style="background:var(--acc);width:${f.progressPct}%;height:3px;border-radius:3px;transition:width .5s"></div>
          </div>
          <div style="font:.45rem var(--mono);color:var(--tx3);margin-top:1px">${f.progressPct}% ruta</div>
        </div>` : ''}
      </div>
      <div class="flt-data">
        <div class="flt-d">ALT <span>${f.alt > 0 ? 'FL'+Math.round(f.alt/100) : f.onGround ? 'GND' : '‚Äî'}</span></div>
        <div class="flt-d">GS <span>${f.gs > 0 ? f.gs+'kt' : '‚Äî'}</span></div>
        ${f.arrivalDist != null ? `<div class="flt-d">DEST <span>${Math.round(f.arrivalDist)}nm</span></div>` : ''}
        ${f.ivaoState ? `<div class="flt-d">ST <span style="font-size:.55rem">${esc(f.ivaoState)}</span></div>` : ''}
        ${f.estEnrouteMin > 0 ? `<div class="flt-d">EET <span>${Math.floor(f.estEnrouteMin/60)}h${String(Math.round(f.estEnrouteMin%60)).padStart(2,'0')}m</span></div>` : ''}
        ${f.enrouteStart ? `<div class="flt-d">ENR <span>${Math.round((Date.now()-f.enrouteStart)/60000)}min</span></div>` : ''}
        ${f.routeInfoCount > 0 ? `<div class="flt-d">RI <span>√ó${f.routeInfoCount}</span></div>` : ''}
      </div>
      <div>
        <div class="flt-phase ${f.phase.toLowerCase()}">${phaseLabel}</div>
        <div style="margin-top:4px;text-align:center">
          <span class="${f.srcSim ? 'src-sim' : f.srcPhpvms ? 'src-phpvms' : 'src-ivao'}" style="font:.45rem var(--mono);padding:1px 4px;border-radius:2px">
            ${f.srcSim ? 'SIM' : f.srcPhpvms ? 'phpVMS' : 'IVAO'}
          </span>
        </div>
      </div>
      ${msgsHtml ? `<div class="flt-msgs">${msgsHtml}</div>` : ''}`;

    dash.appendChild(card);
  }
}

function updateStats() {
  const active = Object.values(flights).filter(f => !f.offlineSince);
  $('stTotal').textContent = active.length;
  $('stPre').textContent = active.filter(f => f.phase === 'PREFLIGHT').length;
  $('stEnr').textContent = active.filter(f => f.phase === 'ENROUTE').length;
  $('stDsc').textContent = active.filter(f => f.phase === 'DESCENT').length;
  $('stLnd').textContent = active.filter(f => f.phase === 'LANDED').length;
  $('stMsgs').textContent = totalMsgsSent;
  $('statsBar').style.display = 'flex';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MONITOR CONTROL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function toggleMonitor() {
  if (monitorInterval) {
    clearInterval(monitorInterval);
    monitorInterval = null;
    $('btnMonitor').classList.remove('on');
    $('btnMonitor').classList.remove('stop');
    $('monIco').textContent = '‚ñ∂';
    $('monTxt').textContent = 'INICIAR';
    ss('ok', 'Monitor detenido');
    log('Monitor detenido', 'wrn');
  } else {
    if (!$('cL').value.trim() || !$('cS').value.trim()) {
      ss('err', '‚úó Configura logon y callsign');
      return;
    }
    const iv = Math.max(15, parseInt($('cI').value) || 45) * 1000;
    log(`Monitor iniciado ‚Äî scan cada ${iv/1000}s ‚Äî prefijo: ${$('cA').value.toUpperCase()}`, 'ops');
    ss('snd', 'Escaneando IVAO...');
    scan(); // immediate first scan
    monitorInterval = setInterval(scan, iv);
    $('btnMonitor').classList.add('on');
    $('monIco').innerHTML = '<span class="dot-live"></span>';
    $('monTxt').textContent = 'DETENER';
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  AOC FULLSCREEN MODE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let aocOpen = false;
let aocClockInterval = null;

function toggleAoc() {
  aocOpen = !aocOpen;
  $('aocOverlay').style.display = aocOpen ? 'flex' : 'none';
  if (aocOpen) {
    updateAoc();
    aocClockInterval = setInterval(() => { updateAocClock(); updateAoc(); }, 1000);
    updateAocClock();
    // Try native fullscreen
    try { document.documentElement.requestFullscreen?.(); } catch(e) {}
  } else {
    if (aocClockInterval) clearInterval(aocClockInterval);
    try { if (document.fullscreenElement) document.exitFullscreen?.(); } catch(e) {}
  }
}

function updateAocClock() {
  const now = new Date();
  $('aocClock').textContent = now.toISOString().substring(11, 19) + 'Z';
}

function updateAoc() {
  if (!aocOpen) return;
  const active = Object.values(flights).filter(f => !f.offlineSince);
  $('aocTotal').textContent = active.length;
  $('aocPre').textContent = active.filter(f => f.phase === 'PREFLIGHT').length;
  $('aocEnr').textContent = active.filter(f => f.phase === 'ENROUTE').length;
  $('aocDsc').textContent = active.filter(f => f.phase === 'DESCENT').length;
  $('aocLnd').textContent = active.filter(f => f.phase === 'LANDED').length;

  const rows = $('aocRows');
  const empty = $('aocEmpty');

  if (!active.length) {
    rows.innerHTML = '';
    empty.style.display = 'block';
    return;
  }
  empty.style.display = 'none';
  const order = { PREFLIGHT: 0, ENROUTE: 1, DESCENT: 2, LANDED: 3 };
  active.sort((a, b) => (order[a.phase] || 9) - (order[b.phase] || 9));

  rows.innerHTML = active.map(f => {
    const phCls = { PREFLIGHT: 'pre', ENROUTE: 'enr', DESCENT: 'dsc', LANDED: 'lnd' }[f.phase] || '';
    const phTxt = { PREFLIGHT: 'PREFLIGHT', ENROUTE: 'EN RUTA', DESCENT: 'DESCENSO', LANDED: 'LANDED' }[f.phase] || f.phase;
    const eet = f.estEnrouteMin > 0 ? `${Math.floor(f.estEnrouteMin / 60)}h${String(Math.round(f.estEnrouteMin % 60)).padStart(2, '0')}` : '-';
    const enr = f.enrouteStart ? `${Math.round((Date.now() - f.enrouteStart) / 60000)}m` : '-';
    const park = f.assignedParking || '-';
    const sbUser = roster[f.callsign];
    const sbTag = sbUser ? `<span style="color:#2e8cf0;font-size:.52rem;background:rgba(46,140,240,.12);padding:1px 5px;border-radius:3px;margin-left:4px;font-weight:700;border:1px solid rgba(46,140,240,.3)" title="SimBrief: ${esc(sbUser)}">SB</span>` : '';
    let msgBadges = '';
    for (const [key, status] of Object.entries(f.msgStatus)) {
      const label = key.replace(/_/g, ' ').substring(0, 10);
      msgBadges += `<span class="aoc-msg ${status}">${label}</span>`;
    }
    return `<tr>
      <td class="aoc-cs">${esc(f.callsign)} ${sbTag}</td>
      <td>${esc(f.aircraft)}</td>
      <td>${esc(f.dep)}</td>
      <td>${esc(f.arr)}</td>
      <td>FL${Math.round(f.alt / 100)}</td>
      <td>${f.gs}kt</td>
      <td>${Math.round(f.heading)}${'¬∞'}</td>
      <td><span class="aoc-ph ${phCls}">${phTxt}</span></td>
      <td>${eet}</td>
      <td>${enr}</td>
      <td>${park}</td>
      <td>${msgBadges || '-'}</td>
    </tr>`;
  }).join('');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ROSTER CHIPS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderRosterChips() {
  const el = $('rosterChips');
  const entries = Object.entries(roster);
  if (!entries.length) { el.style.display = 'none'; return; }
  el.style.display = 'flex';
  el.innerHTML = '<span style="color:var(--acc);margin-right:4px;font-weight:600">ROSTER:</span>' +
    entries.map(([cs, sb]) => {
      const isActive = !!flights[cs.toUpperCase()];
      const dot = isActive ? '<span style="color:var(--ok)">‚óè</span> ' : '<span style="color:var(--tx3)">‚óã</span> ';
      const sbBadge = sb ? ' <span style="color:var(--acc);background:var(--acc-g);padding:0 3px;border-radius:2px;font-size:.48rem">SB</span>' : '';
      return `<span style="background:var(--bg2);border:1px solid var(--brd);padding:2px 6px;border-radius:4px;${isActive?'border-color:var(--ok);':''}font-weight:500">${dot}${esc(cs)}${sbBadge}</span>`;
    }).join('');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  API KEY ENCRYPTION ‚Äî AES-256-GCM + PBKDF2 (Web Crypto API)
//  La API key NUNCA se almacena en claro. Flujo:
//  1. Usuario pega la key ‚Üí bot√≥n VALIDAR
//  2. Validaci√≥n contra /api/user de phpVMS
//  3. Si OK: cifrado AES-256-GCM con clave derivada del dispositivo
//  4. Blob cifrado en localStorage ‚Äî display enmascarado
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Derivar clave AES-256 desde huella del dispositivo + sal aleatoria
async function cryptoGetKey() {
  const fp = `${navigator.userAgent}|${screen.width}x${screen.height}|${navigator.language}|AN_OPS`;
  let salt = localStorage.getItem('an_ks');
  if (!salt) {
    const bytes = crypto.getRandomValues(new Uint8Array(16));
    salt = Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join('');
    localStorage.setItem('an_ks', salt);
  }
  const saltBytes = new Uint8Array(salt.match(/.{2}/g).map(h => parseInt(h, 16)));
  const km = await crypto.subtle.importKey('raw', new TextEncoder().encode(fp), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt: saltBytes, iterations: 120000, hash: 'SHA-256' },
    km,
    { name: 'AES-GCM', length: 256 },
    false, ['encrypt', 'decrypt']
  );
}

async function cryptoEncrypt(plaintext) {
  const key = await cryptoGetKey();
  const iv  = crypto.getRandomValues(new Uint8Array(12));
  const enc = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, new TextEncoder().encode(plaintext));
  const buf = new Uint8Array(12 + enc.byteLength);
  buf.set(iv); buf.set(new Uint8Array(enc), 12);
  return btoa(String.fromCharCode(...buf));
}

async function cryptoDecrypt(cipherB64) {
  try {
    const key  = await cryptoGetKey();
    const data = new Uint8Array(atob(cipherB64).split('').map(c => c.charCodeAt(0)));
    const dec  = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: data.slice(0,12) }, key, data.slice(12));
    return new TextDecoder().decode(dec);
  } catch { return null; }
}

// Recuperar API key descifrada (para uso interno en peticiones)
async function phpvmsGetKey() {
  const blob = localStorage.getItem('an_ak');
  if (!blob) return '';
  return (await cryptoDecrypt(blob)) || '';
}

// ‚îÄ‚îÄ UI de la API Key ‚îÄ‚îÄ
function apikeyOnInput() {
  const val = $('phpvmsKeyRaw')?.value.trim();
  const btn = $('apikeyValidateBtn');
  if (btn) btn.style.display = val.length > 8 ? '' : 'none';
}

function apikeyRenderState() {
  const display = $('apikeyDisplay');
  const wrap    = $('apikeyInputWrap');
  if (!display) return;
  const hasKey = !!localStorage.getItem('an_ak');
  if (hasKey) {
    display.innerHTML = `<div class="apikey-badge ok">üîí API Key cifrada (AES-256) <button class="apikey-btn clear" onclick="apikeyClear()" style="margin-left:6px;position:static;transform:none">‚úï Borrar</button></div>`;
    wrap.style.display = 'none';
  } else {
    display.innerHTML = `<div class="apikey-badge err" style="cursor:pointer" onclick="apikeyShowInput()">‚ö† Sin API Key ‚Äî haz click para configurar</div>`;
    wrap.style.display = 'none';
  }
}

function apikeyShowInput() {
  $('apikeyInputWrap').style.display = '';
  $('phpvmsKeyRaw').focus();
}

async function apikeyValidateAndSave() {
  const raw = $('phpvmsKeyRaw')?.value.trim();
  if (!raw) return;
  const btn = $('apikeyValidateBtn');
  btn.textContent = '‚è≥'; btn.disabled = true;
  phpvmsSetStatus('Validando API Key contra phpVMS‚Ä¶', null);
  try {
    const base = ($('phpvmsUrl')?.value.trim() || '').replace(/\/$/, '');
    const p    = $('cP')?.value.trim();
    const url  = p ? `${p}${encodeURIComponent(base + '/api/user')}` : `${base}/api/user`;
    const resp = await fetch(url, {
      headers: { 'X-API-Key': raw, 'Accept': 'application/json' },
      signal: AbortSignal.timeout(10000)
    });
    if (!resp.ok) throw new Error(`HTTP ${resp.status} ‚Äî Key inv√°lida o sin permisos`);
    const json = await resp.json();
    const name = json?.data?.name || json?.name || 'usuario';
    // Validaci√≥n OK ‚Üí cifrar y guardar
    const blob = await cryptoEncrypt(raw);
    localStorage.setItem('an_ak', blob);
    $('phpvmsKeyRaw').value = '';
    apikeyRenderState();
    phpvmsSetStatus(`‚úì API Key validada (${name}) y cifrada con AES-256`, true);
    if ($('phpvmsEn')?.checked) phpvmsStart();
  } catch(e) {
    phpvmsSetStatus(`‚úó Validaci√≥n fallida: ${e.message}`, false);
    btn.textContent = '‚úì VALIDAR'; btn.disabled = false;
    return;
  }
  btn.textContent = '‚úì VALIDAR'; btn.disabled = false;
}

function apikeyClear() {
  if (!confirm('¬øBorrar la API Key guardada?')) return;
  localStorage.removeItem('an_ak');
  apikeyRenderState();
  phpvmsSetStatus('API Key eliminada', null);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FSUIPC WEBSOCKET MODULE ‚Äî OPS Center
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let fsuipcWs = null, fsuipcConnected = false, fsuipcReady = false;
let fsuipcData = null, fsuipcRetryTimer = null, fsuipcRetryCount = 0, fsuipcPollTimer = null;
const FSUIPC_MAX_RETRY = 8, FSUIPC_RETRY_DELAY = 15000, FSUIPC_GROUP = 'AN_OPS_DATA';
const FSUIPC_OFFSETS = [
  { name:'lat',       address:'0x0560', type:'DBL',    size:8 },
  { name:'lon',       address:'0x0568', type:'DBL',    size:8 },
  { name:'altMeters', address:'0x0574', type:'INT64',  size:8 },
  { name:'gs',        address:'0x02B8', type:'UINT32', size:4 },
  { name:'hdg',       address:'0x0580', type:'UINT32', size:4 },
  { name:'vs',        address:'0x030C', type:'INT32',  size:4 },
  { name:'onGround',  address:'0x0366', type:'INT16',  size:2 },
  { name:'squawk',    address:'0x0354', type:'UINT16', size:2 },
];

function fsuipcSetStatus(msg, ok) {
  const el = $('fsuipcStatus'); if (!el) return;
  el.textContent = msg;
  el.style.color = ok === true ? '#34d399' : ok === false ? 'var(--wrn,#fbbf24)' : 'var(--tx3)';
}
function fsuipcUpdateBadge(state) {
  const b = $('fsuipcBadge'); if (!b) return;
  b.className = `fsuipc-badge src-${state}`;
  b.innerHTML = `<span class="fd"></span>${state === 'fsuipc' ? 'SIM' : state === 'connecting' ? 'SIM‚Ä¶' : 'IVAO'}`;
  b.title = state === 'fsuipc' ? 'Fuente: FSUIPC (simulador local)' : state === 'connecting' ? 'FSUIPC: conectando‚Ä¶' : 'Fuente: IVAO Whazzup';
}
function fsuipcNormalize(r) {
  const gsKts = Math.round((r.gs||0)/65536*1.94384);
  const hdgDeg = Math.round(((r.hdg||0)/65536)*360)%360;
  const altFt  = Math.round((r.altMeters||0)*3.28084);
  const vsFpm  = Math.round((r.vs||0)/256);
  const sq = r.squawk ? `${(r.squawk>>12)&0xF}${(r.squawk>>8)&0xF}${(r.squawk>>4)&0xF}${r.squawk&0xF}` : '0000';
  return { lat:r.lat||0, lon:r.lon||0, altitude:altFt, groundSpeed:gsKts, heading:hdgDeg, verticalSpeed:vsFpm, onGround:r.onGround===1||r.onGround===true, squawk:sq, ts:Date.now() };
}
function fsuipcRegisterGroup() {
  if (!fsuipcWs || fsuipcWs.readyState !== WebSocket.OPEN) return;
  const pollMs = Math.max(200, parseInt($('fsuipcPoll')?.value)||500);
  fsuipcWs.send(JSON.stringify({ command:'groups.add', parameters:[{ name:FSUIPC_GROUP, pollInterval:pollMs, offsets:FSUIPC_OFFSETS }] }));
}
function fsuipcHandleMessage(evt) {
  let msg; try { msg = JSON.parse(evt.data); } catch { return; }
  if (msg.command === FSUIPC_GROUP && msg.data) {
    fsuipcReady = true; fsuipcData = fsuipcNormalize(msg.data);
    fsuipcUpdateBadge('fsuipc');
    fsuipcSetStatus(`‚úì Sim: Alt${fsuipcData.altitude}ft GS${fsuipcData.groundSpeed}kt`, true);
  }
  if (msg.success === true) { fsuipcReady = true; fsuipcSetStatus('‚úì Grupo registrado', true); }
  if (msg.error) fsuipcSetStatus(`‚ö† ${msg.error}`, false);
}
function fsuipcScheduleRetry() {
  if (fsuipcRetryCount >= FSUIPC_MAX_RETRY) { fsuipcSetStatus(`‚úó Sin conexi√≥n tras ${FSUIPC_MAX_RETRY} intentos`, false); fsuipcUpdateBadge('ivao'); return; }
  fsuipcRetryCount++;
  clearTimeout(fsuipcRetryTimer);
  fsuipcSetStatus(`Reintento ${fsuipcRetryCount}/${FSUIPC_MAX_RETRY} en ${FSUIPC_RETRY_DELAY/1000}s‚Ä¶`, null);
  fsuipcRetryTimer = setTimeout(() => { if ($('fsuipcEn')?.checked) fsuipcConnect(); }, FSUIPC_RETRY_DELAY);
}
function fsuipcDisconnect(resetData=true) {
  clearTimeout(fsuipcRetryTimer); clearInterval(fsuipcPollTimer); fsuipcRetryCount=0;
  if (fsuipcWs) { fsuipcWs.onclose=null; fsuipcWs.onerror=null; if(fsuipcWs.readyState<2) fsuipcWs.close(1000,'User'); fsuipcWs=null; }
  fsuipcConnected=false; fsuipcReady=false; if(resetData) fsuipcData=null;
}
function fsuipcConnect() {
  if (fsuipcWs?.readyState===WebSocket.OPEN) return;
  fsuipcDisconnect(false);
  const url = $('fsuipcUrl')?.value.trim() || 'ws://127.0.0.1:2048';
  fsuipcUpdateBadge('connecting'); fsuipcSetStatus(`Conectando a ${url}‚Ä¶`, null);
  try { fsuipcWs = new WebSocket(url); } catch(e) { fsuipcSetStatus(`‚úó URL inv√°lida: ${e.message}`,false); fsuipcUpdateBadge('ivao'); return; }
  const timeout = setTimeout(() => { if(fsuipcWs?.readyState!==WebSocket.OPEN){fsuipcWs.close();fsuipcSetStatus('‚úó Timeout ‚Äî ¬øFSUIPC WS activo?',false);fsuipcUpdateBadge('ivao');fsuipcScheduleRetry();} }, 8000);
  fsuipcWs.addEventListener('open', () => {
    clearTimeout(timeout); fsuipcConnected=true; fsuipcRetryCount=0;
    fsuipcSetStatus('‚úì Conectado ‚Äî registrando offsets‚Ä¶', true); fsuipcRegisterGroup();
    const ms = Math.max(200, parseInt($('fsuipcPoll')?.value)||500);
    fsuipcPollTimer = setInterval(() => { if(fsuipcWs?.readyState===WebSocket.OPEN) fsuipcWs.send(JSON.stringify({command:'groups.read',name:FSUIPC_GROUP})); }, ms);
  });
  fsuipcWs.addEventListener('message', fsuipcHandleMessage);
  fsuipcWs.addEventListener('close', (e) => { clearTimeout(timeout); clearInterval(fsuipcPollTimer); fsuipcConnected=false; fsuipcReady=false; if($('fsuipcEn')?.checked){fsuipcUpdateBadge('connecting');fsuipcScheduleRetry();}else{fsuipcUpdateBadge('ivao');fsuipcData=null;fsuipcSetStatus('Desconectado',null);} });
  fsuipcWs.addEventListener('error', () => { clearTimeout(timeout); });
}
function fsuipcOnToggle() {
  const en = $('fsuipcEn').checked;
  $('fsuipcCfgFields').classList.toggle('active', en);
  if (en) { fsuipcRetryCount=0; fsuipcConnect(); } else { fsuipcDisconnect(true); fsuipcUpdateBadge('ivao'); fsuipcSetStatus('Desactivado',null); }
  saveCfg();
}
function fsuipcGetData(maxAgeMs=5000) {
  if (!fsuipcConnected||!fsuipcReady||!fsuipcData) return null;
  if (Date.now()-fsuipcData.ts>maxAgeMs) return null;
  return fsuipcData;
}
function fsuipcInjectIntoFlight(flt) {
  const csLocal = $('fsuipcCs')?.value.trim().toUpperCase();
  if (!csLocal || flt.callsign !== csLocal) return false;
  const sim = fsuipcGetData(); if (!sim) return false;
  flt.alt=sim.altitude; flt.gs=sim.groundSpeed; flt.heading=sim.heading;
  flt.lat=sim.lat; flt.lng=sim.lon; flt.onGround=sim.onGround; flt.srcSim=true;
  return true;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  phpVMS INTEGRATION MODULE ‚Äî OPS Center
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let phpvmsInterval=null, phpvmsPirepCache={}, phpvmsActive={}, phpvmsScanCount=0;
const PHPVMS_CACHE_TTL = 300000;

function phpvmsSetStatus(msg, ok) {
  const el = $('phpvmsStatus'); if (!el) return;
  el.textContent = msg;
  el.style.color = ok===true ? '#a78bfa' : ok===false ? 'var(--wrn,#fbbf24)' : 'var(--tx3)';
}
function phpvmsProxy(url) { const p=$('cP')?.value.trim(); return p?`${p}${encodeURIComponent(url)}`:url; }
function phpvmsCallsign(pirep) {
  const prefix = pirep?.airline?.icao||pirep?.airline_icao||'';
  const num = String(pirep?.flight_number||'').padStart(3,'0');
  if (!prefix||!num||num==='000') return null;
  return `${prefix}${num}`.toUpperCase();
}
async function phpvmsFetchGeojson() {
  const base = ($('phpvmsUrl')?.value.trim()||'').replace(/\/$/,'');
  const resp = await fetch(phpvmsProxy(`${base}/api/acars/geojson?_t=${Date.now()}`), { signal:AbortSignal.timeout(15000), headers:{'Cache-Control':'no-cache'} });
  if (!resp.ok) throw new Error(`GeoJSON HTTP ${resp.status}`);
  const json = await resp.json();
  return json?.data?.features||json?.features||[];
}
async function phpvmsFetchPirep(pirepId) {
  const cached = phpvmsPirepCache[pirepId];
  if (cached && Date.now()-cached.cachedAt<PHPVMS_CACHE_TTL) return cached;
  const base = ($('phpvmsUrl')?.value.trim()||'').replace(/\/$/,'');
  const key  = await phpvmsGetKey();
  const headers = { 'Accept':'application/json','Cache-Control':'no-cache' };
  if (key) headers['X-API-Key'] = key;
  try {
    const resp = await fetch(phpvmsProxy(`${base}/api/pireps/${pirepId}`), { signal:AbortSignal.timeout(10000), headers });
    if (!resp.ok) return null;
    const data = (await resp.json())?.data;
    if (!data?.id) return null;
    phpvmsPirepCache[pirepId] = { ...data, cachedAt:Date.now() };
    return phpvmsPirepCache[pirepId];
  } catch(e) { return null; }
}
async function phpvmsScan() {
  if (!$('phpvmsEn')?.checked) return;
  phpvmsScanCount++;
  try {
    const features = await phpvmsFetchGeojson();
    phpvmsSetStatus(`Scan #${phpvmsScanCount}: ${features.length} vuelo(s) en phpVMS`, true);
    const activePids = new Set();
    for (const feat of features) {
      const props = feat.properties||{}, coords = feat.geometry?.coordinates||[];
      const pirepId = props.pirep_id; if (!pirepId) continue;
      activePids.add(pirepId);
      const lon=parseFloat(coords[0])||0, lat=parseFloat(coords[1])||0;
      const alt=parseFloat(coords[2]??props.alt)||0, hdg=parseFloat(props.heading)||0;
      const pirep = await phpvmsFetchPirep(pirepId);
      const cs = pirep ? phpvmsCallsign(pirep) : null; if (!cs) continue;
      phpvmsActive[cs] = { pirepId, callsign:cs, lat, lon, alt, heading:hdg,
        dep:pirep?.dpt_airport_id||'????', arr:pirep?.arr_airport_id||'????',
        aircraft:pirep?.aircraft?.icao||'????',
        registration:pirep?.aircraft?.registration||'',
        acName:pirep?.aircraft?.name||'',
        route:pirep?.route||'', planFL:pirep?.level||0,
        plannedDistNmi:pirep?.planned_distance?.nmi||0,
        progressPct: (pirep?.planned_distance?.nmi||0) > 0
          ? Math.min(100, Math.round((pirep?.distance?.nmi||0) / pirep.planned_distance.nmi * 100)) : 0,
        phpvmsPhase:pirep?.phase||'',
        arrLat:pirep?.arr_airport?.lat||null, arrLon:pirep?.arr_airport?.lon||null,
        pilotName:pirep?.user?.name||'', pilotIdent:pirep?.user?.ident||'',
        gs:0, onGround:alt<100, srcPhpvms:true, updatedAt:Date.now() };
    }
    // Purgar inactivos
    for (const cs of Object.keys(phpvmsActive)) {
      if (!activePids.has(phpvmsActive[cs]?.pirepId)) delete phpvmsActive[cs];
    }
    const now = Date.now();
    for (const pid of Object.keys(phpvmsPirepCache)) {
      if (now-phpvmsPirepCache[pid].cachedAt>PHPVMS_CACHE_TTL*2) delete phpvmsPirepCache[pid];
    }
    phpvmsMergeWithFlights();
  } catch(e) { phpvmsSetStatus(`‚úó ${e.message}`, false); }
}
function phpvmsMergeWithFlights() {
  const prefix = ($('cA')?.value.trim().toUpperCase())||'NBV';
  for (const [cs, pv] of Object.entries(phpvmsActive)) {
    if (!cs.startsWith(prefix)) continue;
    if (flights[cs] && !flights[cs].offlineSince) {
      // Enriquecer datos IVAO con phpVMS (solo si faltan)
      const f = flights[cs];
      if (!f.pilotName   && pv.pilotName)   f.pilotName   = pv.pilotName;
      if (!f.pilotIdent  && pv.pilotIdent)  f.pilotIdent  = pv.pilotIdent;
      if (!f.registration&& pv.registration)f.registration= pv.registration;
      if (!f.acName      && pv.acName)      f.acName      = pv.acName;
      if (!f.phpvmsRoute && pv.route)       f.phpvmsRoute = pv.route;
      if (!f.planFL      && pv.planFL)      f.planFL      = pv.planFL;
      if (pv.progressPct)                   f.progressPct = pv.progressPct;
      if (pv.arrLat!=null)                  f.arrLat      = pv.arrLat;
      if (pv.arrLon!=null)                  f.arrLon      = pv.arrLon;
      if (pv.phpvmsPhase)                   f._phpvmsPhase= pv.phpvmsPhase;
      if (f.dep==='????' && pv.dep!=='????') f.dep = pv.dep;
      if (f.arr==='????' && pv.arr!=='????') f.arr = pv.arr;
      continue;
    }
    // Piloto no en IVAO ‚Äî a√±adir desde phpVMS como fuente alternativa
    const synPilot = { lastTrack:{ altitude:pv.alt, groundSpeed:pv.gs||0, onGround:pv.onGround,
      latitude:pv.lat, longitude:pv.lon, state:'', arrivalDistance:null }, _phpvmsPhase:pv.phpvmsPhase };
    const simPhase = detectPhase(synPilot, flights[cs]||null);
    const prevFlt  = flights[cs];
    if (!prevFlt) {
      log(`‚úà ${cs} [phpVMS]: ${pv.dep}‚Üí${pv.arr} | ${pv.pilotName}`, 'ops');
      discordNotifyDetected({ callsign:cs, dep:pv.dep, arr:pv.arr, aircraft:pv.aircraft, srcPhpvms:true, pilotName:pv.pilotName });
    } else if (prevFlt.phase !== simPhase) {
      log(`${cs}: ${prevFlt.phase} ‚Üí ${simPhase}`, 'ops');
      discordNotifyPhase({ callsign:cs, dep:pv.dep, arr:pv.arr, alt:pv.alt, gs:0 }, prevFlt.phase, simPhase);
    }
    flights[cs] = { callsign:cs, phase:simPhase, dep:pv.dep, arr:pv.arr, aircraft:pv.aircraft,
      registration:pv.registration, acName:pv.acName, phpvmsRoute:pv.route,
      planFL:pv.planFL, progressPct:pv.progressPct,
      alt:pv.alt, gs:0, heading:pv.heading, lat:pv.lat, lng:pv.lon, onGround:pv.onGround,
      pilotName:pv.pilotName, pilotIdent:pv.pilotIdent,
      arrLat:pv.arrLat, arrLon:pv.arrLon, _phpvmsPhase:pv.phpvmsPhase,
      pirepId:pv.pirepId, srcPhpvms:true, srcSim:false,
      firstSeen:prevFlt?.firstSeen||Date.now(), offlineSince:null,
      sent:prevFlt?.sent||{ preflight:false, enroute:false, descent:false, landed:false },
      simbrief:prevFlt?.simbrief||null };
  }
}
function phpvmsOnToggle() {
  const en = $('phpvmsEn').checked;
  $('phpvmsCfgFields').classList.toggle('active', en);
  if (en) phpvmsStart(); else { clearInterval(phpvmsInterval); phpvmsInterval=null; phpvmsSetStatus('Desactivado',null); }
  saveCfg();
}
function phpvmsStart() {
  clearInterval(phpvmsInterval);
  phpvmsActive={}; phpvmsPirepCache={}; phpvmsScanCount=0;
  phpvmsScan();
  const ms = Math.max(15, parseInt($('phpvmsPoll')?.value)||30)*1000;
  phpvmsInterval = setInterval(phpvmsScan, ms);
  phpvmsSetStatus('Activado ‚Äî escaneando‚Ä¶', null);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DISCORD WEBHOOK MODULE ‚Äî OPS Center
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const discordQueue=[]; let discordSending=false, discordLastSent=0;
const DC_MIN_GAP=420;
const DC_COLORS={ PREFLIGHT:0xFBBF24, ENROUTE:0x60A5FA, DESCENT:0xA78BFA, LANDED:0x34D399, DETECTED:0x2E8CF0, TELEX:0x6EE7B7, ALERT:0xF87171, TEST:0x7289DA };

function discordSetStatus(msg, ok) {
  const el=$('discordStatus'); if(!el) return;
  el.textContent=msg;
  el.style.color=ok===true?'#7289da':ok===false?'var(--wrn,#fbbf24)':'var(--tx3)';
}
function discordEnabled()  { return $('discordEn')?.checked && !!$('discordUrl')?.value.trim(); }
function discordEvFlight() { return discordEnabled() && ($('dcEvFlight')?.checked!==false); }
function discordEvPhase()  { return discordEnabled() && ($('dcEvPhase')?.checked!==false); }
function discordEvTelex()  { return discordEnabled() && ($('dcEvTelex')?.checked!==false); }
function discordEvAlert()  { return discordEnabled() && ($('dcEvAlert')?.checked!==false); }
function dTrunc(s,max=1024){s=String(s||'');return s.length>max?s.slice(0,max-3)+'‚Ä¶':s;}
function discordOnToggle() {
  const en=$('discordEn').checked;
  $('discordCfgFields').classList.toggle('active',en);
  discordSetStatus(en?'Webhook activo':'Desactivado', en?true:null);
  saveCfg();
}
function discordEmbed({color,title,description,fields=[],footer=''}) {
  return { embeds:[{ color, title, description:description||undefined,
    fields:fields.map(f=>({name:f.name,value:String(f.value||'‚Äî'),inline:f.inline!==false})),
    footer:{text:footer||`AirNubeiro OPS Center ‚Ä¢ ${new Date().toUTCString().slice(5,22)} UTC`},
    timestamp:new Date().toISOString() }] };
}
function discordEnqueue(payload) { if(!discordEnabled()) return; discordQueue.push(payload); discordFlush(); }
async function discordFlush() {
  if (discordSending||!discordQueue.length) return; discordSending=true;
  while (discordQueue.length) {
    const payload=discordQueue.shift();
    const gap=Date.now()-discordLastSent; if(gap<DC_MIN_GAP) await new Promise(r=>setTimeout(r,DC_MIN_GAP-gap));
    try {
      const url=$('discordUrl')?.value.trim(); if(!url) break;
      const resp=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload),signal:AbortSignal.timeout(8000)});
      discordLastSent=Date.now();
      if(!resp.ok) {
        if(resp.status===429){const ra=parseFloat(resp.headers.get('Retry-After')||'2')*1000;discordQueue.unshift(payload);await new Promise(r=>setTimeout(r,ra+200));}
        else discordSetStatus(`‚ö† HTTP ${resp.status}`,false);
      } else discordSetStatus(`‚úì √öltimo env√≠o: ${new Date().toISOString().slice(11,19)}Z`,true);
    } catch(e){discordSetStatus(`‚úó ${e.message}`,false);}
  }
  discordSending=false;
}
function discordNotifyDetected(flt) {
  if (!discordEvFlight()) return;
  discordEnqueue(discordEmbed({ color:DC_COLORS.DETECTED, title:`‚úà Vuelo detectado ‚Äî ${flt.callsign}`,
    fields:[{name:'Callsign',value:flt.callsign,inline:true},{name:'Ruta',value:`${flt.dep}‚Üí${flt.arr}`,inline:true},
      {name:'Aeronave',value:flt.aircraft||'‚Äî',inline:true},{name:'Fuente',value:flt.srcSim?'SIM':flt.srcPhpvms?'phpVMS':'IVAO',inline:true},
      {name:'Piloto',value:flt.pilotName||'‚Äî',inline:true}] }));
}
function discordNotifyPhase(flt, oldPhase, newPhase) {
  if (!discordEvPhase()) return;
  const labels={PREFLIGHT:'üü° PREFLIGHT',ENROUTE:'üîµ ENROUTE',DESCENT:'üü£ DESCENT',LANDED:'üü¢ LANDED'};
  discordEnqueue(discordEmbed({ color:DC_COLORS[newPhase]||DC_COLORS.DETECTED,
    title:`${labels[newPhase]||newPhase} ‚Äî ${flt.callsign}`,
    fields:[{name:'Callsign',value:flt.callsign,inline:true},{name:'Ruta',value:`${flt.dep}‚Üí${flt.arr}`,inline:true},
      {name:'Transici√≥n',value:`${oldPhase} ‚Üí **${newPhase}**`,inline:true},
      {name:'FL',value:`FL${Math.round((flt.alt||0)/100)}`,inline:true},{name:'GS',value:`${flt.gs||0}kt`,inline:true}] }));
}
function discordNotifyTelex(to, body, auto=false) {
  if (!discordEvTelex()) return;
  const from=$('cS')?.value.toUpperCase()||'OPS';
  discordEnqueue(discordEmbed({ color:DC_COLORS.TELEX, title:`üì® TELEX ${auto?'[AUTO]':'[MANUAL]'} ‚Üí ${to}`,
    fields:[{name:'De',value:from,inline:true},{name:'Para',value:to,inline:true},
      {name:'Tipo',value:auto?'Auto-OPS':'Manual',inline:true},{name:'Mensaje',value:dTrunc(body,512),inline:false}] }));
}
function discordNotifyAlert(callsign, alertType, detail) {
  if (!discordEvAlert()) return;
  discordEnqueue(discordEmbed({ color:DC_COLORS.ALERT, title:`üö® Alerta OPS ‚Äî ${alertType}`,
    fields:[{name:'Vuelo',value:callsign||'‚Äî',inline:true},{name:'Tipo',value:alertType,inline:true},
      {name:'Detalle',value:dTrunc(detail,512),inline:false}] }));
}
async function discordTest() {
  if (!$('discordUrl')?.value.trim()) { discordSetStatus('‚úó Introduce la URL del webhook',false); return; }
  discordEnqueue(discordEmbed({ color:DC_COLORS.TEST, title:'‚úÖ AirNubeiro OPS Center ‚Äî Test de conexi√≥n',
    description:'Webhook correctamente configurado.',
    fields:[{name:'App',value:'OPS Center v4.2',inline:true},{name:'Estaci√≥n',value:$('cS')?.value||'‚Äî',inline:true},
      {name:'Hora',value:`${new Date().toISOString().slice(11,19)}Z`,inline:true}] }));
}

// ‚îÄ‚îÄ Colores ACARS exactos por tipo de mensaje (r√©plica de variables CSS) ‚îÄ‚îÄ
const DC_MSG_COLORS = {
  out:   0x2E8CF0,  // --acc  ‚Äî TELEX enviado
  in:    0x60A5FA,  // --inf  ‚Äî TELEX recibido
  cpm:   0xA78BFA,  // --cpdlc‚Äî CPDLC
  logon: 0x34D399,  // --ok   ‚Äî LOGON
  erm:   0xF87171,  // --err  ‚Äî Error
};

// Notificaci√≥n Discord para mensajes TELEX enviados por OPS Center (auto o manual)
function discordNotifyOpsMsg({ type = 'TELEX', to, body, auto = true, ok = true }) {
  if (!discordEvTelex()) return;
  const color = ok ? DC_MSG_COLORS.out : DC_MSG_COLORS.erm;
  const from  = $('cS')?.value.toUpperCase() || 'OPS';
  discordEnqueue(discordEmbed({
    color,
    title: `üì§ ${type} ${auto ? '[AUTO]' : '[MANUAL]'} ‚Üí ${to}`,
    fields: [
      { name: 'De',      value: from, inline: true },
      { name: 'Para',    value: to,   inline: true },
      { name: 'Tipo',    value: auto ? 'Auto-OPS' : 'Manual', inline: true },
      { name: 'Mensaje', value: dTrunc(body, 512), inline: false },
    ],
    footer: `AirNubeiro OPS Center v4.2 ‚Ä¢ ${new Date().toISOString().slice(11,19)}Z`,
  }));
}

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
loadCfg(); renderRoster(); loadSentRegistry(); renderRosterChips();
if (!$('cL').value.trim()) { $('cfgP').classList.add('v'); $('rosterP').classList.add('v'); $('btnCfg').classList.add('on'); }
else ss('ok', `OPS ${$('cS').value||'???'} ‚Äî listo`);

// PWA
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(e => {});
}
</script>
</body>
</html>
