<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ACARS Dispatch ‚Äî AirNubeiro</title>
<!-- PWA -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0062B8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="ACARS DSP">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg0: #050a14; --bg1: #0a1222; --bg2: #0f1830; --bg3: #071018;
    --brd: #162240; --brd-f: #2e8cf0;
    --acc: #2e8cf0; --acc-d: #1a6bc4; --acc-g: rgba(46,140,240,0.10);
    --tx1: #e2eaf4; --tx2: #7d8faa; --tx3: #3e5170;
    --ok: #34d399; --err: #f87171; --wrn: #fbbf24; --inf: #60a5fa; --cpdlc: #a78bfa;
    --mono: 'JetBrains Mono','Courier New',monospace;
    --sans: 'IBM Plex Sans',-apple-system,sans-serif;
  }
  html { font-size: 15px; }
  body { font-family: var(--sans); background: var(--bg0); color: var(--tx1); min-height: 100dvh; -webkit-font-smoothing: antialiased; }

  /* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
  .app { max-width: 560px; margin: 0 auto; padding: 12px; min-height: 100dvh; display: flex; flex-direction: column; gap: 10px; }

  /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
  .hdr { display: flex; align-items: center; justify-content: space-between; padding: 10px 0 8px; border-bottom: 1px solid var(--brd); }
  .hdr-l { display: flex; align-items: center; gap: 10px; }
  .hdr-ico { width: 34px; height: 34px; background: var(--acc); border-radius: 6px; display: flex; align-items: center; justify-content: center; font: 700 13px/1 var(--mono); color: var(--bg0); letter-spacing: -0.5px; }
  .hdr-t h1 { font: 600 1rem/1.2 var(--mono); color: var(--tx1); letter-spacing: -0.3px; }
  .hdr-t .sub { font: 400 0.62rem var(--mono); color: var(--tx3); letter-spacing: 0.5px; }
  .hdr-r { display: flex; gap: 5px; align-items: center; }

  .ib { background: 0; border: 1px solid var(--brd); color: var(--tx2); width: 33px; height: 33px; border-radius: 6px; cursor: pointer; font-size: 0.82rem; display: flex; align-items: center; justify-content: center; transition: .15s; position: relative; }
  .ib:hover { border-color: var(--acc-d); color: var(--acc); }
  .ib.on { border-color: var(--acc); color: var(--acc); background: var(--acc-g); }

  .bdg { position: absolute; top: -4px; right: -4px; background: var(--err); color: #fff; font: 700 0.52rem var(--mono); min-width: 15px; height: 15px; border-radius: 8px; display: none; align-items: center; justify-content: center; padding: 0 3px; }
  .bdg.v { display: flex; }

  /* Auto-poll indicator */
  .poll-on { border-color: var(--ok) !important; color: var(--ok) !important; }
  .poll-on .dot-pulse { width: 6px; height: 6px; background: var(--ok); border-radius: 50%; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0%,100%{ opacity:1 } 50%{ opacity:.3 } }

  /* ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ */
  .tabs { display: flex; gap: 2px; background: var(--bg1); border-radius: 8px; padding: 3px; border: 1px solid var(--brd); }
  .tab { flex: 1; padding: 7px 4px; background: 0; border: 0; color: var(--tx3); font: 600 0.68rem/1 var(--mono); letter-spacing: .7px; text-transform: uppercase; cursor: pointer; border-radius: 6px; transition: .15s; text-align: center; white-space: nowrap; }
  .tab:hover { color: var(--tx2); }
  .tab.on { background: var(--bg2); color: var(--acc); box-shadow: 0 1px 3px rgba(0,0,0,.3); }
  .tab .tb { font-size: 0.55rem; background: var(--err); color: #fff; border-radius: 4px; padding: 0 3px; margin-left: 3px; vertical-align: middle; display: none; }
  .tab .tb.v { display: inline; }

  /* ‚îÄ‚îÄ Panel ‚îÄ‚îÄ */
  .pnl { display: none; flex-direction: column; gap: 10px; }
  .pnl.on { display: flex; }

  /* ‚îÄ‚îÄ Config ‚îÄ‚îÄ */
  .cfg { background: var(--bg2); border: 1px solid var(--brd); border-radius: 8px; padding: 14px; display: none; animation: sd .15s ease-out; }
  .cfg.v { display: block; }
  @keyframes sd { from { opacity:0; transform:translateY(-6px) } to { opacity:1; transform:translateY(0) } }
  .cfg h3 { font: 600 0.68rem var(--mono); text-transform: uppercase; letter-spacing: 1.5px; color: var(--tx3); margin-bottom: 10px; }
  .cfg-g { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .cfg-g .f.fw { grid-column: 1/-1; }

  /* ‚îÄ‚îÄ Fields ‚îÄ‚îÄ */
  .f label { display: block; font: 600 0.66rem var(--mono); color: var(--tx2); margin-bottom: 3px; letter-spacing: .3px; }
  .f input, .f textarea, .f select { width: 100%; background: var(--bg3); border: 1px solid var(--brd); border-radius: 6px; padding: 8px 10px; color: var(--tx1); font: 400 0.84rem var(--mono); transition: .15s; outline: 0; }
  .f input:focus, .f textarea:focus, .f select:focus { border-color: var(--brd-f); box-shadow: 0 0 0 2px var(--acc-g); }
  .f input::placeholder, .f textarea::placeholder { color: var(--tx3); }
  .f input.uc { text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }
  .f textarea { resize: vertical; min-height: 70px; max-height: 200px; line-height: 1.5; }
  .f select { cursor: pointer; }

  .chc { text-align: right; font: 400 0.62rem var(--mono); color: var(--tx3); margin-top: 2px; }
  .chc.w { color: var(--wrn); } .chc.o { color: var(--err); }

  /* ‚îÄ‚îÄ Card ‚îÄ‚îÄ */
  .cd { background: var(--bg2); border: 1px solid var(--brd); border-radius: 10px; padding: 14px; }
  .ct { font: 600 0.68rem var(--mono); text-transform: uppercase; letter-spacing: 1.5px; color: var(--acc-d); margin-bottom: 10px; display: flex; align-items: center; gap: 6px; }
  .ct::before { content:''; width: 6px; height: 6px; background: var(--acc); border-radius: 50%; }
  .ct.cp { color: var(--cpdlc); } .ct.cp::before { background: var(--cpdlc); }
  .ct.inf { color: var(--inf); } .ct.inf::before { background: var(--inf); }

  /* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */
  .bp { width: 100%; margin-top: 10px; padding: 12px; background: linear-gradient(135deg, #0062B8 0%, #2e8cf0 100%); color: #fff; border: 0; border-radius: 8px; font: 700 0.84rem var(--mono); letter-spacing: 1px; text-transform: uppercase; cursor: pointer; transition: .15s; }
  .bp:hover:not(:disabled) { background: linear-gradient(135deg, #1a6bc4 0%, #4aa0f5 100%); transform: translateY(-1px); box-shadow: 0 4px 16px rgba(46,140,240,.25); }
  .bp:active:not(:disabled) { transform: translateY(0); }
  .bp:disabled { opacity: .4; cursor: not-allowed; }
  .bp.snd { background: var(--acc-d); pointer-events: none; }
  .bp.ok { background: var(--ok); } .bp.er { background: var(--err); }
  .bp.cpc { background: var(--cpdlc); } .bp.cpc:hover:not(:disabled) { background: #b99ef5; box-shadow: 0 4px 16px rgba(167,139,250,.25); }
  .bp.ifc { background: var(--inf); } .bp.ifc:hover:not(:disabled) { background: #7db5fc; box-shadow: 0 4px 16px rgba(96,165,250,.25); }

  .bs { padding: 8px 14px; background: var(--bg3); color: var(--tx2); border: 1px solid var(--brd); border-radius: 6px; font: 600 0.76rem var(--mono); cursor: pointer; transition: .15s; }
  .bs:hover { border-color: var(--acc-d); color: var(--acc); }

  .r2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

  /* ‚îÄ‚îÄ Templates / Presets ‚îÄ‚îÄ */
  .tpls { display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 8px; }
  .tp { background: var(--bg3); border: 1px solid var(--brd); color: var(--tx2); padding: 4px 8px; border-radius: 5px; font: 400 0.65rem var(--mono); cursor: pointer; transition: .12s; white-space: nowrap; }
  .tp:hover { border-color: var(--acc-d); color: var(--acc); background: var(--acc-g); }
  .tp.cp { background: rgba(167,139,250,.06); border-color: rgba(167,139,250,.2); color: var(--cpdlc); }
  .tp.cp:hover { background: rgba(167,139,250,.12); border-color: var(--cpdlc); }

  /* ‚îÄ‚îÄ Status Bar ‚îÄ‚îÄ */
  .sb { display: flex; align-items: center; gap: 8px; padding: 7px 12px; border-radius: 6px; font: 400 0.72rem var(--mono); background: var(--bg1); border: 1px solid var(--brd); min-height: 33px; transition: .2s; }
  .sb .d { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
  .sb.idle .d { background: var(--tx3); }
  .sb.ok .d { background: var(--ok); box-shadow: 0 0 6px var(--ok); }
  .sb.err .d { background: var(--err); box-shadow: 0 0 6px var(--err); }
  .sb.snd .d { background: var(--wrn); animation: pulse 1s infinite; }

  /* ‚îÄ‚îÄ Message List ‚îÄ‚îÄ */
  .ml { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 5px; max-height: 50vh; padding-right: 4px; }
  .ml::-webkit-scrollbar { width: 4px; } .ml::-webkit-scrollbar-track { background: 0; } .ml::-webkit-scrollbar-thumb { background: var(--brd); border-radius: 2px; }

  .me { background: var(--bg1); border: 1px solid var(--brd); border-radius: 6px; padding: 8px 10px; font-size: 0.73rem; animation: fi .2s ease-out; }
  .me.in { border-left: 3px solid var(--inf); } .me.out { border-left: 3px solid var(--acc); }
  .me.cpm { border-left: 3px solid var(--cpdlc); } .me.erm { border-left: 3px solid var(--err); }
  .me.logon { border-left: 3px solid var(--ok); background: rgba(52,211,153,.04); }
  @keyframes fi { from { opacity:0; transform:translateY(-3px) } to { opacity:1; transform:translateY(0) } }

  .mm { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px; }
  .mr { font: 600 0.74rem var(--mono); }
  .me.out .mr { color: var(--acc); } .me.in .mr { color: var(--inf); } .me.cpm .mr { color: var(--cpdlc); } .me.logon .mr { color: var(--ok); }
  .mt { font: 400 0.63rem var(--mono); color: var(--tx3); }

  .mb-t { font: 700 0.56rem var(--mono); letter-spacing: .8px; padding: 1px 5px; border-radius: 3px; text-transform: uppercase; }
  .b-tx { background: rgba(224,163,72,.12); color: var(--acc); }
  .b-cp { background: rgba(167,139,250,.12); color: var(--cpdlc); }
  .b-in { background: rgba(96,165,250,.12); color: var(--inf); }
  .b-sy { background: rgba(125,138,160,.12); color: var(--tx2); }
  .b-lo { background: rgba(52,211,153,.12); color: var(--ok); }

  .mb { color: var(--tx2); font: 400 0.71rem/1.4 var(--mono); word-break: break-word; white-space: pre-wrap; }
  .ms { margin-top: 2px; font: 400 0.61rem var(--mono); }
  .ms.ok { color: var(--ok); } .ms.er { color: var(--err); }

  .me-empty { text-align: center; color: var(--tx3); font: 400 0.76rem var(--mono); padding: 24px 0; }

  .lh { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
  .lh h3 { font: 600 0.66rem var(--mono); text-transform: uppercase; letter-spacing: 1.5px; color: var(--tx3); }
  .lh-btns { display: flex; gap: 6px; }
  .sm { background: 0; border: 0; color: var(--tx3); font: 400 0.65rem var(--mono); cursor: pointer; padding: 2px 5px; border-radius: 4px; transition: .15s; }
  .sm:hover { color: var(--err); }
  .sm.pl:hover { color: var(--inf); }

  /* ‚îÄ‚îÄ CPDLC Logon Actions ‚îÄ‚îÄ */
  .logon-actions { display: flex; gap: 6px; margin-top: 6px; }
  .logon-actions button { padding: 5px 12px; border: 0; border-radius: 5px; font: 600 0.68rem var(--mono); cursor: pointer; letter-spacing: .5px; transition: .12s; }
  .la-accept { background: var(--ok); color: var(--bg0); }
  .la-accept:hover { background: #4eeab0; }
  .la-standby { background: var(--wrn); color: var(--bg0); }
  .la-standby:hover { background: #fcd34d; }
  .la-reject { background: var(--err); color: #fff; }
  .la-reject:hover { background: #fca5a5; }

  /* ‚îÄ‚îÄ Connected stations list ‚îÄ‚îÄ */
  .conn-list { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 4px; }
  .conn-tag { background: rgba(52,211,153,.1); border: 1px solid rgba(52,211,153,.3); color: var(--ok); padding: 3px 8px; border-radius: 4px; font: 600 0.65rem var(--mono); display: flex; align-items: center; gap: 4px; }
  .conn-tag .cx { cursor: pointer; opacity: .6; font-size: 0.8rem; }
  .conn-tag .cx:hover { opacity: 1; }

  /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
  .ftr { text-align: center; padding: 10px 0 6px; border-top: 1px solid var(--brd); }
  .ftr .br { font: 600 0.66rem var(--mono); color: var(--acc); letter-spacing: .5px; }
  .ftr .lg { font: 400 0.56rem var(--mono); color: var(--tx3); margin-top: 2px; }

  /* ‚îÄ‚îÄ Help ‚îÄ‚îÄ */
  .hi { display: inline-flex; align-items: center; justify-content: center; width: 13px; height: 13px; border-radius: 50%; background: var(--brd); color: var(--tx3); font-size: .52rem; font-weight: 700; cursor: help; margin-left: 3px; position: relative; }
  .hi .tt { display: none; position: absolute; bottom: calc(100% + 5px); left: 50%; transform: translateX(-50%); background: var(--bg2); border: 1px solid var(--brd); border-radius: 6px; padding: 7px 9px; font: 400 .63rem/1.4 var(--sans); color: var(--tx2); width: 210px; z-index: 10; }
  .hi:hover .tt, .hi:focus .tt { display: block; }

  /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
  @media (max-width: 420px) {
    html { font-size: 14px; }
    .app { padding: 8px; }
    .cfg-g, .r2 { grid-template-columns: 1fr; }
  }

  /* ‚îÄ‚îÄ Dispatch ‚îÄ‚îÄ */
  .dsp-color { color: #f472b6; }
  .ct.dsp { color: #f472b6; } .ct.dsp::before { background: #f472b6; }
  .bp.dsp-btn { background: #f472b6; } .bp.dsp-btn:hover:not(:disabled) { background: #f9a8d4; box-shadow: 0 4px 16px rgba(244,114,182,.25); }
  .dsp-card { background: var(--bg1); border: 1px solid var(--brd); border-radius: 8px; padding: 10px 12px; border-left: 3px solid #f472b6; }
  .dsp-card h4 { font: 600 0.7rem var(--mono); color: #f472b6; letter-spacing: .5px; margin-bottom: 4px; display: flex; align-items: center; gap: 6px; }
  .dsp-card h4 .ico { font-size: 0.85rem; }
  .dsp-card pre { font: 400 0.68rem/1.5 var(--mono); color: var(--tx2); white-space: pre-wrap; word-break: break-word; margin: 4px 0 8px; max-height: 140px; overflow-y: auto; }
  .dsp-card pre::-webkit-scrollbar { width: 3px; } .dsp-card pre::-webkit-scrollbar-thumb { background: var(--brd); border-radius: 2px; }
  .dsp-send { padding: 5px 12px; background: rgba(244,114,182,.12); border: 1px solid rgba(244,114,182,.3); color: #f472b6; border-radius: 5px; font: 600 0.65rem var(--mono); cursor: pointer; transition: .12s; letter-spacing: .3px; }
  .dsp-send:hover { background: rgba(244,114,182,.22); border-color: #f472b6; }
  .dsp-send.sent { background: rgba(52,211,153,.1); border-color: rgba(52,211,153,.3); color: var(--ok); pointer-events: none; }
  .dsp-send.fail { background: rgba(248,113,113,.1); border-color: rgba(248,113,113,.3); color: var(--err); }
  .dsp-cards { display: flex; flex-direction: column; gap: 8px; }
  .dsp-summary { background: var(--bg2); border: 1px solid var(--brd); border-radius: 8px; padding: 12px; }
  .dsp-summary .row { display: flex; justify-content: space-between; font: 400 0.72rem var(--mono); color: var(--tx2); padding: 2px 0; }
  .dsp-summary .row .val { color: var(--tx1); font-weight: 600; }
  .dsp-summary .head { font: 600 0.66rem var(--mono); color: #f472b6; letter-spacing: 1px; text-transform: uppercase; margin-bottom: 5px; }
  .dsp-loading { text-align: center; padding: 20px; color: var(--tx3); font: 400 0.76rem var(--mono); }
  .dsp-loading .spin { display: inline-block; animation: spin 1s linear infinite; }
  @keyframes spin { from{transform:rotate(0)} to{transform:rotate(360deg)} }

  /* ‚îÄ‚îÄ OPS embedded ‚îÄ‚îÄ */
  /* ‚îÄ‚îÄ Discord Webhook ‚îÄ‚îÄ */
  .cfg-discord { margin-top: 8px; padding: 8px 10px; background: var(--bg3); border: 1px solid var(--brd); border-radius: 6px; }
  .cfg-discord-hdr { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; }
  .cfg-discord-ttl { font: 600 0.65rem var(--mono); color: #7289da; letter-spacing: .5px; }
  .discord-toggle { display: flex; align-items: center; gap: 6px; cursor: pointer; }
  .discord-toggle input[type=checkbox] { accent-color: #7289da; width: 13px; height: 13px; }
  .discord-events { display: grid; grid-template-columns: 1fr 1fr; gap: 3px 10px; margin-top: 4px; }
  .discord-events label { display: flex; align-items: center; gap: 5px; font: 500 0.62rem var(--mono); color: var(--tx2); cursor: pointer; }
  .discord-events input[type=checkbox] { accent-color: #7289da; width: 11px; height: 11px; }
  .discord-test-btn { margin-top: 6px; padding: 4px 10px; background: rgba(114,137,218,.15); border: 1px solid rgba(114,137,218,.35); color: #7289da; border-radius: 4px; font: 600 0.62rem var(--mono); cursor: pointer; transition: .15s; letter-spacing: .4px; }
  .discord-test-btn:hover { background: rgba(114,137,218,.25); }

  /* ‚îÄ‚îÄ API Key Encryption ‚îÄ‚îÄ */
  .apikey-wrap { position: relative; }
  .apikey-wrap input { padding-right: 74px; }
  .apikey-actions { position: absolute; right: 4px; top: 50%; transform: translateY(-50%); display: flex; gap: 3px; }
  .apikey-btn { padding: 2px 7px; border-radius: 3px; font: 600 0.58rem var(--mono); cursor: pointer; border: 1px solid; transition: .12s; white-space: nowrap; }
  .apikey-btn.validate { background: rgba(167,139,250,.12); border-color: rgba(167,139,250,.4); color: #a78bfa; }
  .apikey-btn.validate:hover { background: rgba(167,139,250,.22); }
  .apikey-btn.clear { background: rgba(248,113,113,.08); border-color: rgba(248,113,113,.3); color: #f87171; }
  .apikey-badge { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; border-radius: 4px; font: 500 0.62rem var(--mono); cursor: pointer; }
  .apikey-badge.ok  { background: rgba(52,211,153,.1); border: 1px solid rgba(52,211,153,.3); color: #34d399; }
  .apikey-badge.err { background: rgba(248,113,113,.08); border: 1px solid rgba(248,113,113,.3); color: #f87171; }

  /* ‚îÄ‚îÄ phpVMS Integration ‚îÄ‚îÄ */
  .cfg-phpvms { margin-top: 8px; padding: 8px 10px; background: var(--bg3); border: 1px solid var(--brd); border-radius: 6px; }
  .cfg-phpvms-hdr { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; }
  .cfg-phpvms-ttl { font: 600 0.65rem var(--mono); color: #a78bfa; letter-spacing: .5px; }
  .phpvms-toggle { display: flex; align-items: center; gap: 6px; cursor: pointer; }
  .phpvms-toggle input[type=checkbox] { accent-color: #a78bfa; width: 13px; height: 13px; }
  .ops-src-phpvms { font: 700 0.55rem var(--mono); color: #a78bfa; background: rgba(167,139,250,.1); border: 1px solid rgba(167,139,250,.3); border-radius: 3px; padding: 1px 5px; }

  /* ‚îÄ‚îÄ FSUIPC Data Source Badge ‚îÄ‚îÄ */
  .fsuipc-badge {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 2px 7px; border-radius: 4px; font: 700 0.58rem var(--mono);
    letter-spacing: .6px; border: 1px solid; cursor: default;
    transition: all .3s; user-select: none;
  }
  .fsuipc-badge.src-ivao  { color: var(--tx3); border-color: var(--brd); background: transparent; }
  .fsuipc-badge.src-fsuipc { color: #34d399; border-color: rgba(52,211,153,.4); background: rgba(52,211,153,.08); }
  .fsuipc-badge.src-connecting { color: var(--wrn); border-color: rgba(251,191,36,.4); background: rgba(251,191,36,.06); animation: fsuipc-blink 1.2s ease-in-out infinite; }
  @keyframes fsuipc-blink { 0%,100% { opacity:1 } 50% { opacity:.4 } }
  .fsuipc-badge .fsuipc-dot { width: 5px; height: 5px; border-radius: 50%; background: currentColor; }
  /* OPS card ‚Äî indicador SIM en vuelo local */
  .ops-src-sim { font: 700 0.55rem var(--mono); color: #34d399; background: rgba(52,211,153,.1); border: 1px solid rgba(52,211,153,.3); border-radius: 3px; padding: 1px 5px; }
  .ops-src-ivao { font: 700 0.55rem var(--mono); color: var(--tx3); background: var(--bg3); border: 1px solid var(--brd); border-radius: 3px; padding: 1px 5px; }
  /* Config FSUIPC section */
  .cfg-fsuipc { margin-top: 8px; padding: 8px 10px; background: var(--bg3); border: 1px solid var(--brd); border-radius: 6px; }
  .cfg-fsuipc-hdr { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; }
  .cfg-fsuipc-ttl { font: 600 0.65rem var(--mono); color: var(--acc); letter-spacing: .5px; }
  .fsuipc-toggle { display: flex; align-items: center; gap: 6px; cursor: pointer; }
  .fsuipc-toggle input[type=checkbox] { accent-color: var(--acc); width: 13px; height: 13px; }
  .fsuipc-toggle label { font: 500 0.65rem var(--mono); color: var(--tx2); cursor: pointer; }

  .ops-flt { background: var(--bg1); border: 1px solid var(--brd); border-radius: 6px; padding: 8px 10px; margin-bottom: 5px; display: flex; align-items: center; gap: 10px; }
  .ops-flt.ph-preflight { border-left: 3px solid var(--wrn); }
  .ops-flt.ph-enroute { border-left: 3px solid var(--inf); }
  .ops-flt.ph-descent { border-left: 3px solid var(--cpdlc); }
  .ops-flt.ph-landed { border-left: 3px solid var(--ok); }
  .ops-cs { font: 700 0.8rem var(--mono); color: var(--acc); min-width: 70px; }
  .ops-rt { font: 400 0.65rem var(--mono); color: var(--tx2); flex: 1; }
  .ops-ph { padding: 2px 8px; border-radius: 3px; font: 700 0.58rem var(--mono); letter-spacing: .5px; }
  .ops-ph.preflight { background: rgba(251,191,36,.1); color: var(--wrn); }
  .ops-ph.enroute { background: rgba(96,165,250,.1); color: var(--inf); }
  .ops-ph.descent { background: rgba(167,139,250,.1); color: var(--cpdlc); }
  .ops-ph.landed { background: rgba(52,211,153,.1); color: var(--ok); }
  .ops-log-e { font: 400 0.6rem/1.4 var(--mono); color: var(--tx3); padding: 2px 0; border-bottom: 1px solid rgba(28,35,51,.3); }
  .ops-log-e .t { color: var(--tx3); margin-right: 6px; }
  .ops-log-e.ok { color: var(--ok); }
  .ops-log-e.err { color: var(--err); }
  .ops-log-e.ops { color: var(--ops); }

  /* ‚îÄ‚îÄ OCC Board ‚îÄ‚îÄ */
  .occ-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  .occ-count { font: 600 0.72rem var(--mono); color: var(--tx2); }
  .occ-count strong { color: var(--acc); }
  .occ-refresh { font: 400 0.6rem var(--mono); color: var(--tx3); }
  .occ-tbl { width: 100%; border-collapse: collapse; font: 400 0.62rem/1.3 var(--mono); }
  .occ-tbl th { text-align: left; padding: 6px 5px; font-weight: 700; color: var(--tx3); letter-spacing: .8px; text-transform: uppercase; border-bottom: 1px solid var(--brd); white-space: nowrap; font-size: 0.56rem; }
  .occ-tbl td { padding: 5px 5px; border-bottom: 1px solid rgba(28,35,51,.3); color: var(--tx2); white-space: nowrap; }
  .occ-tbl tr:hover td { background: rgba(46,140,240,.04); }
  .occ-cs { color: var(--acc) !important; font-weight: 700; }
  .occ-state { padding: 1px 6px; border-radius: 3px; font-weight: 700; font-size: 0.55rem; letter-spacing: .5px; }
  .st-gnd { background: rgba(74,85,104,.2); color: var(--tx3); }
  .st-dep { background: rgba(251,191,36,.1); color: var(--wrn); }
  .st-clb { background: rgba(251,191,36,.15); color: #f59e0b; }
  .st-enr { background: rgba(96,165,250,.1); color: var(--inf); }
  .st-crz { background: rgba(52,211,153,.1); color: var(--ok); }
  .st-dsc { background: rgba(167,139,250,.1); color: var(--cpdlc); }
  .st-app { background: rgba(248,113,113,.1); color: var(--err); }
  .st-lnd { background: rgba(52,211,153,.15); color: #10b981; }
  .occ-empty { text-align: center; padding: 40px 10px; color: var(--tx3); font: 400 0.78rem var(--mono); }
  .occ-scroll { overflow-x: auto; -webkit-overflow-scrolling: touch; }

  /* ‚îÄ‚îÄ Stream Mode ‚îÄ‚îÄ */
  .stream-overlay { display: none; position: fixed; inset: 0; z-index: 9999; background: #030508; color: #e6eaef; font-family: var(--mono); overflow-y: auto; padding: 30px 40px; }
  .stream-overlay.on { display: flex; flex-direction: column; }
  .str-hdr { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 24px; }
  .str-icao { font: 700 3.5rem/1 var(--mono); color: var(--acc); letter-spacing: 4px; }
  .str-sub { font: 400 0.9rem var(--mono); color: #4a5568; margin-top: 4px; }
  .str-close { background: 0; border: 1px solid #1c2333; color: #4a5568; width: 44px; height: 44px; border-radius: 8px; font-size: 1.4rem; cursor: pointer; transition: .15s; flex-shrink: 0; }
  .str-close:hover { border-color: var(--err); color: var(--err); }
  .str-atis { background: #0b0f18; border: 1px solid #1c2333; border-radius: 10px; padding: 16px 20px; margin-bottom: 20px; }
  .str-atis-h { font: 700 0.7rem var(--mono); color: var(--acc); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 8px; }
  .str-atis-body { font: 400 1rem/1.5 var(--mono); color: #c0c8d4; white-space: pre-wrap; word-break: break-word; }
  .str-wx { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 20px; }
  .str-wx-item { background: #0b0f18; border: 1px solid #1c2333; border-radius: 10px; padding: 14px; text-align: center; }
  .str-wx-val { font: 700 1.8rem/1.2 var(--mono); }
  .str-wx-lbl { font: 400 0.65rem var(--mono); color: #4a5568; letter-spacing: 1px; text-transform: uppercase; margin-top: 4px; }
  .str-flights { flex: 1; }
  .str-tbl { width: 100%; border-collapse: collapse; font: 400 0.85rem/1.3 var(--mono); }
  .str-tbl th { text-align: left; padding: 10px 8px; font-weight: 700; color: #4a5568; letter-spacing: 1px; text-transform: uppercase; border-bottom: 2px solid #1c2333; font-size: 0.7rem; }
  .str-tbl td { padding: 10px 8px; border-bottom: 1px solid rgba(28,35,51,.4); color: #c0c8d4; }
  .str-tbl tr:hover td { background: rgba(46,140,240,.04); }
  .str-cs { color: var(--acc); font-weight: 700; font-size: 0.95rem; }
  .str-state { padding: 3px 10px; border-radius: 4px; font-weight: 700; font-size: 0.7rem; letter-spacing: .5px; }
  .str-empty { text-align: center; padding: 60px; color: #4a5568; font: 400 1.2rem var(--mono); }
  .str-footer { text-align: center; padding: 12px 0; margin-top: auto; }
  .str-footer span { font: 600 0.6rem var(--mono); color: #1c2333; letter-spacing: 2px; text-transform: uppercase; }
  @media (max-width: 600px) {
    .str-icao { font-size: 2.2rem; }
    .stream-overlay { padding: 16px; }
    .str-tbl { font-size: 0.7rem; }
  }
</style>
</head>
<body>
<div class="app">

  <!-- ‚ïê‚ïê‚ïê HEADER ‚ïê‚ïê‚ïê -->
  <div class="hdr">
    <div class="hdr-l">
      <div class="hdr-ico">AN</div>
      <div class="hdr-t">
        <h1>ACARS Dispatch</h1>
        <div class="sub">AirNubeiro v4.2</div>
      </div>
    </div>
    <div class="hdr-r">
      <!-- Auto-poll toggle -->
      <button class="ib" id="btnAuto" onclick="toggleAutoPoll()" title="Auto-poll ON/OFF">
        <span id="autoIco">‚è±</span>
      </button>
      <!-- Manual poll -->
      <button class="ib" id="btnPoll" onclick="doPoll()" title="Poll manual">
        üì• <span class="bdg" id="rxBdg">0</span>
      </button>
      <!-- Sound -->
      <button class="ib" id="btnSnd" onclick="toggleSound()" title="Sonido ON/OFF">üîî</button>
      <!-- FSUIPC data source indicator -->
      <span class="fsuipc-badge src-ivao" id="fsuipcBadge" title="Fuente de datos: IVAO Whazzup">
        <span class="fsuipc-dot"></span>IVAO
      </span>
      <!-- Stream Mode -->
      <button class="ib" id="btnStream" onclick="openStream()" title="Stream Mode (F11)">üì∫</button>
      <!-- Config -->
      <button class="ib" id="btnCfg" onclick="toggleCfg()">‚öô</button>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê CONFIG ‚ïê‚ïê‚ïê -->
  <div class="cfg" id="cfgP">
    <h3>Configuraci√≥n</h3>
    <div class="cfg-g">
      <div class="f"><label>LOGON CODE</label><input type="text" id="cL" placeholder="Tu c√≥digo Hoppie" autocomplete="off" spellcheck="false"></div>
      <div class="f"><label>CALLSIGN ESTACI√ìN</label><input type="text" id="cS" class="uc" placeholder="LEMD_TWR" maxlength="12" autocomplete="off" spellcheck="false"></div>
      <div class="f"><label>INTERVALO AUTO-POLL (seg)</label><input type="number" id="cI" value="20" min="5" max="120" step="5"></div>
      <div class="f">
        <label>CORS PROXY
          <span class="hi" tabindex="0">?<span class="tt">La API de Hoppie no permite peticiones directas desde navegador. Se usa corsproxy.io por defecto.</span></span>
        </label>
        <input type="text" id="cP" value="https://corsproxy.io/?" spellcheck="false">
      </div>
    </div>
    <!-- FSUIPC WebSocket Config -->
    <div class="cfg-fsuipc">
      <div class="cfg-fsuipc-hdr">
        <span class="cfg-fsuipc-ttl">‚úà FSUIPC WEBSOCKET ‚Äî Datos Sim Local</span>
        <label class="fsuipc-toggle">
          <input type="checkbox" id="fsuipcEn" onchange="fsuipcOnToggle()">
          <span>Activar</span>
        </label>
      </div>
      <div class="cfg-g" id="fsuipcCfgFields" style="opacity:.45;pointer-events:none;margin-top:4px">
        <div class="f"><label>WS URL</label><input type="text" id="fsuipcUrl" value="ws://127.0.0.1:2048" spellcheck="false" autocomplete="off"></div>
        <div class="f"><label>MI CALLSIGN (piloto local)
          <span class="hi" tabindex="0">?<span class="tt">Callsign de tu vuelo en IVAO. OPS usar√° datos del simulador para este callsign en lugar de IVAO Whazzup.</span></span>
        </label><input type="text" id="fsuipcCs" class="uc" placeholder="NBV101" maxlength="12" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>POLL INTERVALO (ms)</label><input type="number" id="fsuipcPoll" value="500" min="200" max="2000" step="100"></div>
      </div>
      <div style="font:.6rem var(--mono);color:var(--tx3);margin-top:5px" id="fsuipcStatus">Desactivado ‚Äî activa para conectar al simulador local</div>
    </div>
    <!-- phpVMS Integration Config -->
    <div class="cfg-phpvms">
      <div class="cfg-phpvms-hdr">
        <span class="cfg-phpvms-ttl">üóÑ phpVMS ‚Äî Pilotos AirNubeiro</span>
        <label class="phpvms-toggle">
          <input type="checkbox" id="phpvmsEn" onchange="phpvmsOnToggle()">
          <span>Activar</span>
        </label>
      </div>
      <div class="cfg-g" id="phpvmsCfgFields" style="opacity:.45;pointer-events:none;margin-top:4px">
        <div class="f"><label>URL phpVMS</label><input type="text" id="phpvmsUrl" value="https://operaciones.airnubeiro.es" spellcheck="false" autocomplete="off"></div>
        <div class="f"><label>API KEY phpVMS
          <span class="hi" tabindex="0">?<span class="tt">Pega tu API Key y pulsa VALIDAR. Se verifica contra /api/user y se guarda cifrada con AES-256. Nunca se almacena en claro.</span></span>
        </label>
          <div id="apikeyDisplay"></div>
          <div class="apikey-wrap" id="apikeyInputWrap" style="display:none">
            <input type="password" id="phpvmsKeyRaw" placeholder="Pega tu API Key aqu√≠" autocomplete="off" spellcheck="false" oninput="apikeyOnInput()">
            <div class="apikey-actions">
              <button class="apikey-btn validate" id="apikeyValidateBtn" onclick="apikeyValidateAndSave()" style="display:none">‚úì VALIDAR</button>
            </div>
          </div>
        </div>
        <div class="f"><label>POLL (seg)</label><input type="number" id="phpvmsPoll" value="30" min="15" max="120" step="5"></div>
      </div>
      <div style="font:.6rem var(--mono);color:var(--tx3);margin-top:5px" id="phpvmsStatus">Desactivado ‚Äî activa para monitorizar pilotos via phpVMS</div>
    </div>
    <!-- Discord Webhook Config -->
    <div class="cfg-discord">
      <div class="cfg-discord-hdr">
        <span class="cfg-discord-ttl">üí¨ DISCORD WEBHOOK ‚Äî Notificaciones</span>
        <label class="discord-toggle">
          <input type="checkbox" id="discordEn" onchange="discordOnToggle()">
          <span>Activar</span>
        </label>
      </div>
      <div id="discordCfgFields" style="opacity:.45;pointer-events:none">
        <div class="f"><label>WEBHOOK URL
          <span class="hi" tabindex="0">?<span class="tt">URL del webhook de Discord. Formato: https://discord.com/api/webhooks/{id}/{token}. Config√∫ralo en tu servidor Discord ‚Üí Editar canal ‚Üí Integraciones ‚Üí Webhooks.</span></span>
        </label><input type="text" id="discordUrl" placeholder="https://discord.com/api/webhooks/..." spellcheck="false" autocomplete="off"></div>
        <div class="f" style="margin-top:5px"><label>NOTIFICAR EN</label>
          <div class="discord-events">
            <label><input type="checkbox" id="dcEvFlight" checked> Vuelo detectado</label>
            <label><input type="checkbox" id="dcEvPhase"  checked> Cambio de fase</label>
            <label><input type="checkbox" id="dcEvTelex"  checked> TELEX enviado</label>
            <label><input type="checkbox" id="dcEvAlert"  checked> Alertas OPS</label>
          </div>
        </div>
        <button class="discord-test-btn" onclick="discordTest()">‚ñ∂ Enviar mensaje de prueba</button>
      </div>
      <div style="font:.6rem var(--mono);color:var(--tx3);margin-top:5px" id="discordStatus">Desactivado ‚Äî configura webhook URL y activa</div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê STATUS ‚ïê‚ïê‚ïê -->
  <div class="sb idle" id="sBar"><div class="d"></div><span id="sTxt">Configura logon y callsign</span></div>

  <!-- Connected stations -->
  <div id="connBox" style="display:none">
    <div style="font:.6rem var(--mono);color:var(--tx3);letter-spacing:1px;text-transform:uppercase;margin-bottom:3px">Estaciones conectadas (CPDLC)</div>
    <div class="conn-list" id="connList"></div>
  </div>

  <!-- ‚ïê‚ïê‚ïê TABS ‚ïê‚ïê‚ïê -->
  <div class="tabs">
    <button class="tab on" data-t="telex" onclick="sw('telex')">Telex</button>
    <button class="tab" data-t="info" onclick="sw('info')">INFO</button>
    <button class="tab" data-t="cpdlc" onclick="sw('cpdlc')">CPDLC</button>
    <button class="tab" data-t="dsp" onclick="sw('dsp')">DSP</button>
    <button class="tab" data-t="ops" onclick="sw('ops')">OPS</button>
    <button class="tab" data-t="occ" onclick="sw('occ');refreshOcc()">OCC</button>
    <button class="tab" data-t="rx" onclick="sw('rx')">Recibidos <span class="tb" id="rxTab">0</span></button>
    <button class="tab" data-t="tx" onclick="sw('tx')">Enviados</button>
  </div>

  <!-- ‚ïê‚ïê‚ïê TELEX ‚ïê‚ïê‚ïê -->
  <div class="pnl on" id="p-telex">
    <div class="cd">
      <div class="ct">Enviar TELEX</div>
      <div class="f" style="margin-bottom:7px"><label>DESTINO</label><input type="text" id="txD" class="uc" placeholder="IBE3456" maxlength="12" autocomplete="off" spellcheck="false"></div>
      <div class="tpls">
        <button class="tp" onclick="tT('GATE CHANGE: PROCEED TO GATE __')">GATE CHG</button>
        <button class="tp" onclick="tT('DELAY EXPECTED. REVISED EOBT: ____Z')">DELAY</button>
        <button class="tp" onclick="tT('CLEARED TO TAXI VIA __')">TAXI CLR</button>
        <button class="tp" onclick="tT('CONFIRM READY FOR DEPARTURE')">RDY DEP?</button>
        <button class="tp" onclick="tT('CONTACT __ ON FREQ ___.__')">FREQ CHG</button>
        <button class="tp" onclick="tT('SQUAWK ____')">SQUAWK</button>
      </div>
      <div class="f"><label>MENSAJE</label><textarea id="txM" placeholder="Texto TELEX..." rows="3" maxlength="500"></textarea><div class="chc" id="txC">0 / 500</div></div>
      <button class="bp" id="txB" onclick="sendTx()" disabled>ENVIAR TELEX</button>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê METAR/ATIS ‚ïê‚ïê‚ïê -->
  <div class="pnl" id="p-info">
    <div class="cd">
      <div class="ct inf">Solicitar METAR / ATIS / TAF</div>
      <div class="r2" style="margin-bottom:8px">
        <div class="f"><label>ICAO</label><input type="text" id="inI" class="uc" placeholder="LEMD" maxlength="4" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>TIPO</label>
          <select id="inT">
            <option value="metar">METAR actual</option>
            <option value="metar-hist">METAR historico (3h)</option>
            <option value="taf">TAF (pronostico)</option>
            <option value="vatatis">ATIS ‚Äî VATSIM</option>
            <option value="ivaoatis">ATIS ‚Äî IVAO</option>
          </select>
        </div>
      </div>
      <button class="bp ifc" id="inB" onclick="sendInfo()" disabled>SOLICITAR</button>
    </div>
    <div class="cd" id="inR" style="display:none">
      <div class="ct inf">Resultado</div>
      <div class="mb" id="inRT"></div>
      <div style="margin-top:10px;display:flex;gap:6px;align-items:end">
        <div class="f" style="flex:1"><label>REENVIAR A (callsign)</label><input type="text" id="fwdTo" class="uc" placeholder="IBE3456" maxlength="12" autocomplete="off" spellcheck="false"></div>
        <button class="bs" onclick="fwdInfo()" style="height:36px;white-space:nowrap">üì§ Enviar TELEX</button>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê CPDLC ‚ïê‚ïê‚ïê -->
  <div class="pnl" id="p-cpdlc">
    <div class="cd">
      <div class="ct cp">CPDLC Uplink (ATC ‚Üí Piloto)</div>
      <div class="r2" style="margin-bottom:6px">
        <div class="f"><label>DESTINO</label><input type="text" id="cpD" class="uc" placeholder="IBE3456" maxlength="12" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>MSG ID</label><input type="number" id="cpId" value="1" min="1" max="999"></div>
      </div>
      <div class="r2" style="margin-bottom:6px">
        <div class="f"><label>RESPUESTA</label>
          <select id="cpR">
            <option value="WU">W/U ‚Äî Wilco/Unable</option>
            <option value="AN">A/N ‚Äî Affirm/Negative</option>
            <option value="R">R ‚Äî Roger</option>
            <option value="Y">Y ‚Äî Libre</option>
            <option value="N">N ‚Äî No req (puede resp)</option>
            <option value="NE">NE ‚Äî Solo informativo</option>
          </select>
        </div>
        <div class="f"><label>MENSAJE</label><input type="text" id="cpM" class="uc" placeholder="CLIMB TO FL350" autocomplete="off" spellcheck="false"></div>
      </div>
      <div class="tpls">
        <button class="tp cp" onclick="tC('CLIMB TO FL___')">CLIMB</button>
        <button class="tp cp" onclick="tC('DESCEND TO FL___')">DESCEND</button>
        <button class="tp cp" onclick="tC('MAINTAIN FL___')">MAINTAIN</button>
        <button class="tp cp" onclick="tC('TURN LEFT HDG ___')">TURN L</button>
        <button class="tp cp" onclick="tC('TURN RIGHT HDG ___')">TURN R</button>
        <button class="tp cp" onclick="tC('PROCEED DIRECT TO ___')">DIRECT</button>
        <button class="tp cp" onclick="tC('CONTACT ___ ON ___.__')">CONTACT</button>
        <button class="tp cp" onclick="tC('SQUAWK ____')">SQUAWK</button>
        <button class="tp cp" onclick="tC('REPORT POSITION')">REPORT</button>
        <button class="tp cp" onclick="tC('CLEARED TO ___ VIA ___')">CLR TO</button>
        <button class="tp cp" onclick="tC('CROSS ___ AT FL___')">CROSS AT</button>
        <button class="tp cp" onclick="tC('RESUME OWN NAVIGATION')">RESUME NAV</button>
      </div>
      <button class="bp cpc" id="cpB" onclick="sendCp()" disabled>ENVIAR CPDLC</button>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê DISPATCH ‚ïê‚ïê‚ïê -->
  <div class="pnl" id="p-dsp">
    <div class="cd">
      <div class="ct dsp">Dispatch Automatizado (SimBrief + IVAO)</div>
      <div class="r2" style="margin-bottom:6px">
        <div class="f"><label>SIMBRIEF USER / ID
          <span class="hi" tabindex="0">?<span class="tt">Username de Navigraph o Pilot ID num√©rico de SimBrief. Lo encuentras en Account Settings de SimBrief.</span></span>
        </label><input type="text" id="dspSb" placeholder="username o ID" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>CALLSIGN DESTINO</label><input type="text" id="dspTo" class="uc" placeholder="IBE3456" maxlength="12" autocomplete="off" spellcheck="false"></div>
      </div>
      <button class="bp dsp-btn" id="dspFetch" onclick="fetchDispatch()">üìã GENERAR DISPATCH</button>
    </div>

    <!-- ‚ïê‚ïê‚ïê QUICK DISPATCH (sin SimBrief) ‚ïê‚ïê‚ïê -->
    <div class="cd">
      <div class="ct dsp">Quick Dispatch (sin SimBrief)</div>
      <div class="r2" style="margin-bottom:6px">
        <div class="f"><label>ICAO AEROPUERTO</label><input type="text" id="qdIcao" class="uc" placeholder="LEMD" maxlength="4" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>CALLSIGN DESTINO</label><input type="text" id="qdTo" class="uc" placeholder="IBE3456" maxlength="12" autocomplete="off" spellcheck="false"></div>
      </div>
      <div class="tpls">
        <button class="tp cp" onclick="qdFetch('traffic')" style="background:rgba(46,140,240,.06);border-color:rgba(46,140,240,.2);color:#2e8cf0">üì° TRAFICO</button>
        <button class="tp cp" onclick="qdFetch('metar')" style="background:rgba(46,140,240,.06);border-color:rgba(46,140,240,.2);color:#2e8cf0">üå§Ô∏è METAR</button>
        <button class="tp cp" onclick="qdFetch('taf')" style="background:rgba(46,140,240,.06);border-color:rgba(46,140,240,.2);color:#2e8cf0">üìã TAF</button>
        <button class="tp cp" onclick="qdFetch('atis-ivao')" style="background:rgba(46,140,240,.06);border-color:rgba(46,140,240,.2);color:#2e8cf0">üìª ATIS IVAO</button>
        <button class="tp cp" onclick="qdFetch('atis-vatsim')" style="background:rgba(46,140,240,.06);border-color:rgba(46,140,240,.2);color:#2e8cf0">üìª ATIS VATSIM</button>
      </div>
    </div>

    <!-- ‚ïê‚ïê‚ïê ROUTE INFO ‚ïê‚ïê‚ïê -->
    <div class="cd">
      <div class="ct dsp">Route Info (ATCs + SIGMETs + PIREPs)</div>
      <div class="r2" style="margin-bottom:6px">
        <div class="f"><label>CALLSIGN PILOTO EN IVAO
          <span class="hi" tabindex="0">?<span class="tt">Callsign del piloto activo en IVAO. Se busca su posici√≥n y heading para calcular ATCs, SIGMETs y PIREPs en su ruta.</span></span>
        </label><input type="text" id="riCs" class="uc" placeholder="NBV101" maxlength="12" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>ENVIAR A (callsign)</label><input type="text" id="riTo" class="uc" placeholder="(mismo si vac√≠o)" maxlength="12" autocomplete="off" spellcheck="false"></div>
      </div>
      <button class="bp dsp-btn" id="riBtn" onclick="fetchRouteInfo()">üó∫Ô∏è GENERAR ROUTE INFO</button>
    </div>

    <!-- Route info result -->
    <div class="dsp-card" id="riResult" style="display:none">
      <h4 id="riTitle"><span class="ico">üó∫Ô∏è</span> ‚Äî</h4>
      <pre id="riBody"></pre>
      <button class="dsp-send" id="riSend" onclick="riSendTelex()">üì§ Enviar TELEX</button>
    </div>

    <!-- ‚ïê‚ïê‚ïê PAX CONNECTIONS (manual) ‚ïê‚ïê‚ïê -->
    <div class="cd">
      <div class="ct dsp">Conexiones PAX + Crew Info</div>
      <div class="r2" style="margin-bottom:6px">
        <div class="f"><label>ICAO DESTINO (llegada)
          <span class="hi" tabindex="0">?<span class="tt">Aeropuerto donde aterriza el vuelo. Genera conexiones PAX con vuelos de aerol√≠neas del pa√≠s + crew rotation.</span></span>
        </label><input type="text" id="cxIcao" class="uc" placeholder="EGLL" maxlength="4" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>ENVIAR A (callsign)</label><input type="text" id="cxTo" class="uc" placeholder="NBV101" maxlength="12" autocomplete="off" spellcheck="false"></div>
      </div>
      <div class="tpls">
        <button class="tp cp" onclick="manualPaxConn()" style="background:rgba(244,114,182,.06);border-color:rgba(244,114,182,.2);color:#f472b6">üë• CONEXIONES PAX</button>
        <button class="tp cp" onclick="manualCrewInfo()" style="background:rgba(167,139,250,.06);border-color:rgba(167,139,250,.2);color:#a78bfa">üë®‚Äç‚úàÔ∏è CREW INFO</button>
      </div>
    </div>
    <div class="dsp-card" id="cxResult" style="display:none">
      <h4 id="cxTitle"><span class="ico">üë•</span> ‚Äî</h4>
      <pre id="cxBody"></pre>
      <button class="dsp-send" id="cxSend" onclick="cxSendTelex()">üì§ Enviar TELEX</button>
    </div>

    <!-- Quick dispatch result -->
    <div class="dsp-card" id="qdResult" style="display:none">
      <h4 id="qdTitle"><span class="ico">üì°</span> ‚Äî</h4>
      <pre id="qdBody"></pre>
      <button class="dsp-send" id="qdSend" onclick="qdSendTelex()">üì§ Enviar TELEX</button>
    </div>

    <!-- Loading -->
    <div class="dsp-loading" id="dspLoad" style="display:none"><span class="spin">‚ü≥</span> Obteniendo OFP de SimBrief + tr√°fico IVAO...</div>

    <!-- Flight summary -->
    <div class="dsp-summary" id="dspSum" style="display:none">
      <div class="head">Resumen del vuelo</div>
      <div id="dspSumRows"></div>
    </div>

    <!-- Generated messages -->
    <div class="dsp-cards" id="dspCards" style="display:none"></div>

    <!-- Send all -->
    <button class="bp dsp-btn" id="dspAll" onclick="sendAllDispatch()" style="display:none">üì§ ENVIAR TODOS LOS TELEX</button>
  </div>

  <!-- ‚ïê‚ïê‚ïê OPS CENTER (embedded) ‚ïê‚ïê‚ïê -->
  <div class="pnl" id="p-ops">
    <div class="cd">
      <div class="ct dsp">OPS Center ‚Äî Monitor IVAO</div>
      <div style="font:.62rem var(--mono);color:var(--tx3);margin-bottom:8px;line-height:1.4">Monitoriza vuelos NBV en IVAO y les env√≠a autom√°ticamente TELEX de tr√°fico, meteorolog√≠a, ATIS, conexiones PAX y crew info seg√∫n la fase de vuelo. <a href="ops-center.html" target="_blank" style="color:var(--inf)">Versi√≥n completa ‚Üó</a></div>
      <div class="r2" style="margin-bottom:6px">
        <div class="f"><label>PREFIJO AEROL√çNEA</label><input type="text" id="opsPrefix" class="uc" value="NBV" maxlength="6" autocomplete="off" spellcheck="false"></div>
        <div class="f"><label>SCAN (seg)</label><input type="number" id="opsInterval" value="45" min="15" max="180" step="5"></div>
      </div>
      <div class="r2" style="margin-bottom:6px">
        <div class="f"><label>ROUTE INFO CADA (min)
          <span class="hi" tabindex="0">?<span class="tt">Env√≠a ATCs+frecuencias, SIGMETs y PIREPs a pilotos en crucero cada X minutos.</span></span>
        </label><input type="number" id="opsRI" value="10" min="5" max="60" step="1"></div>
        <div class="f"></div>
      </div>
      <div style="display:flex;gap:6px">
        <button class="bp dsp-btn" id="opsBtn" onclick="toggleOpsMonitor()" style="flex:1">‚ñ∂ INICIAR MONITOR</button>
        <a href="ops-center.html" target="_blank" class="bp" style="flex:0;padding:0 14px;display:flex;align-items:center;font-size:.7rem;text-decoration:none;background:var(--bg2);color:var(--tx2);border:1px solid var(--brd)">‚Üó COMPLETO</a>
      </div>
    </div>
    <!-- OPS stats -->
    <div id="opsStats" style="display:none;font:.65rem var(--mono);color:var(--tx3);padding:6px 0;display:flex;gap:10px;flex-wrap:wrap">
    </div>
    <!-- Flight list -->
    <div id="opsFlights"></div>
    <!-- OPS log -->
    <div id="opsLog" style="max-height:160px;overflow-y:auto"></div>
  </div>

  <!-- ‚ïê‚ïê‚ïê OCC BOARD ‚ïê‚ïê‚ïê -->
  <div class="pnl" id="p-occ">
    <div class="cd">
      <div class="ct inf">OCC Board ‚Äî Vuelos AirNubeiro</div>
      <div class="occ-bar">
        <div class="occ-count" id="occCount">Cargando...</div>
        <div class="occ-refresh" id="occRefresh"></div>
      </div>
      <div class="occ-scroll">
        <div id="occBody">
          <div class="occ-empty">Cargando datos IVAO...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê RECIBIDOS ‚ïê‚ïê‚ïê -->
  <div class="pnl" id="p-rx">
    <div class="lh">
      <h3>Mensajes recibidos</h3>
      <div class="lh-btns"><button class="sm pl" onclick="doPoll()">‚ü≥ Poll</button><button class="sm" onclick="clr('rx')">Limpiar</button></div>
    </div>
    <div class="ml" id="rxL"><div class="me-empty" id="rxE">Sin mensajes ‚Äî pulsa Poll o activa Auto-poll</div></div>
  </div>

  <!-- ‚ïê‚ïê‚ïê ENVIADOS ‚ïê‚ïê‚ïê -->
  <div class="pnl" id="p-tx">
    <div class="lh">
      <h3>Mensajes enviados</h3>
      <div class="lh-btns"><button class="sm" onclick="clr('tx')">Limpiar</button></div>
    </div>
    <div class="ml" id="txL"><div class="me-empty" id="txE">Sin mensajes enviados</div></div>
  </div>

  <!-- ‚ïê‚ïê‚ïê FOOTER ‚ïê‚ïê‚ïê -->
  <div class="ftr">
    <div class="br">‚úà AirNubeiro ACARS Dispatch</div>
    <div class="lg">Creado por Varo para AirNubeiro ‚Äî Todos los derechos reservados ¬© 2026</div>
  </div>

</div>

<!-- ‚ïê‚ïê‚ïê STREAM MODE OVERLAY ‚ïê‚ïê‚ïê -->
<div class="stream-overlay" id="streamOverlay">
  <div class="str-hdr">
    <div>
      <div class="str-icao" id="strIcao">----</div>
      <div class="str-sub" id="strSub">AirNubeiro OPS ‚Äî Stream Mode</div>
    </div>
    <button class="str-close" onclick="closeStream()" title="Cerrar (ESC)">‚úï</button>
  </div>
  <div class="str-atis" id="strAtisBox" style="display:none">
    <div class="str-atis-h">ATIS</div>
    <div class="str-atis-body" id="strAtis"></div>
  </div>
  <div class="str-wx" id="strWx"></div>
  <div class="str-flights" id="strFlights">
    <div class="str-empty">Cargando vuelos NBV...</div>
  </div>
  <div class="str-footer"><span>AirNubeiro ACARS Dispatch ‚Äî Stream Mode</span></div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ACARS DISPATCH v4.2 ‚Äî AirNubeiro
//  Creado por Varo para AirNubeiro ¬∑ Todos los derechos reservados
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const HURL = 'http://www.hoppie.nl/acars/system/connect.html';
const HPARSE = /\{(.*?)\}/gs;
let busy = false, autoPoll = null, soundOn = true, rxCount = 0;
const connStations = new Set(); // CPDLC connected callsigns

const $ = id => document.getElementById(id);

// ‚îÄ‚îÄ Audio context (Web Audio API ‚Äî sin archivos externos) ‚îÄ‚îÄ
let audioCtx;
function beep(freq = 880, dur = 0.15, vol = 0.3) {
  if (!soundOn) return;
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  } catch(e) {}
}
function notifySound() { beep(800, 0.12); setTimeout(() => beep(1100, 0.15), 160); }
function errorSound() { beep(300, 0.25, 0.2); }

// ‚îÄ‚îÄ Config persistence ‚îÄ‚îÄ
function saveCfg() {
  try { localStorage.setItem('an3', JSON.stringify({
    l: $('cL').value, s: $('cS').value, p: $('cP').value,
    i: $('cI').value, snd: soundOn, sb: $('dspSb').value,
    fsuipcEn:   $('fsuipcEn')?.checked || false,
    fsuipcUrl:  $('fsuipcUrl')?.value  || 'ws://127.0.0.1:2048',
    fsuipcCs:   $('fsuipcCs')?.value   || '',
    fsuipcPoll: $('fsuipcPoll')?.value || '500',
    phpvmsEn:   $('phpvmsEn')?.checked  || false,
    phpvmsUrl:  $('phpvmsUrl')?.value   || 'https://operaciones.airnubeiro.es',
    phpvmsPoll: $('phpvmsPoll')?.value  || '30',
    discordEn:      $('discordEn')?.checked     || false,
    discordUrl:     $('discordUrl')?.value       || '',
    dcEvFlight:     $('dcEvFlight')?.checked     ?? true,
    dcEvPhase:      $('dcEvPhase')?.checked      ?? true,
    dcEvTelex:      $('dcEvTelex')?.checked      ?? true,
    dcEvAlert:      $('dcEvAlert')?.checked      ?? true,
  })); } catch(e) {}
}
function loadCfg() {
  try {
    const c = JSON.parse(localStorage.getItem('an3'));
    if (c) {
      $('cL').value = c.l||''; $('cS').value = c.s||'';
      if(c.p) $('cP').value = c.p; if(c.i) $('cI').value = c.i;
      if(c.snd !== undefined) soundOn = c.snd;
      if(c.sb) $('dspSb').value = c.sb;
      // Restaurar config FSUIPC
      if(c.fsuipcUrl  && $('fsuipcUrl'))  $('fsuipcUrl').value  = c.fsuipcUrl;
      if(c.fsuipcCs   && $('fsuipcCs'))   $('fsuipcCs').value   = c.fsuipcCs;
      if(c.fsuipcPoll && $('fsuipcPoll')) $('fsuipcPoll').value = c.fsuipcPoll;
      if(c.fsuipcEn && $('fsuipcEn')) {
        $('fsuipcEn').checked = true;
        const fields = $('fsuipcCfgFields');
        if(fields) { fields.style.opacity = '1'; fields.style.pointerEvents = ''; }
        // Auto-conectar si estaba activado al cerrar
        fsuipcConnect();
      }
      // Restaurar config phpVMS
      if(c.phpvmsUrl  && $('phpvmsUrl'))  $('phpvmsUrl').value  = c.phpvmsUrl;
      if(c.phpvmsPoll && $('phpvmsPoll')) $('phpvmsPoll').value = c.phpvmsPoll;
      apikeyRenderState();
      if(c.phpvmsEn && $('phpvmsEn')) {
        $('phpvmsEn').checked = true;
        const fields = $('phpvmsCfgFields');
        if(fields) { fields.style.opacity = '1'; fields.style.pointerEvents = ''; }
        // Auto-arrancar polling si estaba activado
        phpvmsScan();
        const pollMs = Math.max(15, parseInt(c.phpvmsPoll || 30)) * 1000;
        phpvmsInterval = setInterval(phpvmsScan, pollMs);
        phpvmsSetStatus('Restaurado desde config guardada ‚Äî escaneando‚Ä¶', null);
      }
      // Restaurar config Discord
      if(c.discordUrl && $('discordUrl')) $('discordUrl').value = c.discordUrl;
      if($('dcEvFlight') && c.dcEvFlight !== undefined) $('dcEvFlight').checked = c.dcEvFlight;
      if($('dcEvPhase')  && c.dcEvPhase  !== undefined) $('dcEvPhase').checked  = c.dcEvPhase;
      if($('dcEvTelex')  && c.dcEvTelex  !== undefined) $('dcEvTelex').checked  = c.dcEvTelex;
      if($('dcEvAlert')  && c.dcEvAlert  !== undefined) $('dcEvAlert').checked  = c.dcEvAlert;
      if(c.discordEn && $('discordEn')) {
        $('discordEn').checked = true;
        const fields = $('discordCfgFields');
        if(fields) { fields.style.opacity = '1'; fields.style.pointerEvents = ''; }
        discordSetStatus('Restaurado ‚Äî webhook activo', true);
      }
    }
  } catch(e) {}
}
[$('cL'),$('cS'),$('cP'),$('cI'),$('dspSb')].forEach(e => e.addEventListener('change', saveCfg));

function toggleCfg() { $('cfgP').classList.toggle('v'); $('btnCfg').classList.toggle('on'); }
function toggleSound() { soundOn = !soundOn; $('btnSnd').textContent = soundOn ? 'üîî' : 'üîï'; $('btnSnd').classList.toggle('on', !soundOn); saveCfg(); }

// ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ
function sw(n) {
  document.querySelectorAll('.tab').forEach(t => t.classList.toggle('on', t.dataset.t === n));
  document.querySelectorAll('.pnl').forEach(p => p.classList.toggle('on', p.id === 'p-' + n));
  if (n === 'rx') { rxCount = 0; updBdg(); }
}

// ‚îÄ‚îÄ Status ‚îÄ‚îÄ
function ss(c, t) { $('sBar').className = 'sb ' + c; $('sTxt').textContent = t; }

// ‚îÄ‚îÄ UC fields ‚îÄ‚îÄ
document.querySelectorAll('.uc').forEach(e => e.addEventListener('input', () => { e.value = e.value.toUpperCase(); }));

// ‚îÄ‚îÄ Char count ‚îÄ‚îÄ
$('txM').addEventListener('input', () => {
  const l = $('txM').value.length;
  $('txC').textContent = `${l} / 500`;
  $('txC').className = 'chc' + (l > 450 ? (l >= 500 ? ' o' : ' w') : '');
  updBtn();
});

// ‚îÄ‚îÄ Buttons state ‚îÄ‚îÄ
function updBtn() {
  const ok = $('cL').value.trim() && $('cS').value.trim();
  $('txB').disabled = !ok || !$('txD').value.trim() || !$('txM').value.trim() || busy;
  $('inB').disabled = !ok || !$('inI').value.trim() || busy;
  $('cpB').disabled = !ok || !$('cpD').value.trim() || !$('cpM').value.trim() || busy;
}
[$('cL'),$('cS'),$('txD'),$('txM'),$('inI'),$('cpD'),$('cpM')].forEach(e => e.addEventListener('input', updBtn));

// ‚îÄ‚îÄ Badge ‚îÄ‚îÄ
function updBdg() {
  $('rxBdg').textContent = rxCount; $('rxBdg').classList.toggle('v', rxCount > 0);
  const t = $('rxTab'); t.textContent = rxCount; t.classList.toggle('v', rxCount > 0);
}

// ‚îÄ‚îÄ Templates ‚îÄ‚îÄ
function tT(t) { $('txM').value = t; $('txM').focus(); $('txM').dispatchEvent(new Event('input')); }
function tC(t) { $('cpM').value = t; $('cpM').focus(); updBtn(); }

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
function ts() { return new Date().toISOString().replace('T',' ').substring(0,19) + 'Z'; }

// ‚îÄ‚îÄ Connected stations UI ‚îÄ‚îÄ
function updConn() {
  const box = $('connBox'), list = $('connList');
  if (connStations.size === 0) { box.style.display = 'none'; return; }
  box.style.display = 'block';
  list.innerHTML = '';
  connStations.forEach(cs => {
    const tag = document.createElement('span');
    tag.className = 'conn-tag';
    tag.innerHTML = `${esc(cs)} <span class="cx" onclick="disconnectStation('${esc(cs)}')" title="Desconectar">‚úï</span>`;
    list.appendChild(tag);
  });
}

async function disconnectStation(cs) {
  try {
    const mid = parseInt($('cpId').value);
    await hReq(cs, 'cpdlc', `/data2/${mid}//N/LOGOFF`);
    $('cpId').value = mid + 1;
  } catch(e) {}
  connStations.delete(cs);
  updConn();
  addMsg('tx', { cls: 'out', type: 'CPDLC', badge: 'b-cp', route: `${$('cS').value.toUpperCase()} ‚Üí ${cs}`, body: 'LOGOFF', time: ts(), st: '‚úì Desconectado', ok: true });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  HOPPIE API ‚Äî POST
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Hoppie only supports ASCII ‚Äî strip accents/√± for telex
function sanitizeForHoppie(txt) {
  if (!txt) return '';
  return txt
    .replace(/[√°√†√¢√§]/gi, m => m === m.toUpperCase() ? 'A' : 'a')
    .replace(/[√©√®√™√´]/gi, m => m === m.toUpperCase() ? 'E' : 'e')
    .replace(/[√≠√¨√Æ√Ø]/gi, m => m === m.toUpperCase() ? 'I' : 'i')
    .replace(/[√≥√≤√¥√∂]/gi, m => m === m.toUpperCase() ? 'O' : 'o')
    .replace(/[√∫√π√ª√º]/gi, m => m === m.toUpperCase() ? 'U' : 'u')
    .replace(/√±/g, 'n').replace(/√ë/g, 'N')
    .replace(/¬ø/g, '').replace(/¬°/g, '')
    .replace(/[^\x00-\x7F]/g, '');
}
async function hReq(to, type, packet) {
  const proxy = $('cP').value.trim();
  const url = proxy ? `${proxy}${encodeURIComponent(HURL)}` : HURL;
  const cleanPacket = type === 'telex' ? sanitizeForHoppie(packet) : packet;
  const r = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ logon: $('cL').value.trim(), from: $('cS').value.trim().toUpperCase(), to, type, packet: cleanPacket }).toString()
  });
  return (await r.text()).trim();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SEND TELEX
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function sendTx() {
  if (busy) return;
  const to = $('txD').value.trim().toUpperCase(), msg = $('txM').value.trim();
  if (!to || !msg) return;
  busy = true; const b = $('txB'); b.disabled = true; b.className = 'bp snd'; b.textContent = 'ENVIANDO...';
  ss('snd', `Enviando TELEX a ${to}...`);
  try {
    const raw = await hReq(to, 'telex', msg);
    const ok = raw.toLowerCase().startsWith('ok');
    addMsg('tx', { cls: ok?'out':'erm', type: 'TELEX', badge: 'b-tx', route: `${$('cS').value.toUpperCase()} ‚Üí ${to}`, body: msg, time: ts(), st: ok ? '‚úì OK' : `‚úó ${raw}`, ok });
    if (ok) { ss('ok', `‚úì TELEX ‚Üí ${to}`); b.className = 'bp ok'; b.textContent = '‚úì ENVIADO'; $('txM').value = ''; $('txM').dispatchEvent(new Event('input')); discordNotifyTelex(to, msg, false); }
    else { ss('err', `‚úó ${raw}`); b.className = 'bp er'; b.textContent = '‚úó ERROR'; errorSound(); }
  } catch(e) {
    addMsg('tx', { cls: 'erm', type: 'TELEX', badge: 'b-tx', route: `‚Üí ${to}`, body: msg, time: ts(), st: `‚úó ${e.message}`, ok: false });
    ss('err', '‚úó Error de red'); b.className = 'bp er'; b.textContent = '‚úó ERROR'; errorSound();
  }
  setTimeout(() => { busy = false; b.className = 'bp'; b.textContent = 'ENVIAR TELEX'; updBtn(); }, 1400);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SEND METAR/ATIS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let lastInfoResult = '';

async function sendInfo() {
  if (busy) return;
  const icao = $('inI').value.trim().toUpperCase(), type = $('inT').value;
  if (!icao) return;
  busy = true; $('inB').disabled = true; $('inB').textContent = 'SOLICITANDO...';
  ss('snd', `${type.toUpperCase()} ${icao}...`);
  try {
    let txt = '';
    let ok = true;

    if (type === 'metar' || type === 'metar-hist') {
      // Use aviationweather.gov for reliable METAR data
      const hours = type === 'metar-hist' ? 3 : 1;
      const proxy = $('cP').value.trim();
      try {
        const mUrl = `${METAR_API}?ids=${icao}&format=raw&hours=${hours}`;
        const mFetch = proxy ? `${proxy}${encodeURIComponent(mUrl)}` : mUrl;
        const mResp = await fetch(mFetch, { signal: AbortSignal.timeout(8000) });
        const mTxt = await mResp.text();
        if (mTxt.trim()) {
          if (type === 'metar') {
            // Only current (first line)
            txt = mTxt.trim().split('\n')[0];
          } else {
            // Historical: all lines with separator
            const lines = mTxt.trim().split('\n').filter(l => l.trim());
            txt = `METAR HISTORICO ${icao} (${lines.length} obs):\n${lines.join('\n')}`;
          }
        } else {
          txt = `No METAR available for ${icao}`;
          ok = false;
        }
      } catch(e) {
        // Fallback to Hoppie
        const raw = await hReq('SERVER', 'inforeq', `METAR ${icao}`);
        ok = raw.toLowerCase().startsWith('ok');
        txt = ok ? cleanHoppie(raw.substring(2).trim()) : raw;
        if (type === 'metar' && ok && txt.includes('\n')) {
          txt = txt.split('\n').filter(l => l.trim())[0] || txt;
        }
      }
    } else if (type === 'taf') {
      const proxy = $('cP').value.trim();
      try {
        const tUrl = `https://aviationweather.gov/api/data/taf?ids=${icao}&format=raw&hours=6`;
        const tFetch = proxy ? `${proxy}${encodeURIComponent(tUrl)}` : tUrl;
        const tResp = await fetch(tFetch, { signal: AbortSignal.timeout(6000) });
        txt = await tResp.text();
        txt = txt.trim() || 'No TAF available';
        ok = txt !== 'No TAF available';
      } catch(e) {
        const raw = await hReq('SERVER', 'inforeq', `TAF ${icao}`);
        ok = raw.toLowerCase().startsWith('ok');
        txt = ok ? cleanHoppie(raw.substring(2).trim()) : raw;
      }
    } else {
      // ATIS (IVAO or VATSIM) via Hoppie
      const hType = type === 'ivaoatis' ? 'IVAOATIS' : 'VATATIS';
      const raw = await hReq('SERVER', 'inforeq', `${hType} ${icao}`);
      ok = raw.toLowerCase().startsWith('ok');
      txt = ok ? cleanHoppie(raw.substring(2).trim()) : raw;
    }

    $('inR').style.display = 'block'; $('inRT').textContent = txt || '(vacio)';
    lastInfoResult = `${type.toUpperCase()} ${icao}: ${txt}`;
    const label = type === 'metar-hist' ? 'METAR HIST' : type.toUpperCase();
    addMsg('rx', { cls: 'in', type: 'INFO', badge: 'b-in', route: `SERVER ‚Üí ${$('cS').value.toUpperCase()}`, body: `${label} ${icao}:\n${txt}`, time: ts(), st: ok?'‚úì OK':'‚úó Error', ok });
    ss(ok?'ok':'err', ok ? `‚úì ${label} ${icao}` : `‚úó Error`);
    if (ok) notifySound();
  } catch(e) { $('inR').style.display = 'block'; $('inRT').textContent = `Error: ${e.message}`; ss('err', '‚úó Error de red'); errorSound(); }
  busy = false; $('inB').textContent = 'SOLICITAR'; updBtn();
}

// Strip Hoppie {type {content}} wrappers from inforeq responses
function cleanHoppie(txt) {
  if (!txt) return '';
  let s = txt.trim();
  // Pattern: {type {actual content}} ‚Üí extract actual content
  // Can be nested: {acars info {LEST 231300Z ...}} or {atis {LEST INFO A ...}}
  const m = s.match(/^\{[^{]*\{(.+)\}\s*\}$/s);
  if (m) return m[1].trim();
  // Single wrapper: {content}
  if (s.startsWith('{') && s.endsWith('}')) return s.substring(1, s.length - 1).trim();
  return s;
}

async function fwdInfo() {
  const to = $('fwdTo').value.trim().toUpperCase();
  if (!to || !lastInfoResult) { ss('err', '‚úó Indica callsign destino y solicita primero'); return; }
  if (!$('cL').value.trim() || !$('cS').value.trim()) { ss('err', '‚úó Configura logon y callsign'); return; }
  ss('snd', `Reenviando a ${to}...`);
  try {
    const raw = await hReq(to, 'telex', lastInfoResult);
    const ok = raw.toLowerCase().startsWith('ok');
    addMsg('tx', { cls: ok?'out':'erm', type: 'TELEX', badge: 'b-tx', route: `${$('cS').value.toUpperCase()} ‚Üí ${to}`, body: `[FWD] ${lastInfoResult}`, time: ts(), st: ok?'‚úì OK':`‚úó ${raw}`, ok });
    ss(ok?'ok':'err', ok ? `‚úì Reenviado a ${to}` : `‚úó ${raw}`);
    if (ok) notifySound(); else errorSound();
  } catch(e) { ss('err', `‚úó ${e.message}`); errorSound(); }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SEND CPDLC
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function sendCp() {
  if (busy) return;
  const to = $('cpD').value.trim().toUpperCase(), mid = $('cpId').value, resp = $('cpR').value, msg = $('cpM').value.trim().toUpperCase();
  if (!to || !msg) return;
  const pkt = `/data2/${mid}//${resp}/${msg}`;
  busy = true; const b = $('cpB'); b.disabled = true; b.className = 'bp cpc snd'; b.textContent = 'ENVIANDO...';
  ss('snd', `CPDLC ‚Üí ${to}...`);
  try {
    const raw = await hReq(to, 'cpdlc', pkt);
    const ok = raw.toLowerCase().startsWith('ok');
    addMsg('tx', { cls: ok?'cpm':'erm', type: 'CPDLC', badge: 'b-cp', route: `${$('cS').value.toUpperCase()} ‚Üí ${to}`, body: `[${resp}] ${msg}`, time: ts(), st: ok?'‚úì OK':`‚úó ${raw}`, ok });
    if (ok) { ss('ok', `‚úì CPDLC ‚Üí ${to}`); b.className = 'bp cpc ok'; b.textContent = '‚úì ENVIADO'; $('cpId').value = parseInt(mid) + 1; $('cpM').value = ''; }
    else { ss('err', `‚úó ${raw}`); b.className = 'bp cpc er'; b.textContent = '‚úó ERROR'; errorSound(); }
  } catch(e) {
    addMsg('tx', { cls: 'erm', type: 'CPDLC', badge: 'b-cp', route: `‚Üí ${to}`, body: `[${resp}] ${msg}`, time: ts(), st: `‚úó ${e.message}`, ok: false });
    ss('err', '‚úó Error de red'); b.className = 'bp cpc er'; b.textContent = '‚úó ERROR'; errorSound();
  }
  setTimeout(() => { busy = false; b.className = 'bp cpc'; b.textContent = 'ENVIAR CPDLC'; updBtn(); }, 1400);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CPDLC LOGON MANAGEMENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function acceptLogon(sender) {
  const mid = parseInt($('cpId').value);
  try {
    await hReq(sender, 'cpdlc', `/data2/${mid}//NE/LOGON ACCEPTED`);
    $('cpId').value = mid + 1;
    connStations.add(sender);
    updConn();
    addMsg('rx', { cls: 'logon', type: 'LOGON', badge: 'b-lo', route: `${sender} ‚Üî ${$('cS').value.toUpperCase()}`, body: `LOGON ACCEPTED ‚Äî ${sender} conectado`, time: ts(), st: '‚úì Conectado', ok: true });
    ss('ok', `‚úì ${sender} LOGON aceptado`);
    notifySound();
  } catch(e) { ss('err', `‚úó Error aceptando logon: ${e.message}`); errorSound(); }
  // Remove action buttons
  document.querySelectorAll(`.la-${CSS.escape(sender)}`).forEach(el => el.remove());
}

async function standbyLogon(sender) {
  const mid = parseInt($('cpId').value);
  try {
    await hReq(sender, 'cpdlc', `/data2/${mid}//NE/STANDBY`);
    $('cpId').value = mid + 1;
    addMsg('tx', { cls: 'cpm', type: 'CPDLC', badge: 'b-cp', route: `‚Üí ${sender}`, body: 'STANDBY', time: ts(), st: '‚úì OK', ok: true });
  } catch(e) {}
  document.querySelectorAll(`.la-${CSS.escape(sender)}`).forEach(el => el.remove());
}

async function rejectLogon(sender) {
  const mid = parseInt($('cpId').value);
  try {
    await hReq(sender, 'cpdlc', `/data2/${mid}//NE/UNABLE`);
    $('cpId').value = mid + 1;
    addMsg('tx', { cls: 'erm', type: 'CPDLC', badge: 'b-cp', route: `‚Üí ${sender}`, body: 'LOGON UNABLE', time: ts(), st: '‚úì Rechazado', ok: true });
  } catch(e) {}
  document.querySelectorAll(`.la-${CSS.escape(sender)}`).forEach(el => el.remove());
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  POLL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function doPoll() {
  if (!$('cL').value.trim() || !$('cS').value.trim()) { ss('err', '‚úó Configura logon y callsign'); return; }
  ss('snd', 'Consultando...');
  $('btnPoll').classList.add('on');
  try {
    const raw = await hReq('NONE', 'poll', '');
    const t = raw.trim();
    if (t.toLowerCase() === 'ok') { ss('ok', '‚úì Sin mensajes'); }
    else if (t.toLowerCase().startsWith('ok')) {
      const matches = [...t.matchAll(HPARSE)];
      if (!matches.length) { ss('ok', '‚úì Sin mensajes'); }
      else {
        let cnt = 0;
        for (const m of matches) {
          const inner = m[1];
          const parts = inner.split(' ');
          const sender = (parts[0]||'???').toUpperCase();
          const mtype = (parts[1]||'TELEX').toUpperCase();
          const cMatch = inner.match(/\{(.+)/s);
          let content = cMatch ? cMatch[1].replace(/\}$/, '').trim() : parts.slice(2).join(' ');
          content = cleanHoppie(content); // strip nested {type {content}} wrappers

          // Skip Hoppie system/error messages
          if (!sender || !content || content.toLowerCase().includes('send anything') || sender === 'SERVER') continue;

          // Detect CPDLC LOGON REQUEST
          const isLogonReq = mtype === 'CPDLC' && content.includes('REQUEST LOGON');
          const isCpdlc = mtype === 'CPDLC';

          if (isLogonReq) {
            addMsg('rx', {
              cls: 'logon', type: 'LOGON REQ', badge: 'b-lo',
              route: `${sender} ‚Üí ${$('cS').value.toUpperCase()}`,
              body: `REQUEST LOGON ‚Äî ${sender} solicita conexion CPDLC`,
              time: ts(), st: '‚è≥ Pendiente', ok: true,
              actions: sender
            });
          } else {
            addMsg('rx', {
              cls: isCpdlc ? 'cpm' : 'in',
              type: mtype, badge: isCpdlc ? 'b-cp' : 'b-tx',
              route: `${sender} ‚Üí ${$('cS').value.toUpperCase()}`,
              body: content, time: ts(), st: '‚úì Recibido', ok: true
            });
          }
          cnt++;
        }
        rxCount += cnt; updBdg();
        ss('ok', `‚úì ${cnt} mensaje(s)`);
        notifySound();
      }
    } else { ss('err', `‚úó ${t}`); errorSound(); }
  } catch(e) { ss('err', `‚úó Red: ${e.message}`); errorSound(); }
  $('btnPoll').classList.remove('on');
}

// ‚îÄ‚îÄ Auto-poll ‚îÄ‚îÄ
function toggleAutoPoll() {
  if (autoPoll) {
    clearInterval(autoPoll); autoPoll = null;
    $('btnAuto').classList.remove('poll-on');
    $('btnAuto').innerHTML = '‚è±';
    ss('ok', 'Auto-poll desactivado');
  } else {
    if (!$('cL').value.trim() || !$('cS').value.trim()) { ss('err', '‚úó Configura logon y callsign'); return; }
    const iv = Math.max(5, parseInt($('cI').value) || 20) * 1000;
    doPoll(); // immediate first poll
    autoPoll = setInterval(doPoll, iv);
    $('btnAuto').classList.add('poll-on');
    $('btnAuto').innerHTML = '<span class="dot-pulse"></span>';
    ss('ok', `Auto-poll cada ${iv/1000}s`);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MESSAGE MANAGEMENT (split RX/TX)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function addMsg(list, { cls, type, badge, route, body, time, st, ok, actions }) {
  const container = $(list === 'rx' ? 'rxL' : 'txL');
  const empty = $(list === 'rx' ? 'rxE' : 'txE');
  empty.style.display = 'none';

  const el = document.createElement('div');
  el.className = `me ${cls}`;

  let actionsHtml = '';
  if (actions) {
    const safe = actions.replace(/'/g, "\\'");
    actionsHtml = `<div class="logon-actions la-${esc(actions)}">
      <button class="la-accept" onclick="acceptLogon('${safe}')">‚úì ACCEPT</button>
      <button class="la-standby" onclick="standbyLogon('${safe}')">‚è≥ STANDBY</button>
      <button class="la-reject" onclick="rejectLogon('${safe}')">‚úó UNABLE</button>
    </div>`;
  }

  el.innerHTML = `<div class="mm"><span class="mr">${esc(route)}</span><span class="mb-t ${badge}">${esc(type)}</span></div>
    <div class="mt">${esc(time)}</div>
    <div class="mb">${esc(body)}</div>
    <div class="ms ${ok?'ok':'er'}">${esc(st)}</div>${actionsHtml}`;

  // Insert at top (after empty placeholder)
  if (container.children.length > 0) container.insertBefore(el, container.children[0].nextSibling || container.children[0]);
  else container.appendChild(el);

  saveList(list);

  // Discord: notificar mensajes RX siempre; TX solo manuales (los auto-OPS se notifican en sendOpsTx)
  if (typeof discordNotifyMsg === 'function') {
    const isAutoOps = body && typeof body === 'string' && body.startsWith('[OPS]');
    if (list === 'rx' || !isAutoOps) {
      discordNotifyMsg({ direction: list, cls, type, route, body, st, ok });
    }
  }
}

function clr(list) {
  const c = $(list === 'rx' ? 'rxL' : 'txL');
  c.querySelectorAll('.me').forEach(e => e.remove());
  $(list === 'rx' ? 'rxE' : 'txE').style.display = 'block';
  if (list === 'rx') { rxCount = 0; updBdg(); }
  try { localStorage.removeItem('an3_' + list); } catch(e) {}
}

function saveList(list) {
  try {
    const c = $(list === 'rx' ? 'rxL' : 'txL');
    const entries = [...c.querySelectorAll('.me')].map(e => e.outerHTML);
    localStorage.setItem('an3_' + list, JSON.stringify(entries.slice(0, 150)));
  } catch(e) {}
}

function loadList(list) {
  try {
    const entries = JSON.parse(localStorage.getItem('an3_' + list));
    if (entries && entries.length) {
      const c = $(list === 'rx' ? 'rxL' : 'txL');
      $(list === 'rx' ? 'rxE' : 'txE').style.display = 'none';
      entries.forEach(html => { const d = document.createElement('div'); d.innerHTML = html; c.appendChild(d.firstChild); });
    }
  } catch(e) {}
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  QUICK DISPATCH ‚Äî Traffic / WX / ATIS standalone
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let qdLastBody = '';

// ATC matching: local positions (TWR/GND/APP/DEL) match 4-char ICAO,
// regional positions (FSS/CTR) match 2-char country prefix
function matchAtc(atcs, icao) {
  const prefix4 = icao.substring(0, 4);
  const prefix2 = icao.substring(0, 2);
  return atcs.filter(a => {
    if (!a.callsign) return false;
    const cs = a.callsign.toUpperCase();
    // Skip GND and DEL
    if (cs.includes('_GND') || cs.includes('_DEL')) return false;
    // Local positions: exact ICAO match (APP/TWR/ATIS)
    if (cs.startsWith(prefix4)) return true;
    // Regional: only CTR/FSS (no towers from nearby airports)
    if ((cs.includes('_FSS') || cs.includes('_CTR')) && cs.startsWith(prefix2)) return true;
    return false;
  });
}

async function qdFetch(type) {
  const icao = $('qdIcao').value.trim().toUpperCase();
  const to = $('qdTo').value.trim().toUpperCase();
  if (!icao || icao.length < 3) { ss('err', '‚úó Introduce ICAO del aeropuerto'); return; }

  const proxy = $('cP').value.trim();
  $('qdResult').style.display = 'block';
  $('qdBody').textContent = '‚è≥ Cargando...';
  $('qdSend').className = 'dsp-send';
  $('qdSend').textContent = 'üì§ Enviar TELEX';
  qdLastBody = '';

  try {
    let title = '', body = '';

    if (type === 'traffic') {
      title = `üì° TR√ÅFICO ${icao}`;
      ss('snd', `Trafico IVAO ${icao}...`);
      const ivUrl = `${IVAO_WHAZZUP}?_t=${Date.now()}&_r=${Math.random().toString(36).substring(2,8)}`;
      const ivFetch = proxy ? `${proxy}${encodeURIComponent(ivUrl)}` : ivUrl;
      const ivResp = await fetch(ivFetch, { signal: AbortSignal.timeout(10000) });
      const ivData = await ivResp.json();
      const pilots = ivData.clients?.pilots || [];
      const arriving = pilots.filter(p => p.flightPlan?.arrivalId === icao);
      const departing = pilots.filter(p => p.flightPlan?.departureId === icao);
      const total = arriving.length + departing.length;
      const density = total === 0 ? 'NINGUNO' : total <= 3 ? 'BAJO' : total <= 8 ? 'MODERADO' : 'ALTO';

      body = `TRAFFIC ${icao} ‚Äî ${density} (${total})\n`;
      body += `ARR: ${arriving.length}  |  DEP: ${departing.length}\n`;
      if (arriving.length > 0) {
        body += `--- LLEGADAS ---\n`;
        for (const p of arriving.slice(0, 10)) {
          const cs = p.callsign || '???';
          const fp = p.flightPlan;
          const from = fp?.departureId || '????';
          const ac = fp?.aircraftId || '????';
          const gs = p.lastTrack?.groundSpeed || 0;
          const alt = p.lastTrack?.altitude || 0;
          const st = p.lastTrack?.state || '';
          body += `${cs} ${ac} FROM ${from} GS${gs} FL${Math.round(alt/100)} ${st}\n`;
        }
        if (arriving.length > 10) body += `... y ${arriving.length - 10} mas\n`;
      }
      if (departing.length > 0) {
        body += `--- SALIDAS ---\n`;
        for (const p of departing.slice(0, 10)) {
          const cs = p.callsign || '???';
          const fp = p.flightPlan;
          const to2 = fp?.arrivalId || '????';
          const ac = fp?.aircraftId || '????';
          const st = p.lastTrack?.state || '';
          body += `${cs} ${ac} TO ${to2} ${st}\n`;
        }
        if (departing.length > 10) body += `... y ${departing.length - 10} mas\n`;
      }
      // ATC online (local + regional FSS/CTR)
      const atcs = ivData.clients?.atcs || [];
      const destAtc = matchAtc(atcs, icao);
      if (destAtc.length > 0) {
        body += `--- ATC ONLINE ---\n`;
        for (const a of destAtc) body += `${a.callsign}\n`;
      } else {
        body += `NO ATC ONLINE EN ${icao}\n`;
      }

    } else if (type === 'metar') {
      title = `üå§Ô∏è METAR ${icao}`;
      ss('snd', `METAR ${icao}...`);
      // Only current METAR (hours=1)
      try {
        const mUrl = `${METAR_API}?ids=${icao}&format=raw&hours=1`;
        const mFetch = proxy ? `${proxy}${encodeURIComponent(mUrl)}` : mUrl;
        const mResp = await fetch(mFetch, { signal: AbortSignal.timeout(6000) });
        const mTxt = await mResp.text();
        body = mTxt.trim().split('\n')[0] || 'No METAR available';
      } catch(e) {
        const raw = await hReq('SERVER', 'inforeq', `METAR ${icao}`);
        body = raw.toLowerCase().startsWith('ok') ? raw.substring(2).trim() : raw;
      }

    } else if (type === 'taf') {
      title = `üìã TAF ${icao}`;
      ss('snd', `TAF ${icao}...`);
      try {
        const tUrl = `https://aviationweather.gov/api/data/taf?ids=${icao}&format=raw&hours=6`;
        const tFetch = proxy ? `${proxy}${encodeURIComponent(tUrl)}` : tUrl;
        const tResp = await fetch(tFetch, { signal: AbortSignal.timeout(6000) });
        const tTxt = await tResp.text();
        body = tTxt.trim() || 'No TAF available';
      } catch(e) {
        const raw = await hReq('SERVER', 'inforeq', `TAF ${icao}`);
        body = raw.toLowerCase().startsWith('ok') ? raw.substring(2).trim() : raw;
      }

    } else if (type === 'atis-ivao') {
      title = `üìª ATIS IVAO ${icao}`;
      ss('snd', `ATIS IVAO ${icao}...`);
      const raw = await hReq('SERVER', 'inforeq', `IVAOATIS ${icao}`);
      body = raw.toLowerCase().startsWith('ok') ? raw.substring(2).trim() : raw;

    } else if (type === 'atis-vatsim') {
      title = `üìª ATIS VATSIM ${icao}`;
      ss('snd', `ATIS VATSIM ${icao}...`);
      const raw = await hReq('SERVER', 'inforeq', `VATATIS ${icao}`);
      body = raw.toLowerCase().startsWith('ok') ? raw.substring(2).trim() : raw;
    }

    $('qdTitle').innerHTML = `<span class="ico">${title.substring(0,2)}</span> ${esc(title.substring(2))}`;
    $('qdBody').textContent = body;
    qdLastBody = body;
    ss('ok', `‚úì ${title}`);
    notifySound();

  } catch(e) {
    $('qdBody').textContent = `Error: ${e.message}`;
    ss('err', `‚úó ${e.message}`);
    errorSound();
  }
}

async function qdSendTelex() {
  const to = $('qdTo').value.trim().toUpperCase();
  if (!to) { ss('err', '‚úó Indica callsign destino'); return; }
  if (!qdLastBody) { ss('err', '‚úó Primero genera un resultado'); return; }
  if (!$('cL').value.trim() || !$('cS').value.trim()) { ss('err', '‚úó Configura logon y callsign'); return; }

  const btn = $('qdSend');
  btn.textContent = '‚è≥ Enviando...';
  const chunks = splitMsg(qdLastBody, 480);
  let allOk = true;

  for (let i = 0; i < chunks.length; i++) {
    try {
      const prefix = chunks.length > 1 ? `[${i+1}/${chunks.length}] ` : '';
      const raw = await hReq(to, 'telex', prefix + chunks[i]);
      if (!raw.toLowerCase().startsWith('ok')) { allOk = false; break; }
      addMsg('tx', { cls: 'out', type: 'TELEX', badge: 'b-tx', route: `${$('cS').value.toUpperCase()} ‚Üí ${to}`, body: `[QD] ${prefix}${chunks[i]}`, time: ts(), st: '‚úì OK', ok: true });
      if (i < chunks.length - 1) await new Promise(r => setTimeout(r, 400));
    } catch(e) { allOk = false; break; }
  }

  if (allOk) {
    btn.textContent = '‚úì Enviado'; btn.className = 'dsp-send sent';
    ss('ok', `‚úì TELEX ‚Üí ${to}`);
  } else {
    btn.textContent = '‚úó Error'; btn.className = 'dsp-send fail';
    ss('err', '‚úó Error en env√≠o'); errorSound();
    setTimeout(() => { btn.textContent = 'üì§ Enviar TELEX'; btn.className = 'dsp-send'; }, 2000);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DISPATCH ‚Äî SimBrief + IVAO + Weather
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const SIMBRIEF_API = 'https://www.simbrief.com/api/xml.fetcher.php';
const IVAO_WHAZZUP = 'https://api.ivao.aero/v2/tracker/whazzup';
const METAR_API = 'https://aviationweather.gov/api/data/metar';
const SIGMET_API = 'https://aviationweather.gov/api/data/airsigmet';
const PIREP_API = 'https://aviationweather.gov/api/data/pirep';
let dspMessages = []; // {id, label, icon, body, sent}
let dspOFP = null;

async function fetchDispatch() {
  const sbUser = $('dspSb').value.trim();
  const dest = $('dspTo').value.trim().toUpperCase();
  if (!sbUser) { ss('err', '‚úó Introduce usuario/ID de SimBrief'); return; }
  if (!dest) { ss('err', '‚úó Introduce callsign destino'); return; }
  if (!$('cL').value.trim() || !$('cS').value.trim()) { ss('err', '‚úó Configura logon y callsign primero'); return; }

  $('dspFetch').disabled = true;
  $('dspLoad').style.display = 'block';
  $('dspSum').style.display = 'none';
  $('dspCards').style.display = 'none';
  $('dspAll').style.display = 'none';
  dspMessages = [];
  ss('snd', 'Obteniendo OFP...');

  try {
    // ‚îÄ‚îÄ 1. Fetch SimBrief OFP ‚îÄ‚îÄ
    const isNumeric = /^\d+$/.test(sbUser);
    const sbParam = isNumeric ? `userid=${sbUser}` : `username=${encodeURIComponent(sbUser)}`;
    const proxy = $('cP').value.trim();
    const sbUrl = `${SIMBRIEF_API}?${sbParam}&json=1`;
    const sbFetch = proxy ? `${proxy}${encodeURIComponent(sbUrl)}` : sbUrl;
    const sbResp = await fetch(sbFetch);
    if (!sbResp.ok) throw new Error(`SimBrief HTTP ${sbResp.status}`);
    dspOFP = await sbResp.json();

    if (dspOFP.fetch && dspOFP.fetch.status === 'Error') {
      throw new Error(dspOFP.fetch.result || 'OFP no encontrado');
    }

    const o = dspOFP;
    const orig = o.origin?.icao_code || '????';
    const dest_icao = o.destination?.icao_code || '????';
    const altn = o.alternate?.icao_code || '????';
    const acType = o.aircraft?.icaocode || o.general?.icao_airline || '????';
    const fltNum = (o.general?.icao_airline||'') + (o.general?.flight_number||'');
    const ci = o.general?.costindex || 'N/A';
    const pax = o.weights?.pax_count || '0';
    const cargo = o.weights?.cargo || '0';
    const route = o.general?.route || '';

    // Weights (in kg or lbs depending on OFP units)
    const unit = o.params?.units === 'lbs' ? 'LBS' : 'KG';
    const oew = o.weights?.oew || '0';
    const zfw = o.weights?.est_zfw || '0';
    const tow = o.weights?.est_tow || '0';
    const ldw = o.weights?.est_ldw || '0';
    const payload = o.weights?.payload || '0';

    // Fuel
    const fuelBlock = o.fuel?.plan_ramp || '0';
    const fuelTrip = o.fuel?.enroute_burn || '0';
    const fuelRes = o.fuel?.reserve || '0';
    const fuelAltn = o.fuel?.alternate_burn || '0';
    const fuelCont = o.fuel?.contingency || '0';
    const fuelExtra = o.fuel?.extra || '0';
    const fuelMinTO = o.fuel?.min_takeoff || '0';

    // Times
    const timeEnr = o.times?.est_time_enroute ? formatSeconds(o.times.est_time_enroute) : 'N/A';

    // ‚îÄ‚îÄ Show summary ‚îÄ‚îÄ
    $('dspSumRows').innerHTML = [
      r('Vuelo', `${fltNum} ¬∑ ${acType}`),
      r('Ruta', `${orig} ‚Üí ${dest_icao} (ALT: ${altn})`),
      r('Tiempo en ruta', timeEnr),
      r('CI', ci),
      r('PAX / Cargo', `${pax} pax ¬∑ ${Number(cargo).toLocaleString()} ${unit}`),
      r('TOW / LDW', `${Number(tow).toLocaleString()} / ${Number(ldw).toLocaleString()} ${unit}`),
      r('Block Fuel', `${Number(fuelBlock).toLocaleString()} ${unit}`),
    ].join('');
    $('dspSum').style.display = 'block';

    // ‚îÄ‚îÄ 2. Build LOADSHEET message ‚îÄ‚îÄ
    const loadsheet = [
      `=== LOADSHEET ${fltNum} ===`,
      `ACFT: ${acType}  CI: ${ci}`,
      `${orig}/${dest_icao}  ALT: ${altn}`,
      `PAX: ${pax}  CARGO: ${Number(cargo).toLocaleString()}${unit}`,
      `---`,
      `OEW:     ${pad(oew,8)} ${unit}`,
      `PAYLOAD: ${pad(payload,8)} ${unit}`,
      `ZFW:     ${pad(zfw,8)} ${unit}`,
      `TOW:     ${pad(tow,8)} ${unit}`,
      `LDW:     ${pad(ldw,8)} ${unit}`,
      `--- FUEL ---`,
      `BLOCK:   ${pad(fuelBlock,8)} ${unit}`,
      `TRIP:    ${pad(fuelTrip,8)} ${unit}`,
      `CONT:    ${pad(fuelCont,8)} ${unit}`,
      `ALTN:    ${pad(fuelAltn,8)} ${unit}`,
      `RESERVE: ${pad(fuelRes,8)} ${unit}`,
      `EXTRA:   ${pad(fuelExtra,8)} ${unit}`,
      `MIN T/O: ${pad(fuelMinTO,8)} ${unit}`,
    ].join('\n');
    dspMessages.push({ id: 'load', label: 'LOADSHEET', icon: 'üì¶', body: loadsheet, sent: false });

    // ‚îÄ‚îÄ 3. Build WX BRIEFING message ‚îÄ‚îÄ
    const origMetar = o.weather?.orig_metar || 'N/A';
    const destMetar = o.weather?.dest_metar || 'N/A';
    const altnMetar = o.weather?.altn_metar || 'N/A';
    const origTaf = o.weather?.orig_taf || '';
    const destTaf = o.weather?.dest_taf || '';
    const wxBrief = [
      `=== WX BRIEFING ${fltNum} ===`,
      `DEP ${orig} METAR:`,
      origMetar,
      origTaf ? `TAF: ${origTaf.substring(0,200)}` : '',
      ``,
      `ARR ${dest_icao} METAR:`,
      destMetar,
      destTaf ? `TAF: ${destTaf.substring(0,200)}` : '',
      ``,
      `ALT ${altn} METAR:`,
      altnMetar,
    ].filter(Boolean).join('\n');
    dspMessages.push({ id: 'wx', label: 'WX BRIEFING', icon: 'üå§Ô∏è', body: wxBrief, sent: false });

    // ‚îÄ‚îÄ 4. Build WX EN-ROUTE from navlog ‚îÄ‚îÄ
    ss('snd', 'WX en-ruta...');
    let enrouteWx = `=== WX EN-ROUTE ${orig}-${dest_icao} ===\n`;
    try {
      // Only destination METAR (no intermediate airport METARs)
      try {
        const mUrl = `${METAR_API}?ids=${dest_icao}&format=raw&hours=1`;
        const mFetch = proxy ? `${proxy}${encodeURIComponent(mUrl)}` : mUrl;
        const mResp = await fetch(mFetch, { signal: AbortSignal.timeout(8000) });
        const mTxt = await mResp.text();
        if (mTxt.trim()) {
          enrouteWx += `DEST ${dest_icao} METAR:\n${mTxt.trim().split('\n')[0]}\n`;
        } else {
          enrouteWx += `DEST ${dest_icao}: No METAR available\n`;
        }
      } catch(e) {
        try {
          const raw = await hReq('SERVER', 'inforeq', `METAR ${dest_icao}`);
          if (raw.toLowerCase().startsWith('ok')) {
            enrouteWx += `DEST ${dest_icao} METAR:\n${raw.substring(2).trim()}\n`;
          }
        } catch(e2) {
          enrouteWx += `DEST ${dest_icao}: Unable to fetch METAR\n`;
        }
      }

      // CTR/FSS on route + destination ATC (APP/TWR)
      try {
        const ivUrl = `${IVAO_WHAZZUP}?_t=${Date.now()}&_r=${Math.random().toString(36).substring(2,8)}`;
        const ivFetch = proxy ? `${proxy}${encodeURIComponent(ivUrl)}` : ivUrl;
        const ivResp = await fetch(ivFetch, { signal: AbortSignal.timeout(10000) });
        const ivData = await ivResp.json();
        const atcs = ivData.clients?.atcs || [];
        const destPrefix = dest_icao.substring(0, 4);
        const origPrefix = orig.substring(0, 2);
        const destPfx2 = dest_icao.substring(0, 2);

        // En route: only CTR/FSS matching dep or arr country prefix
        const ctrFss = atcs.filter(a => {
          if (!a.callsign) return false;
          const cs = a.callsign.toUpperCase();
          if (!cs.includes('_CTR') && !cs.includes('_FSS')) return false;
          const p2 = cs.substring(0, 2);
          return p2 === origPrefix || p2 === destPfx2;
        });

        // Destination: APP/TWR/ATIS (not GND/DEL)
        const destAtc = atcs.filter(a => {
          if (!a.callsign) return false;
          const cs = a.callsign.toUpperCase();
          if (!cs.startsWith(destPrefix)) return false;
          return !cs.includes('_GND') && !cs.includes('_DEL');
        });

        if (ctrFss.length) {
          enrouteWx += `--- CTR/FSS EN RUTA ---\n`;
          for (const a of ctrFss.slice(0, 10)) enrouteWx += `${a.callsign}\n`;
        }
        if (destAtc.length) {
          enrouteWx += `--- ATC DESTINO ${dest_icao} ---\n`;
          for (const a of destAtc) enrouteWx += `${a.callsign}\n`;
        }
        if (!ctrFss.length && !destAtc.length) {
          enrouteWx += `NO ATC EN RUTA NI DESTINO\n`;
        }
      } catch(e) {}

    } catch(e) {
      enrouteWx += `Error: ${e.message}`;
    }
    dspMessages.push({ id: 'wxenr', label: 'WX EN-ROUTE', icon: 'üõ´', body: enrouteWx, sent: false });

    // ‚îÄ‚îÄ 5. Fetch IVAO traffic for destination ‚îÄ‚îÄ
    ss('snd', 'Trafico IVAO...');
    let trafficMsg = `=== TRAFFIC ${dest_icao} ===\n`;
    try {
      const ivUrl = `${IVAO_WHAZZUP}?_t=${Date.now()}&_r=${Math.random().toString(36).substring(2,8)}`;
      const ivFetch = proxy ? `${proxy}${encodeURIComponent(ivUrl)}` : ivUrl;
      const ivResp = await fetch(ivFetch, { signal: AbortSignal.timeout(10000) });
      const ivData = await ivResp.json();
      const pilots = ivData.clients?.pilots || [];
      const arriving = pilots.filter(p => p.flightPlan?.arrivalId === dest_icao);
      const departing = pilots.filter(p => p.flightPlan?.departureId === dest_icao);

      const arrCount = arriving.length;
      const depCount = departing.length;
      const total = arrCount + depCount;
      const density = total === 0 ? 'NINGUNO' : total <= 3 ? 'BAJO' : total <= 8 ? 'MODERADO' : 'ALTO';

      trafficMsg += `TRAFICO ${density} (${total} total)\n`;
      trafficMsg += `LLEGADAS: ${arrCount}  |  SALIDAS: ${depCount}\n`;
      if (arrCount > 0) {
        trafficMsg += `--- ARR ---\n`;
        for (const p of arriving.slice(0, 8)) {
          const cs = p.callsign || '???';
          const fp = p.flightPlan;
          const from = fp?.departureId || '????';
          const ac = fp?.aircraftId || '????';
          const gs = p.lastTrack?.groundSpeed || 0;
          const alt = p.lastTrack?.altitude || 0;
          trafficMsg += `${cs} ${ac} FROM ${from} GS${gs} FL${Math.round(alt/100)}\n`;
        }
      }
      if (depCount > 0) {
        trafficMsg += `--- DEP ---\n`;
        for (const p of departing.slice(0, 8)) {
          const cs = p.callsign || '???';
          const fp = p.flightPlan;
          const to = fp?.arrivalId || '????';
          const ac = fp?.aircraftId || '????';
          trafficMsg += `${cs} ${ac} TO ${to}\n`;
        }
      }
      // Also check ATC online for destination (local + regional FSS/CTR)
      const atcs = ivData.clients?.atcs || [];
      const destAtc = matchAtc(atcs, dest_icao);
      if (destAtc.length > 0) {
        trafficMsg += `--- ATC ONLINE ---\n`;
        for (const a of destAtc) {
          trafficMsg += `${a.callsign}\n`;
        }
      } else {
        trafficMsg += `ATC: NO HAY ATC ONLINE EN ${dest_icao}\n`;
      }
    } catch(e) {
      trafficMsg += `Error obteniendo trafico: ${e.message}`;
    }
    dspMessages.push({ id: 'traf', label: 'TRAFFIC', icon: 'üì°', body: trafficMsg, sent: false });

    // ‚îÄ‚îÄ Render cards ‚îÄ‚îÄ
    renderDispatchCards();
    $('dspAll').style.display = 'block';
    ss('ok', `‚úì Dispatch generado ‚Äî ${dspMessages.length} mensajes`);
    notifySound();

  } catch(e) {
    ss('err', `‚úó SimBrief: ${e.message}`);
    errorSound();
  }
  $('dspLoad').style.display = 'none';
  $('dspFetch').disabled = false;
}

function renderDispatchCards() {
  const c = $('dspCards');
  c.innerHTML = '';
  c.style.display = 'flex';
  for (const m of dspMessages) {
    const card = document.createElement('div');
    card.className = 'dsp-card';
    card.id = `dsp-${m.id}`;
    card.innerHTML = `
      <h4><span class="ico">${m.icon}</span> ${esc(m.label)}</h4>
      <pre>${esc(m.body)}</pre>
      <button class="dsp-send" id="dsb-${m.id}" onclick="sendDispatchMsg('${m.id}')">üì§ Enviar TELEX</button>`;
    c.appendChild(card);
  }
}

async function sendDispatchMsg(id) {
  const m = dspMessages.find(x => x.id === id);
  if (!m || m.sent) return;
  const to = $('dspTo').value.trim().toUpperCase();
  if (!to) { ss('err', '‚úó Indica callsign destino'); return; }
  const btn = $(`dsb-${id}`);
  btn.textContent = '‚è≥ Enviando...';

  // TELEX max 500 chars ‚Äî split if needed
  const chunks = splitMsg(m.body, 480);
  let allOk = true;
  for (let i = 0; i < chunks.length; i++) {
    try {
      const prefix = chunks.length > 1 ? `[${m.label} ${i+1}/${chunks.length}]\n` : '';
      const raw = await hReq(to, 'telex', prefix + chunks[i]);
      const ok = raw.toLowerCase().startsWith('ok');
      if (!ok) { allOk = false; break; }
      addMsg('tx', { cls: 'out', type: 'TELEX', badge: 'b-tx', route: `${$('cS').value.toUpperCase()} ‚Üí ${to}`, body: `[DSP:${m.label}] ${prefix}${chunks[i]}`, time: ts(), st: '‚úì OK', ok: true });
    } catch(e) { allOk = false; break; }
  }

  if (allOk) {
    m.sent = true;
    btn.textContent = '‚úì Enviado';
    btn.className = 'dsp-send sent';
    ss('ok', `‚úì ${m.label} ‚Üí ${to}`);
  } else {
    btn.textContent = '‚úó Error';
    btn.className = 'dsp-send fail';
    ss('err', `‚úó Error enviando ${m.label}`);
    errorSound();
    setTimeout(() => { btn.textContent = 'üì§ Enviar TELEX'; btn.className = 'dsp-send'; }, 2000);
  }
}

async function sendAllDispatch() {
  const to = $('dspTo').value.trim().toUpperCase();
  if (!to) { ss('err', '‚úó Indica callsign destino'); return; }
  $('dspAll').disabled = true; $('dspAll').textContent = '‚è≥ ENVIANDO...';
  let ok = 0, fail = 0;
  for (const m of dspMessages) {
    if (!m.sent) {
      await sendDispatchMsg(m.id);
      if (m.sent) ok++; else fail++;
      await new Promise(r => setTimeout(r, 600)); // rate limiting
    }
  }
  $('dspAll').disabled = false;
  $('dspAll').textContent = fail ? `‚úó ${ok} enviados, ${fail} fallidos` : `‚úì ${ok} mensajes enviados`;
  setTimeout(() => { $('dspAll').textContent = 'üì§ ENVIAR TODOS LOS TELEX'; }, 3000);
}

// Helpers dispatch
function r(k, v) { return `<div class="row"><span>${k}</span><span class="val">${v}</span></div>`; }
function pad(n, w) { return String(Number(n).toLocaleString()).padStart(w); }
function formatSeconds(s) { const h = Math.floor(s/3600); const m = Math.floor((s%3600)/60); return `${h}h${String(m).padStart(2,'0')}m`; }
function splitMsg(txt, max) {
  if (txt.length <= max) return [txt];
  const chunks = [];
  let pos = 0;
  while (pos < txt.length) {
    let end = Math.min(pos + max, txt.length);
    if (end < txt.length) { const nl = txt.lastIndexOf('\n', end); if (nl > pos + 50) end = nl; }
    chunks.push(txt.substring(pos, end).trim());
    pos = end;
  }
  return chunks;
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MANUAL PAX CONNECTIONS & CREW INFO DISPATCH
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let cxLastBody = '';

function manualPaxConn() {
  const icao = $('cxIcao').value.trim().toUpperCase();
  if (!icao || icao.length !== 4) { ss('err', '‚úó Introduce ICAO destino (4 chars)'); return; }
  const msg = genPaxConnections(icao);
  if (!msg) { ss('err', '‚úó Sin conexiones generadas'); return; }
  $('cxResult').style.display = 'block';
  $('cxTitle').innerHTML = `<span class="ico">üë•</span> CONEXIONES PAX ${esc(icao)}`;
  $('cxBody').textContent = msg;
  $('cxSend').textContent = 'üì§ Enviar TELEX';
  $('cxSend').className = 'dsp-send';
  cxLastBody = msg;
  ss('ok', `‚úì Conexiones PAX generadas para ${icao}`);
  notifySound();
}

function manualCrewInfo() {
  const icao = $('cxIcao').value.trim().toUpperCase();
  const to = $('cxTo').value.trim().toUpperCase();
  if (!icao || icao.length !== 4) { ss('err', '‚úó Introduce ICAO destino (4 chars)'); return; }
  // Build a minimal flight object for crew gen
  const mockFlt = { callsign: to || 'NBV???', dep: '????', arr: icao, aircraft: '???', enrouteStart: 0, firstSeen: 0 };
  const crewMsg = genCrewInfo(mockFlt);
  if (!crewMsg) { ss('err', '‚úó Sin info crew generada'); return; }
  const body = `=== CREW ${to || 'NBV'} ===\n${icao}\n${crewMsg}`;
  $('cxResult').style.display = 'block';
  $('cxTitle').innerHTML = `<span class="ico">üë®‚Äç‚úàÔ∏è</span> CREW INFO ${esc(icao)}`;
  $('cxBody').textContent = body;
  $('cxSend').textContent = 'üì§ Enviar TELEX';
  $('cxSend').className = 'dsp-send';
  cxLastBody = body;
  ss('ok', `‚úì Crew info generada para ${icao}`);
  notifySound();
}

async function cxSendTelex() {
  const to = $('cxTo').value.trim().toUpperCase();
  if (!to) { ss('err', '‚úó Sin destinatario'); return; }
  if (!cxLastBody) { ss('err', '‚úó Genera primero'); return; }
  if (!$('cL').value.trim() || !$('cS').value.trim()) { ss('err', '‚úó Configura logon y callsign'); return; }
  const btn = $('cxSend');
  btn.textContent = '‚è≥ Enviando...';
  const chunks = splitMsg(cxLastBody, 480);
  let allOk = true;
  for (let i = 0; i < chunks.length; i++) {
    try {
      const pfx = chunks.length > 1 ? `[${i+1}/${chunks.length}] ` : '';
      const raw = await hReq(to, 'telex', pfx + chunks[i]);
      if (!raw.toLowerCase().startsWith('ok')) { allOk = false; break; }
      addMsg('tx', { cls:'out', type:'TELEX', badge:'b-tx', route:`${$('cS').value.toUpperCase()} ‚Üí ${to}`, body:`[CX] ${pfx}${chunks[i]}`, time:ts(), st:'‚úì OK', ok:true });
      if (i < chunks.length - 1) await new Promise(r => setTimeout(r, 400));
    } catch(e) { allOk = false; break; }
  }
  if (allOk) { btn.textContent = '‚úì Enviado'; btn.className = 'dsp-send sent'; ss('ok', `‚úì ‚Üí ${to}`); }
  else { btn.textContent = '‚úó Error'; btn.className = 'dsp-send fail'; ss('err', '‚úó Error env√≠o'); errorSound(); setTimeout(() => { btn.textContent = 'üì§ Enviar TELEX'; btn.className = 'dsp-send'; }, 2000); }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ROUTE INFO ‚Äî ATCs en ruta, SIGMETs, PIREPs, METAR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let riLastBody = '';

function haversineNm(lat1, lon1, lat2, lon2) {
  const R = 3440.065;
  const dLat = (lat2-lat1)*Math.PI/180, dLon = (lon2-lon1)*Math.PI/180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
function bearingTo(lat1, lon1, lat2, lon2) {
  const dLon = (lon2-lon1)*Math.PI/180;
  const y = Math.sin(dLon)*Math.cos(lat2*Math.PI/180);
  const x = Math.cos(lat1*Math.PI/180)*Math.sin(lat2*Math.PI/180) - Math.sin(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.cos(dLon);
  return ((Math.atan2(y,x)*180/Math.PI)+360)%360;
}
function isAhead(pLat, pLon, hdg, tLat, tLon) {
  let diff = Math.abs(bearingTo(pLat,pLon,tLat,tLon) - hdg);
  if (diff > 180) diff = 360 - diff;
  return diff < 100;
}
function fmtFreq(f) {
  if (!f) return '---';
  if (f > 100000) return (f/1000000).toFixed(3);
  if (f > 100) return (f/1000).toFixed(3);
  return String(f);
}
function atcTypeOf(cs) {
  if (cs.includes('_DEL')) return 'DEL'; if (cs.includes('_GND')) return 'GND';
  if (cs.includes('_TWR')) return 'TWR'; if (cs.includes('_APP')||cs.includes('_DEP')) return 'APP';
  if (cs.includes('_CTR')) return 'CTR'; if (cs.includes('_FSS')) return 'FSS';
  return 'ATC';
}

async function fetchRouteInfo() {
  const pilotCs = $('riCs').value.trim().toUpperCase();
  if (!pilotCs) { ss('err', '‚úó Introduce callsign del piloto en IVAO'); return; }

  $('riResult').style.display = 'block';
  $('riBody').textContent = '‚è≥ Buscando piloto en IVAO...';
  $('riSend').className = 'dsp-send';
  $('riSend').textContent = 'üì§ Enviar TELEX';
  riLastBody = '';
  ss('snd', `Route Info para ${pilotCs}...`);

  try {
    const prx = $('cP').value.trim();
    const resp = await ivaoFetch();
    const data = await resp.json();
    const pilots = data.clients?.pilots || [];
    const pilot = pilots.find(p => p.callsign && p.callsign.toUpperCase() === pilotCs);

    if (!pilot) { $('riBody').textContent = `Piloto ${pilotCs} no encontrado en IVAO`; ss('err', `‚úó ${pilotCs} no online`); return; }

    const pLat = pilot.lastTrack?.latitude || 0;
    const pLon = pilot.lastTrack?.longitude || 0;
    const hdg = pilot.lastTrack?.heading || pilot.lastTrack?.transponderHeading || 0;
    const alt = pilot.lastTrack?.altitude || 0;
    const gs = pilot.lastTrack?.groundSpeed || 0;
    const fp = pilot.flightPlan;
    const dep = fp?.departureId || '????', arr = fp?.arrivalId || '????';
    const RADIUS = 400;

    let body = `=== ROUTE INFO ${pilotCs} ===\n${dep}‚Üí${arr} FL${Math.round(alt/100)} GS${gs} HDG${Math.round(hdg)}\n`;

    // ‚îÄ‚îÄ ATCs ‚îÄ‚îÄ
    $('riBody').textContent = '... Buscando ATCs en ruta...';
    const atcs = data.clients?.atcs || [];
    const enrAtc = [], dstAtc = [];
    const arrPfx = arr.substring(0, 4);
    for (const a of atcs) {
      if (!a.callsign || !a.lastTrack) continue;
      const aLat = a.lastTrack.latitude, aLon = a.lastTrack.longitude;
      if (!aLat && !aLon) continue;
      const type = atcTypeOf(a.callsign.toUpperCase());
      if (type === 'GND' || type === 'DEL') continue;
      const dist = haversineNm(pLat, pLon, aLat, aLon);
      if (dist > RADIUS) continue;
      const ahead = isAhead(pLat, pLon, hdg, aLat, aLon);
      const freq = a.atcSession?.frequency || a.frequency || null;
      const entry = { cs: a.callsign, type, freq: fmtFreq(freq), dist: Math.round(dist), ahead };
      const csUp = a.callsign.toUpperCase();
      if (arrPfx && arrPfx !== '????' && csUp.startsWith(arrPfx)) {
        dstAtc.push(entry);
      } else if (type === 'CTR' || type === 'FSS') {
        if (ahead || dist <= 200) enrAtc.push(entry);
      }
    }
    enrAtc.sort((a, b) => (b.ahead - a.ahead) || (a.dist - b.dist));
    dstAtc.sort((a, b) => a.dist - b.dist);
    const relAtc = [...enrAtc, ...dstAtc];
    if (enrAtc.length) {
      body += `--- ATC EN RUTA (CTR/FSS) ---\n`;
      for (const a of enrAtc.slice(0,8)) body += `${a.cs} ${a.freq} ${a.type} ${a.dist}nm\n`;
    }
    if (dstAtc.length) {
      body += `--- ATC DESTINO ${arr} ---\n`;
      for (const a of dstAtc.slice(0,6)) body += `${a.cs} ${a.freq} ${a.type}\n`;
    }
    if (!relAtc.length) {
      body += `NO ATC ACTIVO EN RUTA/DESTINO\n`;
    }

    // ‚îÄ‚îÄ SIGMETs ‚îÄ‚îÄ
    $('riBody').textContent = '‚è≥ Consultando SIGMETs...';
    try {
      const sResp = await fetch(proxy(`${SIGMET_API}?format=json`), { signal: AbortSignal.timeout(8000) });
      const sData = await sResp.json();
      const relSig = [];
      if (Array.isArray(sData)) {
        for (const s of sData) {
          const sLat = s.lat || s.coords?.[0]?.lat, sLon = s.lon || s.coords?.[0]?.lon;
          if (sLat && sLon) {
            const dist = haversineNm(pLat, pLon, sLat, sLon);
            if (dist < RADIUS) relSig.push({ raw: (s.rawAirSigmet||s.rawSigmet||`${s.hazard||'?'} ${s.severity||''}`).substring(0,140), dist: Math.round(dist) });
          } else {
            const icao = s.icaoId || '';
            if (icao.startsWith(dep.substring(0,2)) || icao.startsWith(arr.substring(0,2)))
              relSig.push({ raw: (s.rawAirSigmet||s.rawSigmet||'').substring(0,140), dist: null });
          }
        }
      }
      if (relSig.length) { body += `--- SIGMET ---\n`; for (const s of relSig.slice(0,5)) body += `${s.raw}${s.dist?` (${s.dist}nm)`:''}\n`; }
    } catch(e) {}

    // ‚îÄ‚îÄ PIREPs ‚îÄ‚îÄ
    $('riBody').textContent = '‚è≥ Consultando PIREPs...';
    try {
      const pResp = await fetch(proxy(`${PIREP_API}?format=json&age=4`), { signal: AbortSignal.timeout(8000) });
      const pData = await pResp.json();
      const relP = [];
      if (Array.isArray(pData)) {
        for (const p of pData) {
          const prLat = p.lat||p.latitude, prLon = p.lon||p.longitude;
          if (!prLat || !prLon) continue;
          const dist = haversineNm(pLat, pLon, prLat, prLon);
          if (dist > RADIUS) continue;
          const turb = p.turbulenceCondition||p.tbInt||p.turbulence||'';
          const ice = p.icingCondition||p.icInt||p.icing||'';
          if (!turb && !ice) continue;
          relP.push({ raw: (p.rawOb||`FL${p.altitude||'?'} TURB:${turb||'NIL'} ICE:${ice||'NIL'}`).substring(0,140), dist: Math.round(dist) });
        }
      }
      if (relP.length) { body += `--- PIREP ---\n`; for (const p of relP.slice(0,5)) body += `${p.raw} (${p.dist}nm)\n`; }
    } catch(e) {}

    // ‚îÄ‚îÄ METAR destino ‚îÄ‚îÄ
    if (arr && arr !== '????') {
      try {
        const mR = await fetch(proxy(`${METAR_API}?ids=${arr}&format=raw&hours=1`), { signal: AbortSignal.timeout(6000) });
        const mT = await mR.text();
        if (mT.trim()) {
          const firstM = mT.trim().split('\n')[0];
          body += `--- METAR DESTINO ---\n${firstM}\n`;
        }
      } catch(e) {}
    }

    // Parking stand
    const stand = genParkingStand(arr);
    if (stand) body += `--- PARKING ASIGNADO ---\n${arr}: ${stand}\n`;

    $('riTitle').innerHTML = `<span class="ico">üó∫Ô∏è</span> ROUTE INFO ${esc(pilotCs)}`;
    $('riBody').textContent = body;
    riLastBody = body;
    ss('ok', `‚úì Route Info ${pilotCs} ‚Äî ${relAtc.length} ATCs`);
    notifySound();

  } catch(e) {
    $('riBody').textContent = `Error: ${e.message}`;
    ss('err', `‚úó ${e.message}`);
    errorSound();
  }
}

async function riSendTelex() {
  const pilotCs = $('riCs').value.trim().toUpperCase();
  const to = $('riTo').value.trim().toUpperCase() || pilotCs;
  if (!to) { ss('err', '‚úó Sin destinatario'); return; }
  if (!riLastBody) { ss('err', '‚úó Genera route info primero'); return; }
  if (!$('cL').value.trim() || !$('cS').value.trim()) { ss('err', '‚úó Configura logon y callsign'); return; }

  const btn = $('riSend');
  btn.textContent = '‚è≥ Enviando...';
  const chunks = splitMsg(riLastBody, 480);
  let allOk = true;
  for (let i = 0; i < chunks.length; i++) {
    try {
      const pfx = chunks.length > 1 ? `[${i+1}/${chunks.length}] ` : '';
      const raw = await hReq(to, 'telex', pfx + chunks[i]);
      if (!raw.toLowerCase().startsWith('ok')) { allOk = false; break; }
      addMsg('tx', { cls:'out', type:'TELEX', badge:'b-tx', route:`${$('cS').value.toUpperCase()} ‚Üí ${to}`, body:`[RI] ${pfx}${chunks[i]}`, time:ts(), st:'‚úì OK', ok:true });
      if (i < chunks.length - 1) await new Promise(r => setTimeout(r, 400));
    } catch(e) { allOk = false; break; }
  }
  if (allOk) { btn.textContent = '‚úì Enviado'; btn.className = 'dsp-send sent'; ss('ok', `‚úì Route Info ‚Üí ${to}`); }
  else { btn.textContent = '‚úó Error'; btn.className = 'dsp-send fail'; ss('err', '‚úó Error env√≠o'); errorSound(); setTimeout(() => { btn.textContent = 'üì§ Enviar TELEX'; btn.className = 'dsp-send'; }, 2000); }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  OPS CENTER (embedded) ‚Äî Simplified monitor
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let opsInterval = null;
let opsFlights = {};
let opsMsgCount = 0;

function detectPhase(pilot, prev) {
  const lt = pilot.lastTrack || {};
  const safeNum = v => typeof v === 'number' ? v : (typeof v === 'object' ? 0 : parseFloat(v) || 0);
  const onGround = lt.onGround === true || lt.onGround === 1 || (lt.onGround == null && gs < 50);
  const gs = safeNum(lt.groundSpeed);
  const alt = safeNum(lt.altitude);
  const prevAlt = prev ? prev.alt : alt;
  const prevPhase = prev ? prev.phase : 'PREFLIGHT';
  if (onGround && (prevPhase === 'ENROUTE' || prevPhase === 'DESCENT')) return 'LANDED';
  if (onGround && (prevPhase === 'PREFLIGHT' || !prev)) return 'PREFLIGHT';
  if (prevPhase === 'LANDED') return 'LANDED';
  if (!onGround && (prevPhase === 'ENROUTE' || prevPhase === 'DESCENT')) {
    if (prevAlt - alt > 500) return 'DESCENT';
    if (prevPhase === 'DESCENT' && alt - prevAlt < 500) return 'DESCENT';
  }
  if (!onGround) return 'ENROUTE';
  if (onGround && gs < 5) return 'PREFLIGHT';
  return prevPhase;
}

async function opsScan() {
  const prefix = $('opsPrefix').value.trim().toUpperCase();
  if (!prefix) return;
  try {
    const resp = await ivaoFetch();
    const data = await resp.json();
    const pilots = data.clients?.pilots || [];
    const nbv = pilots.filter(p => p.callsign && p.callsign.toUpperCase().startsWith(prefix));
    const onlineCs = new Set(nbv.map(p => p.callsign.toUpperCase()));

    // Diagnostic logging
    console.log(`[OPS] Scan: ${pilots.length} pilotos IVAO, ${nbv.length} coinciden con prefix "${prefix}"`);
    if (nbv.length) nbv.forEach(p => {
      const t = p.lastTrack || {};
      console.log(`  ${p.callsign}: dep=${p.flightPlan?.departureId} arr=${p.flightPlan?.arrivalId} alt=${t.altitude} gs=${t.groundSpeed}`);
    });
    // Also check for partial matches if no exact matches
    if (!nbv.length) {
      const partial = pilots.filter(p => p.callsign && p.callsign.toUpperCase().includes(prefix.substring(0,2)));
      if (partial.length) console.log(`  Parciales (${prefix.substring(0,2)}*):`, partial.map(p => p.callsign));
    }

    // Cleanup offline
    for (const cs of Object.keys(opsFlights)) {
      if (!onlineCs.has(cs)) {
        if (!opsFlights[cs]._off) opsFlights[cs]._off = Date.now();
        else if (Date.now() - opsFlights[cs]._off > 300000) delete opsFlights[cs];
      }
    }

    for (const pilot of nbv) {
      const cs = pilot.callsign.toUpperCase();
      const fp = pilot.flightPlan;
      const prev = opsFlights[cs] || null;
      const track = pilot.lastTrack || {};

      // Safe extraction ‚Äî IVAO v2 can return nested objects
      const safeNum = v => typeof v === 'number' ? v : (typeof v === 'object' ? 0 : parseFloat(v) || 0);
      const safeStr = v => typeof v === 'string' ? v : (typeof v === 'object' ? (v?.id || v?.code || '') : String(v || ''));

      const newPhase = detectPhase(pilot, prev);
      const phaseChanged = prev && prev.phase !== newPhase;

      opsFlights[cs] = {
        callsign: cs, phase: newPhase,
        dep: safeStr(fp?.departureId) || prev?.dep || '????',
        arr: safeStr(fp?.arrivalId) || prev?.arr || '????',
        alt: safeNum(track.altitude),
        gs: safeNum(track.groundSpeed),
        heading: safeNum(track.heading || track.transponderHeading) || prev?.heading || 0,
        lat: safeNum(track.latitude),
        lng: safeNum(track.longitude),
        onGround: track.onGround === true || track.onGround === 1 || (track.onGround == null && safeNum(track.groundSpeed) < 50),
        aircraft: safeStr(fp?.aircraftId) || prev?.aircraft || '????',
        plannedDepTime: prev?.plannedDepTime || fp?.departureTime || null,
        firstSeen: prev?.firstSeen || Date.now(),
        enrouteStart: prev?.enrouteStart || 0,
        assignedParking: prev?.assignedParking || null,
        lastRouteInfo: prev?.lastRouteInfo || 0,
        _off: null,
        sent: prev?.sent || { preflight: false, enroute: false, descent: false, landed: false },
      };
      const flt = opsFlights[cs];

      // ‚îÄ‚îÄ FSUIPC: sustituir datos IVAO por datos del simulador para el vuelo local ‚îÄ‚îÄ
      const csLocal = $('fsuipcCs')?.value.trim().toUpperCase();
      const injected = fsuipcInjectIntoFlight(flt, csLocal);
      if (injected) {
        // Recalcular fase con datos frescos del sim (m√°s precisos que IVAO 45s)
        const simPhase = detectPhase({ lastTrack: {
          altitude: flt.alt, groundSpeed: flt.gs,
          onGround: flt.onGround, latitude: flt.lat, longitude: flt.lng,
        }}, prev);
        if (simPhase !== flt.phase) {
          opsLog(`${cs} [SIM]: ${flt.phase} ‚Üí ${simPhase}`, 'ops');
          flt.phase = simPhase;
        }
      }
      if (newPhase === 'ENROUTE' && !flt.enrouteStart) flt.enrouteStart = Date.now();

      if (!prev) { opsLog(`‚úà ${cs} detectado: ${flt.dep}‚Üí${flt.arr}`, 'ops'); notifySound(); discordNotifyDetected(flt); }
      if (phaseChanged) { opsLog(`${cs}: ${prev.phase} ‚Üí ${newPhase}`, 'ops'); discordNotifyPhase(flt, prev.phase, newPhase); }

      // Auto-messages per phase
      if (newPhase === 'PREFLIGHT' && !flt.sent.preflight) {
        flt.sent.preflight = true;
        opsAutoWx(flt, 'DEP');
      }
      if (newPhase === 'ENROUTE' && !flt.sent.enroute) {
        flt.sent.enroute = true;
        opsAutoTraffic(flt);
      }
      if (newPhase === 'DESCENT' && !flt.sent.descent) {
        flt.sent.descent = true;
        opsAutoWx(flt, 'ARR');
      }
      if (newPhase === 'LANDED' && !flt.sent.landed) {
        flt.sent.landed = true;
        opsAutoWelcome(flt);
      }

      // Periodic ROUTE INFO (configurable interval for enroute/descent)
      if ((newPhase === 'ENROUTE' || newPhase === 'DESCENT') && flt.lat && flt.lng) {
        const riMin = Math.max(5, parseInt($('opsRI').value) || 10);
        const elapsed = (Date.now() - flt.lastRouteInfo) / 60000;
        if (elapsed >= riMin) {
          flt.lastRouteInfo = Date.now();
          opsAutoRouteInfo(flt, data);
        }
      }
    }
    opsRender();
    ss('ok', `OPS: ${Object.keys(opsFlights).filter(c=>!opsFlights[c]._off).length} vuelo(s) ‚Äî ${tsShort()}`);
    // phpVMS: merge en cada scan OPS si est√° activado (sin esperar su propio intervalo)
    if ($('phpvmsEn')?.checked) phpvmsMergeWithOps();
  } catch(e) {
    opsLog(`Error: ${e.message}`, 'err');
  }
}

function proxy(url) { const p = $('cP').value.trim(); return p ? `${p}${encodeURIComponent(url)}` : url; }

// Cache-busting wrapper for IVAO API to defeat stale CORS proxy responses
function ivaoFetch() {
  const url = `${IVAO_WHAZZUP}?_t=${Date.now()}&_r=${Math.random().toString(36).substring(2,8)}`;
  return fetch(proxy(url), {
    signal: AbortSignal.timeout(25000),
    headers: { 'Cache-Control': 'no-cache, no-store, must-revalidate', 'Pragma': 'no-cache' }
  });
}

async function opsAutoWx(flt, type) {
  const icao = type === 'DEP' ? flt.dep : flt.arr;
  if (icao === '????') return;
  try {
    const mResp = await fetch(proxy(`${METAR_API}?ids=${icao}&format=raw&hours=2`), { signal: AbortSignal.timeout(6000) });
    const metar = await mResp.text();
    let body = `=== WX ${type} ${flt.callsign} ===\n${icao} METAR:\n${metar.trim()}`;
    // Add ATIS on descent
    if (type === 'ARR') {
      try {
        const raw = await hReq('SERVER', 'inforeq', `IVAOATIS ${icao}`);
        if (raw.toLowerCase().startsWith('ok') && raw.length > 5) body += `\nATIS: ${raw.substring(2).trim()}`;
      } catch(e) {}
    }
    await sendOpsTx(flt.callsign, body);
    opsLog(`‚úì WX ${type} ‚Üí ${flt.callsign}`, 'ok');

    // Send PAX connections on descent
    if (type === 'ARR') {
      const connMsg = genPaxConnections(icao);
      if (connMsg) {
        await sleep(600);
        await sendOpsTx(flt.callsign, connMsg);
        opsLog(`‚úì PAX CONN ‚Üí ${flt.callsign}`, 'ok');
      }

      // ATC congestion check
      try {
        const ivResp = await ivaoFetch();
        const ivData = await ivResp.json();
        const pilots = ivData.clients?.pilots || [];
        const atcs = ivData.clients?.atcs || [];
        const arrP = pilots.filter(p => p.flightPlan?.arrivalId === icao);
        const depP = pilots.filter(p => p.flightPlan?.departureId === icao);
        const total = arrP.length + depP.length;
        const p2 = icao.substring(0,2);
        const destAtc = atcs.filter(a => a.callsign && (a.callsign.startsWith(icao) || ((a.callsign.includes('_FSS')||a.callsign.includes('_CTR')) && a.callsign.startsWith(p2))));
        const hasApp = destAtc.some(a => a.callsign.includes('_APP'));
        if (total > 8 && destAtc.length > 0) {
          await sleep(600);
          let warn = `=== ATC ADVISORY ${icao} ===\n`;
          if (total > 12) {
            warn += `‚ö† TRAFICO MUY ALTO - ${total} ACFT (${arrP.length} ARR/${depP.length} DEP)\nPOSIBLE ATC DELAY EN LLEGADA\nEspere vectores extendidos o holdings.\n`;
          } else {
            warn += `‚ö† TRAFICO ALTO - ${total} ACFT (${arrP.length} ARR/${depP.length} DEP)\nPOSIBLE SECUENCIACION EN LLEGADA\n`;
          }
          if (hasApp) warn += `APP activo ‚Äî secuenciacion probable.\n`;
          warn += `ATC: ${destAtc.map(a=>a.callsign).join(', ')}\n`;
          await sendOpsTx(flt.callsign, warn);
          opsLog(`‚ö† ATC ADVSY ‚Üí ${flt.callsign} (${total} acft)`, 'wrn');
          discordNotifyAlert(flt.callsign, 'ATC CONGESTION', `${icao}: ${total} aeronaves (${arrP.length} ARR / ${depP.length} DEP)`);
        }
      } catch(e) {}
    }
  } catch(e) { opsLog(`‚úó WX ${type} ${flt.callsign}: ${e.message}`, 'err'); }
}

async function opsAutoTraffic(flt) {
  if (flt.arr === '????') return;
  try {
    const resp = await ivaoFetch();
    const data = await resp.json();
    const pilots = data.clients?.pilots || [];
    const arr = pilots.filter(p => p.flightPlan?.arrivalId === flt.arr);
    const dep = pilots.filter(p => p.flightPlan?.departureId === flt.arr);
    const total = arr.length + dep.length;
    const d = total === 0 ? 'NINGUNO' : total <= 3 ? 'BAJO' : total <= 8 ? 'MODERADO' : 'ALTO';
    let body = `=== TRAFFIC ${flt.arr} ===\n${d} (ARR:${arr.length} DEP:${dep.length})\n`;
    for (const p of arr.slice(0,6)) body += `${p.callsign||'?'} ${p.flightPlan?.aircraftId||'?'} FL${Math.round((p.lastTrack?.altitude||0)/100)}\n`;
    // ATC
    const atcs = data.clients?.atcs || [];
    const p2 = flt.arr.substring(0,2);
    const online = atcs.filter(a => a.callsign && (a.callsign.startsWith(flt.arr) || ((a.callsign.includes('_FSS')||a.callsign.includes('_CTR')) && a.callsign.startsWith(p2))));
    body += online.length ? `ATC: ${online.map(a=>a.callsign).join(', ')}\n` : `NO ATC ${flt.arr}\n`;
    // Dest METAR
    try {
      const mR = await fetch(proxy(`${METAR_API}?ids=${flt.arr}&format=raw&hours=2`), { signal: AbortSignal.timeout(6000) });
      const mT = await mR.text();
      if (mT.trim()) body += `METAR ${flt.arr}:\n${mT.trim()}\n`;
    } catch(e) {}
    await sendOpsTx(flt.callsign, body);
    opsLog(`‚úì TRAFFIC+WX ‚Üí ${flt.callsign}`, 'ok');
  } catch(e) { opsLog(`‚úó TRAFFIC ${flt.callsign}: ${e.message}`, 'err'); }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  AIRLINE & AIRPORT DB + PAX CONNECTIONS + CREW ROTATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const AIRLINES_BY_PREFIX = {
  'LE':['NBV','IBE','VLG','AEA','RYR','ANE','ELY'],'LP':['NBV','TAP','NTP','RYR'],
  'LF':['NBV','AFR','EZY','TVF','BEE','HOP'],'EG':['NBV','BAW','EZY','RYR','TOM','LOG','VIR'],
  'ED':['NBV','DLH','EWG','CFG','RYR','SXS'],'LI':['NBV','AZA','RYR','EZY','NOS','VOE'],
  'EH':['NBV','KLM','TRA','EZY','RYR'],'EB':['NBV','BEL','TUI','RYR'],
  'EI':['NBV','EIN','RYR','ASL'],'ES':['NBV','SAS','NAX','RYR'],
  'EN':['NBV','SAS','NAX','WIF'],'EK':['NBV','SAS','NAX','RYR'],
  'LO':['NBV','AUA','RYR','EZY','LWG'],'LS':['NBV','SWR','EZY','EZS'],
  'LK':['NBV','CSA','TVS','RYR'],'EP':['NBV','LOT','RYR','WZZ'],
  'LG':['NBV','AEE','RYR','OAL'],'LT':['NBV','THY','PGT','SXS','AJA'],
};
const DESTINATIONS_BY_PREFIX = {
  'LE':['LEMD','LEBL','LEPA','LEAL','LEMG','LEZL','LEBB','LEST','LEVC','LEXJ','GCXO','GCLP','GCFV','GCTS'],
  'LP':['LPPT','LPPR','LPFR','LPMA'],'LF':['LFPG','LFPO','LFBO','LFML','LFMN','LFLL','LFSB'],
  'EG':['EGLL','EGKK','EGSS','EGGW','EGCC','EGGP','EGPH','EGBB'],
  'ED':['EDDF','EDDM','EDDB','EDDL','EDDK','EDDS','EDDH'],
  'LI':['LIRF','LIMC','LIPZ','LIPE','LIMF','LIRN','LICC','LICJ'],
  'EH':['EHAM'],'EB':['EBBR','EBCI'],'EI':['EIDW','EICK'],
  'ES':['ESSA','ESGG','ESMS'],'EN':['ENGM','ENBR','ENZV'],
  'EK':['EKCH','EKBI'],'LO':['LOWW','LOWS','LOWG'],
  'LS':['LSZH','LSGG','LSZA'],'LK':['LKPR','LKTB'],
  'EP':['EPWA','EPKK','EPGD'],'LG':['LGAV','LGTS','LGIR','LGKR','LGSA'],
  'LT':['LTFM','LTAI','LTBS','LTFE'],
};
const GALICIAN_BASES = ['LEST','LECO','LEVX'];
const SPAIN_DOMESTIC = ['LEMD','LEBL','LEPA','LEAL','LEMG','LEZL','LEBB','LEVC','LEXJ','LEZG','GCXO','GCLP','GCFV','GCTS'];
const EUROPE_DEST = ['LFPG','EGLL','EDDF','LIRF','EHAM','EBBR','LPPT','LFBO','EDDM','LSZH','LOWW','LKPR','EPWA','EKCH','ENGM','LGAV','EIDW','ESSA'];

function genPaxConnections(arrIcao) {
  if (!arrIcao || arrIcao === '????') return '';
  // 40% probability: no connecting passengers
  if (Math.random() < 0.40) {
    return `=== CONEXIONES PAX ${arrIcao} ===\n0 PAX EN CONEXION\nNo hay pasajeros con enlaces en este vuelo.`;
  }
  const prefix = arrIcao.substring(0,2);
  const local = AIRLINES_BY_PREFIX[prefix] || ['NBV','RYR','EZY'];
  const pool = [...new Set([...local,'NBV','IBE','AFR','BAW','DLH','KLM'])];
  const localD = DESTINATIONS_BY_PREFIX[prefix] || [];
  const allD = [...new Set([...localD,...EUROPE_DEST])].filter(d => d !== arrIcao);
  const n = 2 + Math.floor(Math.random()*3);
  const used = new Set(), conns = [], now = new Date();
  const baseMin = 45 + Math.floor(Math.random()*75);
  for (let i = 0; i < n && allD.length; i++) {
    let dest, att = 0;
    do { dest = allD[Math.floor(Math.random()*allD.length)]; att++; } while (used.has(dest) && att < 20);
    if (used.has(dest)) continue; used.add(dest);
    const al = Math.random() < 0.4 ? 'NBV' : pool[Math.floor(Math.random()*pool.length)];
    const fn = `${al}${String(Math.floor(Math.random()*9000)+1000)}`;
    const gate = genParkingStand(arrIcao) || `GATE ${Math.floor(Math.random()*40)+1}`;
    const dt = new Date(now.getTime() + (baseMin + i*(15+Math.floor(Math.random()*30)))*60000);
    const ds = `${String(dt.getUTCHours()).padStart(2,'0')}:${String(dt.getUTCMinutes()).padStart(2,'0')}z`;
    const pax = Math.floor(Math.random()*12)+1;
    conns.push({fn,dest,gate,ds,pax});
  }
  if (!conns.length) return '';
  let msg = `=== CONEXIONES PAX ${arrIcao} ===\n${conns.reduce((s,c)=>s+c.pax,0)} PAX EN CONEXION:\n`;
  for (const c of conns) msg += `${c.fn} ‚Üí ${c.dest} GATE ${c.gate} ETD ${c.ds} (${c.pax}pax)\n`;
  return msg;
}

function genCrewInfo(flt) {
  const arr = flt.arr||'????', now = new Date(), h = now.getUTCHours(), m = now.getUTCMinutes();
  const localOff = getLocalOffset(arr);
  const localH = (h + localOff + 24) % 24, localM = m;
  const isBase = GALICIAN_BASES.includes(arr);
  let cc, reason, goodnight = false;
  // Late night: local >= 00:30 ‚Üí last flight, buenas noches
  if (localH >= 0 && localH < 5 && (localH > 0 || localM >= 30)) {
    cc = true; goodnight = true; reason = 'ULTIMO VUELO DEL DIA';
  } else if (h >= 21 || localH >= 23) { cc = true; reason = 'ULTIMO VUELO DEL DIA'; }
  else if (h >= 19 || localH >= 21) { cc = Math.random() < (isBase?.5:.7); reason = cc?'VUELO NOCTURNO - RELEVO PROGRAMADO':null; }
  else { cc = Math.random() < (isBase?.1:.2); reason = cc?'RELEVO DE TRIPULACION PROGRAMADO':null; }
  let msg = '';
  if (cc) {
    if (goodnight) {
      msg += `--- TRIPULACION ---\nNO HAY M√ÅS VUELOS PROGRAMADOS HOY\nTripulacion libre de servicio.\nBuenas noches y buen descanso.\n`;
    } else {
      msg += `--- TRIPULACION ---\nCAMBIO: ${reason}\nTripulacion entrante reportar a briefing.\n`;
    }
  } else {
    msg += `--- TRIPULACION ---\nSIN CAMBIO - MISMA TRIPULACION CONTIN√öA\n`;
    const nf = genNextFlight(flt, arr);
    if (nf) {
      msg += `PROXIMO: ${nf.fn} ${nf.dep}‚Üí${nf.dest} ETD ${nf.etd}\n`;
      msg += `GATE: ${nf.gate} TURN: ${nf.turn}min${nf.isRet?' (RETORNO BASE)':''}\n`;
    }
  }
  return msg;
}

function getLocalOffset(icao) {
  if (!icao || icao.length < 2) return 1;
  if (icao.startsWith('GC')) return 0;
  const pfx = icao.substring(0,2);
  const o = {'LE':1,'LP':0,'LF':1,'EG':0,'ED':1,'LI':1,'EH':1,'EB':1,'EI':0,'ES':1,'EN':1,'EK':1,'LO':1,'LS':1,'LK':1,'EP':1,'LG':2,'LT':3,'LC':2,'LH':1,'LR':2,'LZ':2};
  return o[pfx] ?? 1;
}

function genNextFlight(flt, apt) {
  const roll = Math.random(); let dest, isRet = false;
  if (roll < 0.50) { const b = GALICIAN_BASES.filter(x=>x!==apt); dest = b.length?b[Math.floor(Math.random()*b.length)]:GALICIAN_BASES[0]; isRet = true; }
  else if (roll < 0.80) { const d = SPAIN_DOMESTIC.filter(x=>x!==apt); dest = d[Math.floor(Math.random()*d.length)]||'LEMD'; }
  else { const e = EUROPE_DEST.filter(x=>x!==apt); dest = e[Math.floor(Math.random()*e.length)]||'LFPG'; }
  const turn = 35+Math.floor(Math.random()*40);
  const dt = new Date(Date.now()+turn*60000);
  const etd = `${String(dt.getUTCHours()).padStart(2,'0')}:${String(dt.getUTCMinutes()).padStart(2,'0')}z`;
  const fn = `NBV${String(Math.floor(Math.random()*9000)+1000)}`;
  const gate = genParkingStand(apt) || `STAND ${Math.floor(Math.random()*30)+1}`;
  return {fn,dep:apt,dest,etd,gate,turn,isRet};
}

function genParkingStand(icao) {
  if (!icao || icao === '????') return '';
  // AirNubeiro official stands from Manual de Procedimientos Operacionales
  const NBV_STANDS = {
    'LEST':['2','3','4','5','6','7','21','22'],'LEVX':['4','5','7'],'LEAS':['2','3'],
    'LECO':['1','3','12'],'LEXJ':['2','6'],'LEBB':['4','6','16'],
    'LEBL':['236','238','240','242','248'],'LEVC':['4','6','42'],
    'LEAL':['29','31'],'LEPA':['84','86','88','48','66'],'LEMG':['24','26','28'],
    'LEMD':['T27','T28','T29','T32','T18'],'LEIB':['18','25','27','28'],
    'LEZL':['6','7'],'GCFV':['21','22','23'],'GCLA':['7','9'],
    'GCXO':['T1','T4'],'GCRR':['T1','T3'],'GCLP':['T05','T06'],'GCTS':['14','16'],
  };
  // Real gates for major European airports (A320-A350 size)
  const REAL_GATES = {
    'EGLL':['A5','A7','A10','A14','A18','A22','B32','B34','B36','B38','B42','B44','B46','C54','C56','C60','C62','301','305','307','340','501','503','505','510','520','525','544','546','555','562'],
    'LFPG':['E40','E42','E44','E46','E48','E50','K21','K24','K30','K36','L40','L42','L44','M30','M32','M34','M36','A22','A24','A26','A30','D51','D53','D55','F32','F34','F36','F38'],
    'EDDF':['A15','A17','A21','A24','A26','A50','A52','A60','A62','B20','B22','B24','B28','B30','B40','B42','B44','C14','C15','D2','D4','D6','D8','E4','E6','E8','E12','E15','E21'],
    'EHAM':['B18','B20','B22','B24','B28','C8','C10','C12','D18','D20','D22','D51','D53','D57','D59','E18','E20','E22','E24','F3','F5','F7','F9','G3','G5','G9','H1','H3','H5','H7'],
    'LIRF':['B1','B3','B5','B7','B11','B13','B15','B17','B19','B21','D1','D3','D5','D7','E1','E3','E5','E7','E11','E13','E15','E17','E19','E21','E23','E25','G1','G3','G5','G7','G9'],
    'EBBR':['A26','A28','A30','A32','A34','A40','A42','A44','A46','B50','B52','B54','B56','B58','B60','B62','B64'],
    'EIDW':['101','102','103','104','105','201','202','203','204','301','302','303','304','305','306','307','308','310','311','312','314','315'],
    'LPPT':['14','16','18','20','22','24','26','28','30','32','34','36','38','40','42','44','46','48','50','52','54','56','58'],
    'LPPR':['3','5','7','9','11','13','15','17','19','21','23','25'],
    'LOWW':['B14','B16','B18','B20','B22','B24','C28','C30','C32','C34','D42','D44','D46','D48','D50','D52','F68','F70','F72','F74','F76','G81','G83','G85'],
    'LSZH':['A10','A12','A14','A16','A20','A22','A24','A26','A28','A30','A32','A34','B51','B53','B55','B57','B59','B61','B63','B65','D31','D33','D35','D37','D39','D41','E54','E56','E58','E60','E62','E64'],
    'EKCH':['A1','A2','A3','A4','A5','A7','B5','B6','B7','B8','B9','B10','C22','C24','C26','C28','C30','C32','C34','D4','D6','D8','D10','E52','E54','E56','E58','E60','E62','E64','E66'],
    'ESSA':['1','2','3','4','5','6','7','8','10','12','14','16','18','20','22','24','26','28','30','32','34','36','38','40','42','44'],
    'ENGM':['A11','A12','A13','A14','A15','A16','A17','A18','A19','B22','B24','B26','B28','B30','B32','B34','C36','C38','C40','C42','C44','C46','C48','D50','D52','D54','D56','D58','D60','D62'],
    'LKPR':['A2','A4','A6','A8','A10','B15','B17','B19','B21','B23','B25','C30','C32','C34','C36','C38','C40','D42','D44','D46','D48'],
    'EPWA':['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29'],
    'LGAV':['A1','A2','A3','A4','A5','A6','A7','A8','A9','A10','A11','B15','B16','B17','B18','B19','B20','B21','B22','B23','B24','B25','B26'],
    'LTFM':['D201','D203','D205','D207','D209','D211','D213','D215','F101','F103','F105','F107','F109','F111','F113','F115','G301','G303','G305','G307','G309','G311'],
    'LIMC':['A1','A3','A5','A7','A9','A11','B15','B17','B19','B21','B23','B25','B27','C1','C3','C5','C7','C9'],
    'LFBO':['A1','A3','A5','A7','A9','A11','B1','B3','B5','B7','B9','B11','B13','C1','C3','C5','D1','D3','D5','D7'],
    'LFML':['A2','A4','A6','A8','A10','A12','A14','B1','B3','B5','B7','B9','B11','B13'],
    'LFMN':['A1','A2','A3','A4','A5','A6','A7','A8','A9','A10','A11','A12','T2-1','T2-3','T2-5','T2-7'],
    'EGKK':['1','2','3','4','5','6','10','11','12','13','14','15','21','22','23','24','25','26','31','32','33','34','35','36','40','41','42','43','44','45','46','47','48','51','52','53','54','55','56','101','102','103'],
  };
  // Check NBV official first, then real gates, then generate plausible
  if (NBV_STANDS[icao]) {
    const sl = NBV_STANDS[icao];
    return `STAND ${sl[Math.floor(Math.random() * sl.length)]}`;
  }
  if (REAL_GATES[icao]) {
    const gl = REAL_GATES[icao];
    return `GATE ${gl[Math.floor(Math.random() * gl.length)]}`;
  }
  // Fallback: generate plausible stand based on ICAO prefix
  const prefix = icao.substring(0, 2);
  const ranges = {
    'LE':[1,50],'LP':[1,40],'LF':[1,60],'EG':[1,60],'ED':[1,50],'LI':[1,40],
    'EH':[1,70],'EB':[1,60],'EI':[1,40],'ES':[1,50],'EN':[1,60],'EK':[1,40],
    'LO':[1,50],'LS':[1,50],'LK':[1,40],'EP':[1,30],'LG':[1,30],'LT':[1,50],
  };
  const r = ranges[prefix] || [1,30];
  return `STAND ${Math.floor(Math.random()*(r[1]-r[0]+1))+r[0]}`;
}

async function opsAutoWelcome(flt) {
  const flightMin = flt.enrouteStart ? Math.round((Date.now() - flt.enrouteStart) / 60000) : 0;
  const monitorMin = flt.firstSeen ? Math.round((Date.now() - flt.firstSeen) / 60000) : 0;
  const stand = flt.assignedParking || genParkingStand(flt.arr);
  const welcome = [
    `=== BIENVENIDO ${flt.arr} ===`,
    `${flt.callsign} ‚Äî ${flt.dep}/${flt.arr} (${flt.aircraft})`,
    flightMin > 0 ? `TIEMPO DE VUELO: ${Math.floor(flightMin/60)}h${String(flightMin%60).padStart(2,'0')}m` : '',
    monitorMin > flightMin + 5 ? `TIEMPO TOTAL: ${Math.floor(monitorMin/60)}h${String(monitorMin%60).padStart(2,'0')}m` : '',
    stand ? `PARKING: ${stand}` : '',
    `Gracias por volar con AirNubeiro.`,
    `Buen servicio, cielos limpios.`,
  ].filter(Boolean).join('\n');
  try {
    await sendOpsTx(flt.callsign, welcome);
    opsLog(`‚úì WELCOME ‚Üí ${flt.callsign}`, 'ok');
  } catch(e) { opsLog(`‚úó WELCOME ${flt.callsign}: ${e.message}`, 'err'); }

  // Delay report if departure was late
  try {
    const delayMsg = genDelayReport(flt);
    if (delayMsg) {
      await sleep(600);
      await sendOpsTx(flt.callsign, delayMsg);
      opsLog(`‚ö† DELAY RPT ‚Üí ${flt.callsign}`, 'wrn');
    }
  } catch(e) { opsLog(`‚úó DELAY ${flt.callsign}: ${e.message}`, 'err'); }

  // Crew rotation + next flight
  try {
    const crewMsg = genCrewInfo(flt);
    if (crewMsg) {
      await sleep(600);
      await sendOpsTx(flt.callsign, `=== CREW ${flt.callsign} ===\n${flt.arr}\n${crewMsg}`);
      opsLog(`‚úì CREW ‚Üí ${flt.callsign}`, 'ok');
    }
  } catch(e) { opsLog(`‚úó CREW ${flt.callsign}: ${e.message}`, 'err'); }
}

async function opsAutoRouteInfo(flt, ivaoData) {
  const RADIUS = 400;
  let body = `=== ROUTE INFO ${flt.callsign} ===\n${flt.dep}‚Üí${flt.arr} FL${Math.round(flt.alt/100)} GS${flt.gs}\n`;
  try {
    // ATCs
    const atcs = ivaoData.clients?.atcs || [];
    const relAtc = [];
    for (const a of atcs) {
      if (!a.callsign || !a.lastTrack) continue;
      const aLat = a.lastTrack.latitude, aLon = a.lastTrack.longitude;
      if (!aLat && !aLon) continue;
      const type = atcTypeOf(a.callsign.toUpperCase());
      if (type === 'GND' || type === 'DEL') continue;
      const dist = haversineNm(flt.lat, flt.lng, aLat, aLon);
      if (dist > RADIUS) continue;
      const ahead = isAhead(flt.lat, flt.lng, flt.heading, aLat, aLon);
      if (!ahead && type !== 'CTR' && type !== 'FSS' && dist > 100) continue;
      const freq = a.atcSession?.frequency || a.frequency || null;
      relAtc.push({ cs: a.callsign, type, freq: fmtFreq(freq), dist: Math.round(dist) });
    }
    relAtc.sort((a, b) => a.dist - b.dist);
    if (relAtc.length) {
      body += `--- ATC ---\n`;
      for (const a of relAtc.slice(0,10)) body += `${a.cs} ${a.freq} ${a.type} ${a.dist}nm\n`;
    } else body += `NO ATC (${RADIUS}nm)\n`;

    // SIGMETs
    try {
      const sR = await fetch(proxy(`${SIGMET_API}?format=json`), { signal: AbortSignal.timeout(8000) });
      const sD = await sR.json();
      if (Array.isArray(sD)) {
        const rel = sD.filter(s => {
          const sLat = s.lat||s.coords?.[0]?.lat, sLon = s.lon||s.coords?.[0]?.lon;
          return sLat && sLon && haversineNm(flt.lat,flt.lng,sLat,sLon) < RADIUS;
        });
        if (rel.length) { body += `--- SIGMET ---\n`; for (const s of rel.slice(0,4)) body += `${(s.rawAirSigmet||s.rawSigmet||s.hazard||'?').substring(0,120)}\n`; }
      }
    } catch(e) {}

    // PIREPs
    try {
      const pR = await fetch(proxy(`${PIREP_API}?format=json&age=4`), { signal: AbortSignal.timeout(8000) });
      const pD = await pR.json();
      if (Array.isArray(pD)) {
        const rel = pD.filter(p => {
          const pLat = p.lat||p.latitude, pLon = p.lon||p.longitude;
          if (!pLat||!pLon) return false;
          if (haversineNm(flt.lat,flt.lng,pLat,pLon) > RADIUS) return false;
          return !!(p.turbulenceCondition||p.tbInt||p.turbulence||p.icingCondition||p.icInt||p.icing);
        });
        if (rel.length) { body += `--- PIREP ---\n`; for (const p of rel.slice(0,4)) body += `${(p.rawOb||`TURB:${p.turbulence||'?'} ICE:${p.icing||'?'}`).substring(0,120)}\n`; }
      }
    } catch(e) {}

    // Assign parking stand (generate once, reuse)
    if (!flt.assignedParking) flt.assignedParking = genParkingStand(flt.arr);
    if (flt.assignedParking) body += `--- PARKING ASIGNADO ---\n${flt.arr}: ${flt.assignedParking}\n`;

    await sendOpsTx(flt.callsign, body);
    opsLog(`‚úì ROUTE INFO ‚Üí ${flt.callsign} (${relAtc.length} ATCs)`, 'ok');
  } catch(e) { opsLog(`‚úó ROUTE INFO ${flt.callsign}: ${e.message}`, 'err'); }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DELAY DETECTION & REPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function genDelayReport(flt) {
  if (!flt.plannedDepTime || !flt.enrouteStart) return null;
  let plannedMin = 0;
  const pdt = flt.plannedDepTime;
  if (typeof pdt === 'number') {
    if (pdt > 100000) { const d = new Date(pdt*1000); plannedMin = d.getUTCHours()*60+d.getUTCMinutes(); }
    else { plannedMin = Math.floor(pdt/100)*60+(pdt%100); }
  } else if (typeof pdt === 'string') {
    const m = pdt.match(/(\d{1,2}):?(\d{2})/);
    if (m) plannedMin = parseInt(m[1])*60+parseInt(m[2]); else return null;
  } else return null;
  const ad = new Date(flt.enrouteStart);
  const actualMin = ad.getUTCHours()*60+ad.getUTCMinutes();
  let delayMin = actualMin - plannedMin;
  if (delayMin < -720) delayMin += 1440;
  if (delayMin > 720) delayMin -= 1440;
  if (delayMin <= 15) return null;
  const pH = String(Math.floor(plannedMin/60)).padStart(2,'0');
  const pM = String(plannedMin%60).padStart(2,'0');
  const aH = String(ad.getUTCHours()).padStart(2,'0');
  const aM = String(ad.getUTCMinutes()).padStart(2,'0');
  const tpls = [
    `=== DELAY REPORT ${flt.callsign} ===\n${flt.dep}‚Üí${flt.arr}\nETD PLAN: ${pH}${pM}z / REAL: ${aH}${aM}z\nDELAY: +${delayMin} MIN\n---\nACCION REQUERIDA:\nReportar motivo del retraso a OPS.\nCodigo delay IATA requerido.\nContactar jefe de operaciones antes\nde iniciar siguiente rotacion.`,
    `=== DELAY REPORT ${flt.callsign} ===\n${flt.dep}‚Üí${flt.arr}\nRETRASO: +${delayMin} MIN (${pH}${pM}z‚Üí${aH}${aM}z)\n---\nDOCUMENTACION PENDIENTE:\nCompletar formulario de incidencia\noperacional post-vuelo.\nIncluir codigo IATA y descripcion.\nEntregar en briefing room o v√≠a email\na ops@airnubeiro.va`,
    `=== DELAY REPORT ${flt.callsign} ===\n${flt.dep}‚Üí${flt.arr} ‚Äî DELAY +${delayMin}MIN\nPLAN: ${pH}${pM}z / REAL: ${aH}${aM}z\n---\nPAPERWORK REQUERIDO:\nRellenar delay report antes de\nabandonar la aeronave.\nMotivo + codigo IATA + firma PIC.\nCopia a dispatch y crew planning.`,
  ];
  return tpls[Math.floor(Math.random()*tpls.length)];
}

async function sendOpsTx(to, body) {
  const chunks = splitMsg(body, 480);
  for (let i = 0; i < chunks.length; i++) {
    const pfx = chunks.length > 1 ? `[${i+1}/${chunks.length}] ` : '';
    const raw = await hReq(to, 'telex', pfx + chunks[i]);
    if (!raw.toLowerCase().startsWith('ok')) throw new Error(raw);
    addMsg('tx', { cls:'out', type:'TELEX', badge:'b-tx', route:`${$('cS').value.toUpperCase()} ‚Üí ${to}`, body:`[OPS] ${pfx}${chunks[i]}`, time:ts(), st:'‚úì OK', ok:true });
    // Discord: notificar TELEX autom√°tico (solo primer chunk para no saturar)
    if (i === 0) discordNotifyTelex(to, body, true);
    if (i < chunks.length - 1) await new Promise(r => setTimeout(r, 500));
  }
  opsMsgCount++;
}

function opsRender() {
  const c = $('opsFlights');
  const active = Object.values(opsFlights).filter(f => !f._off);
  if (!active.length) { c.innerHTML = '<div style="text-align:center;padding:12px;color:var(--tx3);font:.7rem var(--mono)">Sin vuelos detectados</div>'; return; }
  const order = { PREFLIGHT:0, ENROUTE:1, DESCENT:2, LANDED:3 };
  active.sort((a,b) => (order[a.phase]||9) - (order[b.phase]||9));
  c.innerHTML = active.map(f => {
    const ph = f.phase.toLowerCase();
    const label = { PREFLIGHT:'PRE', ENROUTE:'ENR', DESCENT:'DSC', LANDED:'LND' }[f.phase]||f.phase;
    return `<div class="ops-flt ph-${ph}">
      <span class="ops-cs">${esc(f.callsign)}</span>
      <span class="ops-rt">${esc(f.dep)}‚Üí${esc(f.arr)} ${f.aircraft} FL${Math.round(f.alt/100)} GS${f.gs}</span>
      <span class="${f.srcSim ? 'ops-src-sim' : f.srcPhpvms ? 'ops-src-phpvms' : 'ops-src-ivao'}">${f.srcSim ? 'SIM' : f.srcPhpvms ? 'phpVMS' : 'NET'}</span>
      <span class="ops-ph ${ph}">${label}</span>
    </div>`;
  }).join('');
}

function opsLog(msg, cls = '') {
  const c = $('opsLog');
  const e = document.createElement('div');
  e.className = `ops-log-e ${cls}`;
  e.innerHTML = `<span class="t">${tsShort()}</span>${esc(msg)}`;
  c.insertBefore(e, c.firstChild);
  while (c.children.length > 50) c.removeChild(c.lastChild);
}

function toggleOpsMonitor() {
  if (opsInterval) {
    clearInterval(opsInterval); opsInterval = null;
    $('opsBtn').textContent = '‚ñ∂ INICIAR MONITOR';
    $('opsBtn').style.background = '';
    ss('ok', 'OPS monitor detenido');
    opsLog('Monitor detenido', 'wrn');
  } else {
    if (!$('cL').value.trim() || !$('cS').value.trim()) { ss('err', '‚úó Configura logon y callsign'); return; }
    const iv = Math.max(15, parseInt($('opsInterval').value) || 45) * 1000;
    opsLog(`Monitor iniciado ‚Äî ${$('opsPrefix').value.toUpperCase()} cada ${iv/1000}s`, 'ops');
    opsScan();
    opsInterval = setInterval(opsScan, iv);
    $('opsBtn').textContent = '‚èπ DETENER MONITOR';
    $('opsBtn').style.background = 'var(--ok)';
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  OCC BOARD ‚Äî Fleet Overview (NBV flights from IVAO Whazzup)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let occTimer = null;
let lastOccData = null; // cache to share with Stream Mode

// Airport coordinates cache for distance/ETA calculation
const APT_COORDS = {};

// State label/class mapping from IVAO lastTrack.state
function mapState(st) {
  if (!st) return { label:'UNKNOWN', cls:'gnd' };
  const s = String(st).toUpperCase();
  // IVAO states: "En Route", "Boarding", "Departing", "Climbing", "Cruising", "Descending", "Approaching", "On Blocks", "Arrived", "Initial Climb"
  if (s.includes('BOARD') || s.includes('BLOCK') || s.includes('PARKED')) return { label:'GROUND', cls:'gnd' };
  if (s.includes('DEPART') || s.includes('TAXI')) return { label:'DEPARTING', cls:'dep' };
  if (s.includes('INITIAL') || s.includes('CLIMB')) return { label:'CLIMBING', cls:'clb' };
  if (s.includes('CRUIS')) return { label:'CRUISE', cls:'crz' };
  if (s.includes('EN ROUTE') || s === 'EN ROUTE') return { label:'EN ROUTE', cls:'enr' };
  if (s.includes('DESCEND')) return { label:'DESCEND', cls:'dsc' };
  if (s.includes('APPROACH') || s.includes('LANDING')) return { label:'APPROACH', cls:'app' };
  if (s.includes('ARRIV') || s.includes('LANDED')) return { label:'LANDED', cls:'lnd' };
  return { label: s.substring(0,12), cls:'gnd' };
}

async function refreshOcc() {
  try {
    const resp = await ivaoFetch();
    const data = await resp.json();
    const pilots = data.clients?.pilots || [];

    // Filter NBV callsigns
    const nbvFlights = pilots.filter(p => p.callsign && p.callsign.toUpperCase().startsWith('NBV'));

    // Merge phpVMS y FSUIPC (fuentes alternativas)
    const mergedFlights = occMergeAlternativeSources(nbvFlights);

    // Cache for Stream Mode
    lastOccData = { flights: mergedFlights, time: Date.now(), allPilots: pilots, atcs: data.clients?.atcs || [] };

    // Debug
    console.log(`[OCC] IVAO: ${pilots.length} pilotos, ${nbvFlights.length} NBV + ${mergedFlights.length - nbvFlights.length} alt.`);
    nbvFlights.forEach(f => {
      const lt = f.lastTrack || {};
      console.log(`  ${f.callsign}: alt=${lt.altitude} gs=${lt.groundSpeed} onGround=${lt.onGround} state=${lt.state}`);
    });

    renderOcc(mergedFlights);
  } catch(e) {
    console.error('[OCC] Error:', e);
    $('occBody').innerHTML = `<div class="occ-empty">Error IVAO: ${esc(e.message)}<br><small>Reintentando...</small></div>`;
  }
  // Always schedule next refresh while OCC tab is active (even after errors)
  if (occTimer) clearTimeout(occTimer);
  const activeTab = document.querySelector('.tab.on')?.dataset.t;
  if (activeTab === 'occ') {
    const iv = 45000; // OCC refresca cada 45s independientemente del scan OPS
    occTimer = setTimeout(refreshOcc, iv);
  }
}

// Merge phpVMS y FSUIPC en la lista de vuelos del OCC
function occMergeAlternativeSources(ivaoFlights) {
  // Construir mapa de callsigns ya en IVAO
  const seen = new Set(ivaoFlights.map(f => (f.callsign||'').toUpperCase()));

  // A√±adir vuelos phpVMS no detectados en IVAO
  for (const [cs, pv] of Object.entries(typeof phpvmsActive !== 'undefined' ? phpvmsActive : {})) {
    if (seen.has(cs)) {
      // IVAO tiene el vuelo ‚Äî enriquecer con pilotName si falta
      const existing = ivaoFlights.find(f => f.callsign?.toUpperCase() === cs);
      if (existing && !existing._pilotName) existing._pilotName = pv.pilotName;
      continue;
    }
    seen.add(cs);
    // Crear entrada sint√©tica compatible con renderOcc
    ivaoFlights.push({
      callsign: cs, _src: 'phpvms',
      flightPlan: { aircraftId: pv.aircraft, departureId: pv.dep, arrivalId: pv.arr },
      lastTrack: { altitude: pv.alt, groundSpeed: pv.gs || 0, onGround: pv.onGround,
        state: pv.onGround ? 'On Blocks' : pv.alt > 5000 ? 'En Route' : 'Departing',
        latitude: pv.lat, longitude: pv.lon, heading: pv.heading },
      id: '‚Äî', _pilotName: pv.pilotName,
    });
  }

  // A√±adir datos FSUIPC para el callsign local (si no est√° ya en IVAO)
  const csLocal = ($('fsuipcCs')?.value.trim().toUpperCase()) || '';
  if (csLocal && !seen.has(csLocal) && typeof fsuipcGetData === 'function') {
    const sim = fsuipcGetData();
    if (sim) {
      const opsF = typeof opsFlights !== 'undefined' ? opsFlights[csLocal] : null;
      ivaoFlights.push({
        callsign: csLocal, _src: 'fsuipc',
        flightPlan: { aircraftId: opsF?.aircraft || '????', departureId: opsF?.dep || '????', arrivalId: opsF?.arr || '????' },
        lastTrack: { altitude: sim.altitude, groundSpeed: sim.groundSpeed, onGround: sim.onGround,
          state: sim.onGround ? 'On Blocks' : sim.altitude > 5000 ? 'En Route' : 'Departing',
          latitude: sim.lat, longitude: sim.lon, heading: sim.heading },
        id: 'LOCAL',
      });
    }
  }

  return ivaoFlights;
}

function renderOcc(flights) {
  const now = new Date();
  $('occRefresh').textContent = `‚ü≥ ${now.toUTCString().substring(17,25)}z`;

  if (!flights.length) {
    $('occCount').innerHTML = `<strong>0</strong> vuelos NBV en red`;
    $('occBody').innerHTML = `<div class="occ-empty">‚úà Sin vuelos NBV activos en IVAO</div>`;
    return;
  }

  $('occCount').innerHTML = `<strong>${flights.length}</strong> vuelo${flights.length>1?'s':''} NBV activo${flights.length>1?'s':''}`;

  // Build table
  let html = `<table class="occ-tbl"><thead><tr>
    <th>Callsign</th><th>ACFT</th><th>VID</th><th>DEP</th><th>ARR</th>
    <th>Estado</th><th>ALT</th><th>GS</th><th>DIST</th><th>ETA</th><th>SRC</th>
  </tr></thead><tbody>`;

  for (const p of flights) {
    const fp = p.flightPlan || {};
    const lt = p.lastTrack || {};
    // Safe extraction ‚Äî IVAO v2 can return nested objects for these fields
    const safeNum = v => typeof v === 'number' ? v : (typeof v === 'object' ? 0 : parseFloat(v) || 0);
    const safeStr = v => typeof v === 'string' ? v : (typeof v === 'object' ? (v?.id || v?.code || '') : String(v || ''));
    const cs = safeStr(p.callsign) || '???';
    const acft = safeStr(fp.aircraftId) || '???';
    const vid = p.id || p.pilotId || p.userId || '‚Äî';
    const dep = safeStr(fp.departureId) || '????';
    const arr = safeStr(fp.arrivalId) || '????';
    const alt = safeNum(lt.altitude);
    const gs = safeNum(lt.groundSpeed);
    const rawState = safeStr(lt.state);
    const state = mapState(rawState);

    // Distance to destination
    let distNm = '‚Äî';
    let eta = '‚Äî';
    if (arr && arr !== '????' && lt.latitude && lt.longitude) {
      // Try to get airport coords from IVAO data or estimate
      const aDist = calcDistToAirport(lt.latitude, lt.longitude, arr);
      if (aDist !== null) {
        distNm = Math.round(aDist);
        // ETA: distance / groundspeed
        if (gs > 50) {
          const etaMin = Math.round((aDist / gs) * 60);
          const etaTime = new Date(now.getTime() + etaMin * 60000);
          eta = `${String(etaTime.getUTCHours()).padStart(2,'0')}:${String(etaTime.getUTCMinutes()).padStart(2,'0')}z`;
        }
      }
    }

    const altStr = alt > 0 ? (alt >= 18000 ? `FL${Math.round(alt/100)}` : `${alt}ft`) : '‚Äî';
    const srcBadge = p._src === 'phpvms'
      ? `<span class="ops-src-phpvms">phpVMS</span>`
      : p._src === 'fsuipc'
        ? `<span class="ops-src-sim">SIM</span>`
        : `<span class="ops-src-ivao">IVAO</span>`;

    html += `<tr>
      <td class="occ-cs">${esc(cs)}</td>
      <td>${esc(acft)}</td>
      <td>${esc(String(vid))}</td>
      <td>${esc(dep)}</td>
      <td>${esc(arr)}</td>
      <td><span class="occ-state st-${state.cls}">${state.label}</span></td>
      <td>${altStr}</td>
      <td>${gs > 0 ? gs+'kt' : '‚Äî'}</td>
      <td>${distNm !== '‚Äî' ? distNm+'nm' : '‚Äî'}</td>
      <td>${eta}</td>
      <td>${srcBadge}</td>
    </tr>`;
  }

  html += `</tbody></table>`;
  $('occBody').innerHTML = html;
}

// Calculate distance to airport using known coordinates or ICAO estimation
function calcDistToAirport(lat, lon, icao) {
  // Check cache
  if (APT_COORDS[icao]) {
    return haversineNm(lat, lon, APT_COORDS[icao][0], APT_COORDS[icao][1]);
  }
  // Built-in major airport coordinates
  const known = {
    'LEMD':[40.472,-3.561],'LEBL':[41.297,2.078],'LEPA':[39.551,2.739],'LEAL':[38.282,-0.558],
    'LEMG':[36.675,-4.499],'LEZL':[37.418,-5.893],'LEBB':[43.301,-2.911],'LEST':[42.896,-8.415],
    'LECO':[43.302,-8.377],'LEVX':[42.232,-8.627],'LEVC':[39.489,-0.473],'LEXJ':[43.427,-3.820],
    'GCXO':[28.483,-16.341],'GCLP':[27.932,-15.387],'GCFV':[28.453,-13.864],'GCTS':[28.045,-16.572],
    'LPPT':[38.774,-9.134],'LPPR':[41.236,-8.681],'LPFR':[37.014,-7.966],'LPMA':[32.694,-16.774],
    'LFPG':[49.010,2.548],'LFPO':[48.723,2.359],'LFBO':[43.629,1.364],'LFML':[43.437,5.214],
    'LFMN':[43.658,7.216],'LFLL':[45.726,5.091],
    'EGLL':[51.470,-0.461],'EGKK':[51.148,-0.190],'EGSS':[51.885,0.235],'EGGW':[51.875,-0.368],
    'EGCC':[53.354,-2.275],'EGGP':[53.334,-2.850],'EGPH':[55.950,-3.373],'EGBB':[52.454,-1.748],
    'EDDF':[50.033,8.570],'EDDM':[48.354,11.786],'EDDB':[52.362,13.509],'EDDL':[51.289,6.767],
    'EDDK':[50.866,7.143],'EDDS':[48.690,9.222],'EDDH':[53.630,9.988],
    'LIRF':[41.800,12.239],'LIMC':[45.630,8.723],'LIPZ':[45.505,12.352],'LIPE':[44.535,11.289],
    'LIMF':[45.200,7.650],'LIRN':[40.886,14.291],
    'EHAM':[52.308,4.764],'EBBR':[50.901,4.484],'EIDW':[53.421,-6.270],'EICK':[51.841,-8.491],
    'ESSA':[59.652,17.919],'ENGM':[60.194,11.100],'EKCH':[55.618,12.656],
    'LOWW':[48.110,16.570],'LSZH':[47.458,8.548],'LSGG':[46.238,6.109],
    'LKPR':[50.101,14.260],'EPWA':[52.166,20.967],'EPKK':[50.078,19.785],
    'LGAV':[37.936,23.944],'LGTS':[40.520,22.971],
    'LTFM':[41.275,28.752],'LTAI':[36.899,30.800],
  };
  if (known[icao]) {
    APT_COORDS[icao] = known[icao];
    return haversineNm(lat, lon, known[icao][0], known[icao][1]);
  }
  return null;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  STREAM MODE ‚Äî Full-screen display for streaming/recording
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let streamActive = false;
let streamTimer = null;

function openStream() {
  streamActive = true;
  $('streamOverlay').classList.add('on');
  document.body.style.overflow = 'hidden';

  // Get active airport from config (callsign station field)
  const stationCs = ($('cS')?.value || '').trim().toUpperCase();
  const icao = stationCs.replace(/_.*/, ''); // LEMD_TWR ‚Üí LEMD
  $('strIcao').textContent = icao.length === 4 ? icao : '----';

  refreshStream();
}

function closeStream() {
  streamActive = false;
  $('streamOverlay').classList.remove('on');
  document.body.style.overflow = '';
  if (streamTimer) { clearTimeout(streamTimer); streamTimer = null; }
}

async function refreshStream() {
  if (!streamActive) return;

  const stationCs = ($('cS')?.value || '').trim().toUpperCase();
  const icao = stationCs.replace(/_.*/, '');
  if (icao.length === 4) $('strIcao').textContent = icao;

  // Fetch METAR for active airport
  try {
    const mResp = await fetch(proxy(`${METAR_API}?ids=${icao}&format=raw&hours=2`), { signal: AbortSignal.timeout(6000) });
    const mTxt = (await mResp.text()).trim();
    if (mTxt) {
      const wx = parseMetarSummary(mTxt);
      let wxHtml = '';
      if (wx.wind) wxHtml += `<div class="str-wx-item"><div class="str-wx-val" style="color:var(--inf)">${esc(wx.wind)}</div><div class="str-wx-lbl">Viento</div></div>`;
      if (wx.vis) wxHtml += `<div class="str-wx-item"><div class="str-wx-val" style="color:${wx.visWarn?'var(--wrn)':'var(--ok)'}">${esc(wx.vis)}</div><div class="str-wx-lbl">Visibilidad</div></div>`;
      if (wx.qnh) wxHtml += `<div class="str-wx-item"><div class="str-wx-val" style="color:var(--tx1)">${esc(wx.qnh)}</div><div class="str-wx-lbl">QNH</div></div>`;
      if (wx.temp) wxHtml += `<div class="str-wx-item"><div class="str-wx-val" style="color:var(--cpdlc)">${esc(wx.temp)}</div><div class="str-wx-lbl">Temp</div></div>`;
      $('strWx').innerHTML = wxHtml;
    }
  } catch(e) {
    $('strWx').innerHTML = '';
  }

  // Fetch ATIS
  try {
    if (icao.length === 4) {
      const raw = await hReq('SERVER', 'inforeq', `IVAOATIS ${icao}`);
      if (raw.toLowerCase().startsWith('ok') && raw.length > 5) {
        $('strAtisBox').style.display = 'block';
        $('strAtis').textContent = raw.substring(2).trim();
      } else {
        $('strAtisBox').style.display = 'none';
      }
    }
  } catch(e) { $('strAtisBox').style.display = 'none'; }

  // Fetch NBV flights
  try {
    let flights;
    if (lastOccData && (Date.now() - lastOccData.time) < 30000) {
      flights = lastOccData.flights;
    } else {
      const resp = await ivaoFetch();
      const data = await resp.json();
      const pilots = data.clients?.pilots || [];
      flights = pilots.filter(p => p.callsign && p.callsign.toUpperCase().startsWith('NBV'));
      lastOccData = { flights, time: Date.now(), allPilots: pilots, atcs: data.clients?.atcs || [] };
    }
    renderStreamFlights(flights);
  } catch(e) {
    $('strFlights').innerHTML = `<div class="str-empty">Error IVAO: ${esc(e.message)}</div>`;
  }

  // Auto-refresh every 20s while stream is active
  if (streamActive) {
    streamTimer = setTimeout(refreshStream, 20000);
  }
}

function renderStreamFlights(flights) {
  if (!flights.length) {
    $('strFlights').innerHTML = `<div class="str-empty">‚úà Sin vuelos NBV activos en IVAO</div>`;
    return;
  }

  const now = new Date();
  let html = `<table class="str-tbl"><thead><tr>
    <th>Callsign</th><th>ACFT</th><th>Ruta</th><th>Estado</th><th>ALT</th><th>GS</th><th>ETA</th>
  </tr></thead><tbody>`;

  for (const p of flights) {
    const fp = p.flightPlan || {};
    const lt = p.lastTrack || {};
    const cs = p.callsign || '???';
    const acft = fp.aircraftId || '???';
    const dep = fp.departureId || '????';
    const arr = fp.arrivalId || '????';
    const alt = lt.altitude ? Math.round(lt.altitude) : 0;
    const gs = lt.groundSpeed || 0;
    const state = mapState(lt.state || '');
    const altStr = alt > 0 ? (alt >= 18000 ? `FL${Math.round(alt/100)}` : `${alt}ft`) : '‚Äî';

    let eta = '‚Äî';
    if (arr !== '????' && lt.latitude && lt.longitude && gs > 50) {
      const d = calcDistToAirport(lt.latitude, lt.longitude, arr);
      if (d !== null) {
        const etaMin = Math.round((d / gs) * 60);
        const etaT = new Date(now.getTime() + etaMin * 60000);
        eta = `${String(etaT.getUTCHours()).padStart(2,'0')}:${String(etaT.getUTCMinutes()).padStart(2,'0')}z`;
      }
    }

    html += `<tr>
      <td class="str-cs">${esc(cs)}</td>
      <td>${esc(acft)}</td>
      <td>${esc(dep)} ‚Üí ${esc(arr)}</td>
      <td><span class="str-state st-${state.cls}">${state.label}</span></td>
      <td>${altStr}</td>
      <td>${gs > 0 ? gs+'kt' : '‚Äî'}</td>
      <td>${eta}</td>
    </tr>`;
  }

  html += `</tbody></table>`;
  $('strFlights').innerHTML = html;
}

// Parse METAR into summary components for Stream Mode display
function parseMetarSummary(raw) {
  const result = { wind: null, vis: null, visWarn: false, qnh: null, temp: null };
  try {
    // Wind: e.g. 24015KT, 24015G25KT, VRB03KT
    const wm = raw.match(/\b(\d{3}|VRB)(\d{2,3})(G\d{2,3})?(KT|MPS)\b/);
    if (wm) {
      const dir = wm[1] === 'VRB' ? 'VRB' : wm[1] + '¬∞';
      const spd = wm[2];
      const gust = wm[3] ? wm[3] : '';
      const unit = wm[4];
      result.wind = `${dir}/${spd}${gust}${unit}`;
    }
    // Visibility: e.g. 9999, 3000, CAVOK
    if (raw.includes('CAVOK')) {
      result.vis = 'CAVOK';
    } else {
      const vm = raw.match(/\s(\d{4})\s/);
      if (vm) {
        const v = parseInt(vm[1]);
        result.vis = v >= 9999 ? '10km+' : (v >= 1000 ? (v/1000).toFixed(1)+'km' : v+'m');
        result.visWarn = v < 5000;
      }
    }
    // QNH: Q1013 or A2992
    const qm = raw.match(/\b(Q\d{4}|A\d{4})\b/);
    if (qm) result.qnh = qm[1];
    // Temperature: e.g. 18/12 or M02/M05
    const tm = raw.match(/\b(M?\d{2})\/(M?\d{2})\b/);
    if (tm) {
      const t = tm[1].replace('M', '-');
      const d = tm[2].replace('M', '-');
      result.temp = `${t}¬∞/${d}¬∞`;
    }
  } catch(e) {}
  return result;
}

// ‚îÄ‚îÄ Keyboard shortcuts ‚îÄ‚îÄ
document.addEventListener('keydown', e => {
  // F11 or Ctrl+Shift+S ‚Üí Stream Mode toggle
  if (e.key === 'F11') {
    e.preventDefault();
    if (streamActive) closeStream(); else openStream();
    return;
  }
  // ESC ‚Üí close Stream Mode
  if (e.key === 'Escape' && streamActive) {
    closeStream();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    e.preventDefault();
    const a = document.querySelector('.tab.on')?.dataset.t;
    if (a === 'telex') sendTx(); else if (a === 'info') sendInfo(); else if (a === 'cpdlc') sendCp();
  }
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FSUIPC WEBSOCKET MODULE v1.0 ‚Äî AirNubeiro ACARS
//  Conecta a FSUIPC WebSocket Server (Paul Henty) en ws://127.0.0.1:2048
//  Fuente primaria de datos del simulador local.
//  Documentaci√≥n protocolo: fsuipcwebsockets.paulhenty.com
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ Estado global ‚îÄ‚îÄ
let fsuipcWs         = null;   // Instancia WebSocket activa
let fsuipcConnected  = false;  // true = conexi√≥n WS establecida
let fsuipcReady      = false;  // true = grupo registrado y recibiendo datos
let fsuipcData       = null;   // √öltimo snapshot normalizado del simulador
let fsuipcRetryTimer = null;   // Handle del timer de reintento
let fsuipcRetryCount = 0;      // Contador de reintentos consecutivos
let fsuipcPollTimer  = null;   // Handle del poll peri√≥dico

const FSUIPC_MAX_RETRY   = 8;     // Reintentos antes de darse por vencido
const FSUIPC_RETRY_DELAY = 15000; // 15 s entre reintentos
const FSUIPC_GROUP_NAME  = 'AN_FLIGHT_DATA';

// ‚îÄ‚îÄ Offsets FSUIPC (Paul Henty WebSocket Server) ‚îÄ‚îÄ
// Compatibles con FSUIPC4 (FS9/FSX), FSUIPC5 (P3D), FSUIPC7 (MSFS 2020/2024)
const FSUIPC_OFFSETS = [
  { name: 'lat',      address: '0x0560', type: 'DBL',    size: 8 }, // Latitud decimal (¬∞)
  { name: 'lon',      address: '0x0568', type: 'DBL',    size: 8 }, // Longitud decimal (¬∞)
  { name: 'altMeters',address: '0x0574', type: 'INT64',  size: 8 }, // Altitud metros MSL
  { name: 'gs',       address: '0x02B8', type: 'UINT32', size: 4 }, // Ground speed (m/s √ó 65536)
  { name: 'hdg',      address: '0x0580', type: 'UINT32', size: 4 }, // Heading (¬∞ √ó 65536 / 360 √ó 65536)
  { name: 'vs',       address: '0x030C', type: 'INT32',  size: 4 }, // Vertical speed (ft/min √ó 256)
  { name: 'onGround', address: '0x0366', type: 'INT16',  size: 2 }, // 1 = en tierra, 0 = en vuelo
  { name: 'squawk',   address: '0x0354', type: 'UINT16', size: 2 }, // Transponder BCD
  { name: 'flaps',    address: '0x0BE0', type: 'UINT32', size: 4 }, // Posici√≥n flaps handle
  { name: 'fuel',     address: '0x126C', type: 'UINT32', size: 4 }, // Combustible total (kg √ó 65536)
];

// ‚îÄ‚îÄ Normalizaci√≥n de datos brutos FSUIPC ‚Üí formato interno ‚îÄ‚îÄ
function fsuipcNormalize(raw) {
  // Ground speed: UINT32 en m/s √ó 65536 ‚Üí knots
  const gsMs  = (raw.gs || 0) / 65536;
  const gsKts = Math.round(gsMs * 1.94384);
  // Heading: UINT32, valor = degrees √ó (65536 / 360) √ó 65536 ‚Üí reducir a grados
  // Formato real FSUIPC: heading_degrees = raw_value / 65536 * 360 / 65536 * 360... simplificado:
  // heading en degrees = (raw / 65536) * 360 si el valor viene como (deg/360)*65536
  const hdgDeg = Math.round(((raw.hdg || 0) / 65536) * 360) % 360;
  // Altitud: INT64 en metros ‚Üí feet
  const altFt  = Math.round((raw.altMeters || 0) * 3.28084);
  // VS: INT32 en ft/min √ó 256
  const vsFpm  = Math.round((raw.vs || 0) / 256);
  // onGround: INT16, 1 = suelo
  const onGround = (raw.onGround === 1 || raw.onGround === true);
  // Transponder BCD ‚Üí string 4 d√≠gitos
  let squawk = '0000';
  if (raw.squawk) {
    // BCD decode: cada 4 bits = un d√≠gito octal
    const d1 = (raw.squawk >> 12) & 0xF;
    const d2 = (raw.squawk >> 8)  & 0xF;
    const d3 = (raw.squawk >> 4)  & 0xF;
    const d4 =  raw.squawk        & 0xF;
    squawk = `${d1}${d2}${d3}${d4}`;
  }
  // Combustible: UINT32 en kg √ó 65536
  const fuelKg = Math.round((raw.fuel || 0) / 65536);

  return {
    lat:       raw.lat       || 0,
    lon:       raw.lon       || 0,
    altitude:  altFt,            // ft MSL
    groundSpeed: gsKts,          // knots
    heading:   hdgDeg,           // grados true
    verticalSpeed: vsFpm,        // ft/min
    onGround:  onGround,
    squawk:    squawk,
    flaps:     raw.flaps || 0,
    fuelKg:    fuelKg,
    ts:        Date.now(),
  };
}

// ‚îÄ‚îÄ Actualizar UI del badge de fuente ‚îÄ‚îÄ
function fsuipcUpdateBadge(state) {
  // state: 'ivao' | 'fsuipc' | 'connecting'
  const b = $('fsuipcBadge');
  if (!b) return;
  b.className = `fsuipc-badge src-${state}`;
  const labels = { ivao: 'IVAO', fsuipc: 'SIM', connecting: 'SIM‚Ä¶' };
  const titles = {
    ivao: 'Fuente: IVAO Whazzup (red)',
    fsuipc: 'Fuente: FSUIPC WebSocket (simulador local)',
    connecting: 'FSUIPC: conectando...',
  };
  b.innerHTML = `<span class="fsuipc-dot"></span>${labels[state] || 'IVAO'}`;
  b.title = titles[state] || '';
}

// ‚îÄ‚îÄ Actualizar estado visible en el panel cfg ‚îÄ‚îÄ
function fsuipcSetStatus(msg, ok) {
  const el = $('fsuipcStatus');
  if (!el) return;
  el.textContent = msg;
  el.style.color = ok === true ? '#34d399' : ok === false ? 'var(--wrn)' : 'var(--tx3)';
}

// ‚îÄ‚îÄ Registrar grupo de offsets tras conexi√≥n ‚îÄ‚îÄ
function fsuipcRegisterGroup() {
  if (!fsuipcWs || fsuipcWs.readyState !== WebSocket.OPEN) return;
  const pollMs = Math.max(200, parseInt($('fsuipcPoll')?.value) || 500);
  const msg = JSON.stringify({
    command: 'groups.add',
    parameters: [{
      name:         FSUIPC_GROUP_NAME,
      pollInterval: pollMs,
      offsets:      FSUIPC_OFFSETS,
    }]
  });
  fsuipcWs.send(msg);
}

// ‚îÄ‚îÄ Parsear mensajes entrantes del WS ‚îÄ‚îÄ
function fsuipcHandleMessage(evt) {
  let msg;
  try { msg = JSON.parse(evt.data); } catch { return; }

  // El servidor puede enviar datos con command = nombre del grupo
  if (msg.command === FSUIPC_GROUP_NAME && msg.data) {
    fsuipcReady = true;
    fsuipcData  = fsuipcNormalize(msg.data);
    fsuipcUpdateBadge('fsuipc');
    fsuipcSetStatus(`‚úì Sim conectado ‚Äî Alt:${fsuipcData.altitude}ft GS:${fsuipcData.groundSpeed}kt`, true);
    return;
  }

  // Respuesta de confirmaci√≥n de registro del grupo
  if (msg.command === 'groups.add' || msg.success === true) {
    fsuipcReady = true;
    fsuipcSetStatus('‚úì Grupo registrado ‚Äî esperando datos del sim', true);
    return;
  }

  // Error reportado por el servidor
  if (msg.error || msg.command === 'error') {
    console.warn('[FSUIPC] Error servidor:', msg.error || msg.message || JSON.stringify(msg));
    fsuipcSetStatus(`‚ö† Error servidor: ${msg.error || msg.message || 'desconocido'}`, false);
  }
}

// ‚îÄ‚îÄ Conectar al servidor FSUIPC WS ‚îÄ‚îÄ
function fsuipcConnect() {
  if (fsuipcWs && fsuipcWs.readyState === WebSocket.OPEN) return;
  fsuipcDisconnect(false); // limpiar sin deshabilitar

  const url = ($('fsuipcUrl')?.value.trim()) || 'ws://127.0.0.1:2048';
  fsuipcUpdateBadge('connecting');
  fsuipcSetStatus(`Conectando a ${url}‚Ä¶`, null);
  console.log('[FSUIPC] Conectando a', url);

  try {
    fsuipcWs = new WebSocket(url);
  } catch(e) {
    fsuipcSetStatus(`‚úó URL inv√°lida: ${e.message}`, false);
    fsuipcUpdateBadge('ivao');
    return;
  }

  // Timeout de conexi√≥n: 8 segundos
  const connTimeout = setTimeout(() => {
    if (fsuipcWs && fsuipcWs.readyState !== WebSocket.OPEN) {
      fsuipcWs.close();
      fsuipcSetStatus('‚úó Timeout ‚Äî simulador no responde (¬øFSUIPC WS Server activo?)', false);
      fsuipcUpdateBadge('ivao');
      fsuipcScheduleRetry();
    }
  }, 8000);

  fsuipcWs.addEventListener('open', () => {
    clearTimeout(connTimeout);
    fsuipcConnected  = true;
    fsuipcRetryCount = 0;
    console.log('[FSUIPC] Conexi√≥n establecida');
    fsuipcSetStatus('‚úì WS conectado ‚Äî registrando offsets‚Ä¶', true);
    fsuipcRegisterGroup();
    // Poll activo cada pollInterval ms para garantizar datos frescos
    const pollMs = Math.max(200, parseInt($('fsuipcPoll')?.value) || 500);
    fsuipcPollTimer = setInterval(() => {
      if (fsuipcWs?.readyState === WebSocket.OPEN) {
        fsuipcWs.send(JSON.stringify({ command: 'groups.read', name: FSUIPC_GROUP_NAME }));
      }
    }, pollMs);
  });

  fsuipcWs.addEventListener('message', fsuipcHandleMessage);

  fsuipcWs.addEventListener('close', (evt) => {
    clearTimeout(connTimeout);
    clearInterval(fsuipcPollTimer);
    fsuipcConnected = false;
    fsuipcReady     = false;
    const reason = evt.wasClean ? 'cierre limpio' : `c√≥digo ${evt.code}`;
    console.log(`[FSUIPC] Desconectado (${reason})`);

    // Si sigue habilitado, reintentar
    if ($('fsuipcEn')?.checked) {
      fsuipcUpdateBadge('connecting');
      fsuipcSetStatus(`Desconectado (${reason}) ‚Äî reintentando‚Ä¶`, null);
      fsuipcScheduleRetry();
    } else {
      fsuipcUpdateBadge('ivao');
      fsuipcData = null;
      fsuipcSetStatus('Desactivado', null);
    }
  });

  fsuipcWs.addEventListener('error', (e) => {
    clearTimeout(connTimeout);
    console.warn('[FSUIPC] Error WS:', e);
    // close se dispara tras error ‚Äî el retry lo maneja el handler close
  });
}

// ‚îÄ‚îÄ Programar reintento de conexi√≥n ‚îÄ‚îÄ
function fsuipcScheduleRetry() {
  if (fsuipcRetryCount >= FSUIPC_MAX_RETRY) {
    fsuipcSetStatus(`‚úó Sin conexi√≥n tras ${FSUIPC_MAX_RETRY} intentos ‚Äî desactiva/activa para reintentar`, false);
    fsuipcUpdateBadge('ivao');
    return;
  }
  fsuipcRetryCount++;
  const delay = FSUIPC_RETRY_DELAY;
  clearTimeout(fsuipcRetryTimer);
  fsuipcSetStatus(`Reintento ${fsuipcRetryCount}/${FSUIPC_MAX_RETRY} en ${delay/1000}s‚Ä¶`, null);
  fsuipcRetryTimer = setTimeout(() => {
    if ($('fsuipcEn')?.checked) fsuipcConnect();
  }, delay);
}

// ‚îÄ‚îÄ Desconectar limpiamente ‚îÄ‚îÄ
function fsuipcDisconnect(resetData = true) {
  clearTimeout(fsuipcRetryTimer);
  clearInterval(fsuipcPollTimer);
  fsuipcRetryCount = 0;
  if (fsuipcWs) {
    fsuipcWs.onclose = null; // evitar loop de retry
    fsuipcWs.onerror = null;
    if (fsuipcWs.readyState === WebSocket.OPEN || fsuipcWs.readyState === WebSocket.CONNECTING) {
      fsuipcWs.close(1000, 'Usuario desactiv√≥ FSUIPC');
    }
    fsuipcWs = null;
  }
  fsuipcConnected = false;
  fsuipcReady     = false;
  if (resetData) fsuipcData = null;
}

// ‚îÄ‚îÄ Toggle desde checkbox de config ‚îÄ‚îÄ
function fsuipcOnToggle() {
  const enabled = $('fsuipcEn').checked;
  const fields  = $('fsuipcCfgFields');
  if (fields) { fields.style.opacity = enabled ? '1' : '.45'; fields.style.pointerEvents = enabled ? '' : 'none'; }
  if (enabled) {
    fsuipcRetryCount = 0;
    fsuipcConnect();
  } else {
    fsuipcDisconnect(true);
    fsuipcUpdateBadge('ivao');
    fsuipcSetStatus('Desactivado ‚Äî activa para conectar al simulador local', null);
  }
  saveCfg();
}

// ‚îÄ‚îÄ API p√∫blica: ¬øhay datos FSUIPC v√°lidos y frescos? ‚îÄ‚îÄ
// maxAgeMs: m√°ximo tiempo aceptable desde el √∫ltimo dato (default 5s)
function fsuipcGetData(maxAgeMs = 5000) {
  if (!fsuipcConnected || !fsuipcReady || !fsuipcData) return null;
  if (Date.now() - fsuipcData.ts > maxAgeMs) return null; // datos obsoletos
  return fsuipcData;
}

// ‚îÄ‚îÄ Inyectar datos FSUIPC en el objeto de vuelo de opsScan ‚îÄ‚îÄ
// Cuando el piloto local (mi callsign) est√° volando, sustituye los datos IVAO
// por los datos del simulador en tiempo real.
function fsuipcInjectIntoFlight(flt, csLocal) {
  if (!csLocal) return false;
  if (flt.callsign !== csLocal.toUpperCase()) return false;
  const sim = fsuipcGetData();
  if (!sim) return false;

  flt.alt       = sim.altitude;
  flt.gs        = sim.groundSpeed;
  flt.heading   = sim.heading;
  flt.lat       = sim.lat;
  flt.lng       = sim.lon;
  flt.onGround  = sim.onGround;
  flt.vs        = sim.verticalSpeed;
  flt.squawk    = sim.squawk;
  flt.srcSim    = true; // Marca visual SIM en opsRender
  return true;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FIN M√ìDULO FSUIPC
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DISCORD WEBHOOK MODULE v1.0 ‚Äî AirNubeiro ACARS
//  Env√≠a embeds a un canal Discord para eventos clave de OPS:
//  vuelo detectado, cambio de fase, TELEX enviado, alertas.
//  Rate limit Discord: 5 req / 2s por webhook ‚Üí cola con debounce.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ Cola anti-rate-limit ‚îÄ‚îÄ
const discordQueue   = [];       // Cola de payloads pendientes
let discordSending   = false;    // Mutex de env√≠o
let discordLastSent  = 0;        // Timestamp del √∫ltimo env√≠o exitoso
const DISCORD_MIN_GAP = 420;     // ms m√≠nimos entre env√≠os (‚â§5 req/2s con margen)

// Colores por fase/tipo (hex decimal)
const DISCORD_COLORS = {
  PREFLIGHT: 0xFBBF24,   // √Åmbar
  ENROUTE:   0x60A5FA,   // Azul
  DESCENT:   0xA78BFA,   // Violeta
  LANDED:    0x34D399,   // Verde
  DETECTED:  0x2E8CF0,   // Azul corporativo NBV
  TELEX:     0x6EE7B7,   // Verde claro
  ALERT:     0xF87171,   // Rojo
  TEST:      0x7289DA,   // Discord blurple
};

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ
function discordEnabled()  { return $('discordEn')?.checked && !!$('discordUrl')?.value.trim(); }
function discordEvFlight() { return discordEnabled() && $('dcEvFlight')?.checked; }
function discordEvPhase()  { return discordEnabled() && $('dcEvPhase')?.checked; }
function discordEvTelex()  { return discordEnabled() && $('dcEvTelex')?.checked; }
function discordEvAlert()  { return discordEnabled() && $('dcEvAlert')?.checked; }

function discordSetStatus(msg, ok) {
  const el = $('discordStatus');
  if (!el) return;
  el.textContent = msg;
  el.style.color = ok === true ? '#7289da' : ok === false ? 'var(--wrn)' : 'var(--tx3)';
}

function discordOnToggle() {
  const enabled = $('discordEn').checked;
  const fields  = $('discordCfgFields');
  if (fields) { fields.style.opacity = enabled ? '1' : '.45'; fields.style.pointerEvents = enabled ? '' : 'none'; }
  discordSetStatus(enabled ? 'Activado ‚Äî webhook listo' : 'Desactivado', enabled ? true : null);
  saveCfg();
}

// ‚îÄ‚îÄ Encolar un payload (objeto Discord embed) ‚îÄ‚îÄ
function discordEnqueue(payload) {
  if (!discordEnabled()) return;
  discordQueue.push(payload);
  discordFlush();
}

// ‚îÄ‚îÄ Procesador de cola ‚îÄ‚îÄ
async function discordFlush() {
  if (discordSending || !discordQueue.length) return;
  discordSending = true;
  while (discordQueue.length) {
    const payload = discordQueue.shift();
    const now     = Date.now();
    const gap     = now - discordLastSent;
    if (gap < DISCORD_MIN_GAP) {
      await new Promise(r => setTimeout(r, DISCORD_MIN_GAP - gap));
    }
    try {
      const url = $('discordUrl')?.value.trim();
      if (!url) break;
      const resp = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        signal: AbortSignal.timeout(8000),
      });
      discordLastSent = Date.now();
      if (!resp.ok) {
        const txt = await resp.text().catch(() => '');
        console.warn(`[Discord] HTTP ${resp.status}:`, txt);
        if (resp.status === 429) {
          // Rate limited ‚Äî reencolar y esperar
          const retryAfter = parseFloat(resp.headers.get('Retry-After') || '2') * 1000;
          discordQueue.unshift(payload);
          await new Promise(r => setTimeout(r, retryAfter + 200));
        } else {
          discordSetStatus(`‚ö† Error webhook: HTTP ${resp.status}`, false);
        }
      } else {
        discordSetStatus(`‚úì √öltimo env√≠o: ${new Date().toISOString().substring(11,19)}Z`, true);
      }
    } catch(e) {
      console.warn('[Discord] Error de red:', e.message);
      discordSetStatus(`‚úó Error de red: ${e.message}`, false);
    }
  }
  discordSending = false;
}

// ‚îÄ‚îÄ Constructor de embed base ‚îÄ‚îÄ
function discordEmbed({ color, title, description, fields = [], footer = '' }) {
  return {
    embeds: [{
      color,
      title,
      description: description || undefined,
      fields: fields.map(f => ({ name: f.name, value: String(f.value || '‚Äî'), inline: f.inline !== false })),
      footer: { text: footer || `AirNubeiro OPS ‚Ä¢ ${new Date().toUTCString().substring(5,22)} UTC` },
      timestamp: new Date().toISOString(),
    }]
  };
}

// ‚îÄ‚îÄ Truncar texto a l√≠mite Discord (1024 chars en field, 4096 en description) ‚îÄ‚îÄ
function dTrunc(str, max = 1024) {
  const s = String(str || '');
  return s.length > max ? s.substring(0, max - 3) + '‚Ä¶' : s;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Eventos p√∫blicos ‚Äî llamados desde opsScan, sendOpsTx, etc.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Evento: nuevo vuelo detectado
function discordNotifyDetected(flt) {
  if (!discordEvFlight()) return;
  discordEnqueue(discordEmbed({
    color: DISCORD_COLORS.DETECTED,
    title: `‚úà Vuelo detectado ‚Äî ${flt.callsign}`,
    fields: [
      { name: 'Callsign',  value: flt.callsign,   inline: true },
      { name: 'Ruta',      value: `${flt.dep} ‚Üí ${flt.arr}`, inline: true },
      { name: 'Aeronave',  value: flt.aircraft || '‚Äî', inline: true },
      { name: 'Fase',      value: 'PREFLIGHT',    inline: true },
      { name: 'Fuente',    value: flt.srcSim ? 'SIM' : flt.srcPhpvms ? 'phpVMS' : 'IVAO', inline: true },
      { name: 'Piloto',    value: flt.pilotName || '‚Äî', inline: true },
    ],
  }));
}

// Evento: cambio de fase
function discordNotifyPhase(flt, oldPhase, newPhase) {
  if (!discordEvPhase()) return;
  const phaseLabels = {
    PREFLIGHT: 'üü° PREFLIGHT',
    ENROUTE:   'üîµ ENROUTE',
    DESCENT:   'üü£ DESCENT',
    LANDED:    'üü¢ LANDED',
  };
  const color = DISCORD_COLORS[newPhase] || DISCORD_COLORS.DETECTED;
  discordEnqueue(discordEmbed({
    color,
    title: `${phaseLabels[newPhase] || newPhase} ‚Äî ${flt.callsign}`,
    fields: [
      { name: 'Callsign', value: flt.callsign,  inline: true },
      { name: 'Ruta',     value: `${flt.dep} ‚Üí ${flt.arr}`, inline: true },
      { name: 'Fase',     value: `${oldPhase} ‚Üí **${newPhase}**`, inline: true },
      { name: 'FL',       value: `FL${Math.round((flt.alt || 0) / 100)}`, inline: true },
      { name: 'GS',       value: `${flt.gs || 0} kt`, inline: true },
      { name: 'HDG',      value: `${flt.heading || 0}¬∞`,   inline: true },
    ],
  }));
}

// Evento: TELEX enviado (auto-OPS o manual)
function discordNotifyTelex(to, body, auto = false) {
  if (!discordEvTelex()) return;
  const station = $('cS')?.value.toUpperCase() || 'OPS';
  discordEnqueue(discordEmbed({
    color: DISCORD_COLORS.TELEX,
    title: `üì® TELEX ${auto ? '[AUTO]' : '[MANUAL]'} ‚Üí ${to}`,
    fields: [
      { name: 'De',      value: station,          inline: true },
      { name: 'Para',    value: to,               inline: true },
      { name: 'Tipo',    value: auto ? 'Auto-OPS' : 'Manual', inline: true },
      { name: 'Mensaje', value: dTrunc(body, 512), inline: false },
    ],
  }));
}

// Evento: alerta OPS (ATC congestion, weather warning, etc.)
function discordNotifyAlert(callsign, alertType, detail) {
  if (!discordEvAlert()) return;
  discordEnqueue(discordEmbed({
    color: DISCORD_COLORS.ALERT,
    title: `üö® Alerta OPS ‚Äî ${alertType}`,
    fields: [
      { name: 'Vuelo',  value: callsign || '‚Äî', inline: true },
      { name: 'Tipo',   value: alertType,       inline: true },
      { name: 'Detalle', value: dTrunc(detail, 512), inline: false },
    ],
  }));
}

// Bot√≥n de prueba desde el panel cfg
async function discordTest() {
  if (!$('discordUrl')?.value.trim()) {
    discordSetStatus('‚úó Introduce primero la URL del webhook', false);
    return;
  }
  discordEnqueue(discordEmbed({
    color: DISCORD_COLORS.TEST,
    title: '‚úÖ AirNubeiro ACARS ‚Äî Test de conexi√≥n',
    description: 'El webhook de Discord est√° correctamente configurado.',
    fields: [
      { name: 'App',     value: 'ACARS Dispatch v4.2',  inline: true },
      { name: 'Estaci√≥n', value: $('cS')?.value || '‚Äî', inline: true },
      { name: 'Hora',    value: `${new Date().toISOString().substring(11,19)}Z`, inline: true },
    ],
  }));
}

// ‚îÄ‚îÄ Colores ACARS exactos por tipo de mensaje ‚îÄ‚îÄ
// Replican las variables CSS: --acc #2e8cf0 ¬∑ --inf #60a5fa ¬∑ --cpdlc #a78bfa ¬∑ --ok #34d399 ¬∑ --err #f87171
const DISCORD_MSG_COLORS = {
  out:   0x2E8CF0,  // TELEX enviado ‚Äî azul corporativo (--acc)
  in:    0x60A5FA,  // TELEX recibido ‚Äî azul claro (--inf)
  cpm:   0xA78BFA,  // CPDLC ‚Äî violeta (--cpdlc)
  logon: 0x34D399,  // LOGON ‚Äî verde (--ok)
  erm:   0xF87171,  // Error ‚Äî rojo (--err)
};

// Notificaci√≥n Discord para cualquier mensaje ACARS (RX o TX)
// Llamado desde addMsg() cuando el evento es relevante para Discord
function discordNotifyMsg({ direction, cls, type, route, body, st, ok }) {
  if (!discordEvTelex()) return;
  // Filtrar mensajes OPS autom√°ticos (ya notificados por discordNotifyTelex)
  if (body && typeof body === 'string' && body.startsWith('[OPS]')) return;
  const color  = DISCORD_MSG_COLORS[ok === false ? 'erm' : cls] || DISCORD_MSG_COLORS.out;
  const icon   = direction === 'rx' ? 'üì•' : 'üì§';
  const dir    = direction === 'rx' ? 'RECIBIDO' : 'ENVIADO';
  discordEnqueue(discordEmbed({
    color,
    title: `${icon} ${type} ${dir}`,
    fields: [
      { name: 'Ruta',    value: route || '‚Äî',    inline: true },
      { name: 'Tipo',    value: type,            inline: true },
      { name: 'Estado',  value: st || '‚Äî',       inline: true },
      { name: 'Mensaje', value: dTrunc(body, 512), inline: false },
    ],
    footer: `AirNubeiro ACARS v4.2 ‚Ä¢ ${new Date().toISOString().substring(11,19)}Z`,
  }));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FIN M√ìDULO DISCORD
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  API KEY ENCRYPTION ‚Äî AES-256-GCM + PBKDF2 (Web Crypto API)
//  La API key NUNCA se almacena en claro. Flujo:
//  1. Usuario pega la key ‚Üí bot√≥n VALIDAR
//  2. Validaci√≥n contra /api/user de phpVMS
//  3. Si OK: cifrado AES-256-GCM con clave derivada del dispositivo
//  4. Blob cifrado en localStorage ‚Äî display enmascarado
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function cryptoGetKey() {
  const fp = `${navigator.userAgent}|${screen.width}x${screen.height}|${navigator.language}|AN_ACARS`;
  let salt = localStorage.getItem('an_ks');
  if (!salt) {
    const bytes = crypto.getRandomValues(new Uint8Array(16));
    salt = Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join('');
    localStorage.setItem('an_ks', salt);
  }
  const saltBytes = new Uint8Array(salt.match(/.{2}/g).map(h => parseInt(h, 16)));
  const km = await crypto.subtle.importKey('raw', new TextEncoder().encode(fp), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt:saltBytes, iterations:120000, hash:'SHA-256' },
    km, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']
  );
}
async function cryptoEncrypt(plaintext) {
  const key = await cryptoGetKey();
  const iv  = crypto.getRandomValues(new Uint8Array(12));
  const enc = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, new TextEncoder().encode(plaintext));
  const buf = new Uint8Array(12 + enc.byteLength);
  buf.set(iv); buf.set(new Uint8Array(enc), 12);
  return btoa(String.fromCharCode(...buf));
}
async function cryptoDecrypt(cipherB64) {
  try {
    const key  = await cryptoGetKey();
    const data = new Uint8Array(atob(cipherB64).split('').map(c => c.charCodeAt(0)));
    const dec  = await crypto.subtle.decrypt({ name:'AES-GCM', iv:data.slice(0,12) }, key, data.slice(12));
    return new TextDecoder().decode(dec);
  } catch { return null; }
}
async function phpvmsGetKey() {
  const blob = localStorage.getItem('an_ak');
  if (!blob) return '';
  return (await cryptoDecrypt(blob)) || '';
}

function apikeyOnInput() {
  const val = $('phpvmsKeyRaw')?.value.trim();
  const btn = $('apikeyValidateBtn');
  if (btn) btn.style.display = val.length > 8 ? '' : 'none';
}
function apikeyRenderState() {
  const display = $('apikeyDisplay');
  const wrap    = $('apikeyInputWrap');
  if (!display) return;
  const hasKey = !!localStorage.getItem('an_ak');
  if (hasKey) {
    display.innerHTML = `<div class="apikey-badge ok">üîí API Key cifrada (AES-256) <button class="apikey-btn clear" onclick="apikeyClear()" style="margin-left:6px;position:static;transform:none">‚úï Borrar</button></div>`;
    if (wrap) wrap.style.display = 'none';
  } else {
    display.innerHTML = `<div class="apikey-badge err" onclick="apikeyShowInput()">‚ö† Sin API Key ‚Äî click para configurar</div>`;
    if (wrap) wrap.style.display = 'none';
  }
}
function apikeyShowInput() {
  const wrap = $('apikeyInputWrap');
  if (wrap) { wrap.style.display = ''; $('phpvmsKeyRaw')?.focus(); }
}
async function apikeyValidateAndSave() {
  const raw = $('phpvmsKeyRaw')?.value.trim();
  if (!raw) return;
  const btn = $('apikeyValidateBtn');
  btn.textContent = '‚è≥'; btn.disabled = true;
  phpvmsSetStatus('Validando API Key‚Ä¶', null);
  try {
    const base = ($('phpvmsUrl')?.value.trim() || '').replace(/\/$/,'');
    const p    = $('cP')?.value.trim();
    const url  = p ? `${p}${encodeURIComponent(base + '/api/user')}` : `${base}/api/user`;
    const resp = await fetch(url, { headers:{'X-API-Key':raw,'Accept':'application/json'}, signal:AbortSignal.timeout(10000) });
    if (!resp.ok) throw new Error(`HTTP ${resp.status} ‚Äî Key inv√°lida`);
    const json = await resp.json();
    const name = json?.data?.name || 'usuario';
    const blob = await cryptoEncrypt(raw);
    localStorage.setItem('an_ak', blob);
    $('phpvmsKeyRaw').value = '';
    apikeyRenderState();
    phpvmsSetStatus(`‚úì Key validada (${name}) y cifrada AES-256`, true);
    if ($('phpvmsEn')?.checked) { phpvmsPirepCache = {}; phpvmsScan(); }
  } catch(e) {
    phpvmsSetStatus(`‚úó ${e.message}`, false);
    btn.textContent = '‚úì VALIDAR'; btn.disabled = false;
    return;
  }
  btn.textContent = '‚úì VALIDAR'; btn.disabled = false;
}
function apikeyClear() {
  if (!confirm('¬øBorrar la API Key guardada?')) return;
  localStorage.removeItem('an_ak');
  apikeyRenderState();
  phpvmsSetStatus('API Key eliminada', null);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  phpVMS INTEGRATION MODULE v1.0 ‚Äî AirNubeiro ACARS
//  Fuente secundaria de datos: vuelos activos desde phpVMS/vmsACARS.
//  Endpoint principal: GET /api/acars/geojson (p√∫blico, sin auth)
//  Enriquecimiento: GET /api/pireps/{id} (con X-API-Key, cacheado)
//  Prioridad datos: FSUIPC > IVAO Whazzup > phpVMS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let phpvmsInterval    = null;  // Handle del setInterval de scan
let phpvmsPirepCache  = {};    // { pirepId: { ...pirepData, cachedAt } }
let phpvmsActive      = {};    // { callsign: { ...flightData } } ‚Äî vuelos activos phpVMS
let phpvmsScanCount   = 0;     // Contador de scans para logging

const PHPVMS_CACHE_TTL = 300000; // 5 min ‚Äî tiempo m√°ximo de cacheo de PIREP detail

// ‚îÄ‚îÄ Helpers internos ‚îÄ‚îÄ
function phpvmsSetStatus(msg, ok) {
  const el = $('phpvmsStatus');
  if (!el) return;
  el.textContent = msg;
  el.style.color = ok === true ? '#a78bfa' : ok === false ? 'var(--wrn)' : 'var(--tx3)';
}

function phpvmsProxy(url) {
  // Reutiliza el CORS proxy ya configurado en la app
  const p = $('cP')?.value.trim();
  return p ? `${p}${encodeURIComponent(url)}` : url;
}

// ‚îÄ‚îÄ Construir callsign desde datos del PIREP ‚îÄ‚îÄ
// phpVMS almacena airline.icao + flight_number ‚Üí "NBV" + "011" = "NBV011"
function phpvmsCallsign(pirep) {
  const prefix = pirep?.airline?.icao || pirep?.airline_icao || '';
  const num    = String(pirep?.flight_number || '').padStart(3, '0');
  if (!prefix || !num || num === '000') return null;
  return `${prefix}${num}`.toUpperCase();
}

// ‚îÄ‚îÄ Fetch GeoJSON p√∫blico ‚Äî lista de vuelos activos ‚îÄ‚îÄ
async function phpvmsFetchGeojson() {
  const base = ($('phpvmsUrl')?.value.trim() || '').replace(/\/$/, '');
  if (!base) throw new Error('URL phpVMS no configurada');
  const url = `${base}/api/acars/geojson?_t=${Date.now()}`;
  const resp = await fetch(phpvmsProxy(url), {
    signal: AbortSignal.timeout(15000),
    headers: { 'Cache-Control': 'no-cache' }
  });
  if (!resp.ok) throw new Error(`GeoJSON HTTP ${resp.status}`);
  const json = await resp.json();
  // Estructura: { data: { type: "FeatureCollection", features: [...] } }
  return (json?.data?.features || json?.features || []);
}

// ‚îÄ‚îÄ Fetch detalle de un PIREP (cacheado) ‚îÄ‚îÄ
async function phpvmsFetchPirep(pirepId) {
  // Verificar cach√©
  const cached = phpvmsPirepCache[pirepId];
  if (cached && (Date.now() - cached.cachedAt) < PHPVMS_CACHE_TTL) {
    return cached;
  }
  const base = ($('phpvmsUrl')?.value.trim() || '').replace(/\/$/, '');
  const key  = await phpvmsGetKey();
  if (!base) return null;
  const headers = { 'Accept': 'application/json', 'Cache-Control': 'no-cache' };
  if (key) headers['X-API-Key'] = key;
  try {
    const resp = await fetch(phpvmsProxy(`${base}/api/pireps/${pirepId}`), {
      signal: AbortSignal.timeout(10000),
      headers
    });
    if (!resp.ok) return null;
    const json = await resp.json();
    const data = json?.data || json;
    if (!data?.id) return null;
    phpvmsPirepCache[pirepId] = { ...data, cachedAt: Date.now() };
    return phpvmsPirepCache[pirepId];
  } catch(e) {
    console.warn(`[phpVMS] Error fetching pirep ${pirepId}:`, e.message);
    return null;
  }
}

// ‚îÄ‚îÄ Scan principal: GeoJSON ‚Üí enriquecimiento ‚Üí merge con opsFlights ‚îÄ‚îÄ
async function phpvmsScan() {
  if (!$('phpvmsEn')?.checked) return;
  phpvmsScanCount++;
  try {
    const features = await phpvmsFetchGeojson();
    phpvmsSetStatus(`Scan #${phpvmsScanCount}: ${features.length} vuelo(s) activo(s) en phpVMS`, true);

    if (!features.length) {
      // Sin vuelos activos ‚Äî limpiar entradas phpVMS de opsFlights que ya no est√°n
      phpvmsPurgeInactive(new Set());
      phpvmsActive = {};
      return;
    }

    const activePirepIds = new Set();

    for (const feat of features) {
      const props = feat.properties || {};
      const coords = feat.geometry?.coordinates || [];
      const pirepId = props.pirep_id;
      if (!pirepId) continue;
      activePirepIds.add(pirepId);

      // Coordenadas GeoJSON: [lon, lat, alt]
      const lon = parseFloat(coords[0]) || 0;
      const lat = parseFloat(coords[1]) || 0;
      const alt = parseFloat(coords[2] ?? props.alt) || 0;
      const hdg = parseFloat(props.heading) || 0;

      // Intentar obtener detalle del PIREP (cacheado)
      const pirep = await phpvmsFetchPirep(pirepId);
      const cs = pirep ? phpvmsCallsign(pirep) : null;
      if (!cs) {
        console.log(`[phpVMS] PIREP ${pirepId}: no se pudo determinar callsign`);
        continue;
      }

      // Construir objeto de vuelo phpVMS
      const dep = pirep?.dpt_airport_id || '????';
      const arr = pirep?.arr_airport_id || '????';
      const aircraft = pirep?.aircraft?.icao || pirep?.aircraft_icao || '????';

      phpvmsActive[cs] = {
        pirepId, callsign: cs,
        lat, lon, alt, heading: hdg,
        dep, arr, aircraft,
        gs: 0,         // GeoJSON no incluye GS ‚Äî se mantiene 0 o se hereda de IVAO
        onGround: alt < 100,
        pirepState: pirep?.state ?? -1,
        pilotName: pirep?.user?.name || '',
        updatedAt: Date.now(),
        srcPhpvms: true,
      };
    }

    // Purgar vuelos ya no activos en phpVMS
    phpvmsPurgeInactive(activePirepIds);

    // Merge con opsFlights
    phpvmsMergeWithOps();

    console.log(`[phpVMS] Scan #${phpvmsScanCount}: ${Object.keys(phpvmsActive).length} vuelo(s) ‚Äî ${Object.keys(phpvmsPirepCache).length} PIREPs en cach√©`);

  } catch(e) {
    phpvmsSetStatus(`‚úó Error: ${e.message}`, false);
    console.error('[phpVMS] Error en scan:', e);
  }
}

// ‚îÄ‚îÄ Purgar del cach√© vuelos que ya no aparecen en el GeoJSON ‚îÄ‚îÄ
function phpvmsPurgeInactive(activePirepIds) {
  for (const cs of Object.keys(phpvmsActive)) {
    const pid = phpvmsActive[cs]?.pirepId;
    if (pid && !activePirepIds.has(pid)) {
      console.log(`[phpVMS] Vuelo ${cs} ya no activo ‚Äî eliminando`);
      delete phpvmsActive[cs];
    }
  }
  // Limpiar cach√© de PIREPs expirados
  const now = Date.now();
  for (const pid of Object.keys(phpvmsPirepCache)) {
    if (now - phpvmsPirepCache[pid].cachedAt > PHPVMS_CACHE_TTL * 2) {
      delete phpvmsPirepCache[pid];
    }
  }
}

// ‚îÄ‚îÄ Merge phpVMS ‚Üí opsFlights ‚îÄ‚îÄ
// Solo a√±ade pilotos que NO est√°n ya en IVAO Whazzup (evita duplicar).
// Si el piloto ya est√° en IVAO, solo enriquece con pilotName si falta.
function phpvmsMergeWithOps() {
  const prefix = ($('opsPrefix')?.value.trim().toUpperCase()) || 'NBV';

  for (const [cs, pv] of Object.entries(phpvmsActive)) {
    // Solo pilotos que coincidan con el prefijo configurado
    if (!cs.startsWith(prefix)) continue;

    if (opsFlights[cs] && !opsFlights[cs]._off) {
      // Piloto ya detectado por IVAO ‚Äî enriquecer datos si es √∫til
      if (!opsFlights[cs].pilotName && pv.pilotName) {
        opsFlights[cs].pilotName = pv.pilotName;
      }
      // Actualizar dep/arr si IVAO los tiene como '????' y phpVMS los conoce
      if (opsFlights[cs].dep === '????' && pv.dep !== '????') opsFlights[cs].dep = pv.dep;
      if (opsFlights[cs].arr === '????' && pv.arr !== '????') opsFlights[cs].arr = pv.arr;
      continue;
    }

    // Piloto NO detectado por IVAO ‚Äî a√±adir desde phpVMS como fuente alternativa
    const safeNum = v => parseFloat(v) || 0;
    const prevPhase = opsFlights[cs]?.phase || 'PREFLIGHT';

    // Detectar fase usando los datos disponibles de phpVMS
    const simPhase = detectPhase({
      lastTrack: {
        altitude: pv.alt, groundSpeed: pv.gs,
        onGround: pv.onGround, latitude: pv.lat, longitude: pv.lon,
      }
    }, opsFlights[cs] || null);

    const phaseChanged = opsFlights[cs] && opsFlights[cs].phase !== simPhase;

    opsFlights[cs] = {
      callsign: cs, phase: simPhase,
      dep: pv.dep, arr: pv.arr, aircraft: pv.aircraft,
      alt: pv.alt, gs: pv.gs, heading: pv.heading,
      lat: pv.lat, lng: pv.lon,
      onGround: pv.onGround,
      pilotName: pv.pilotName,
      pirepId: pv.pirepId,
      firstSeen: opsFlights[cs]?.firstSeen || Date.now(),
      enrouteStart: opsFlights[cs]?.enrouteStart || 0,
      lastRouteInfo: opsFlights[cs]?.lastRouteInfo || 0,
      assignedParking: opsFlights[cs]?.assignedParking || null,
      plannedDepTime: opsFlights[cs]?.plannedDepTime || null,
      _off: null,
      srcPhpvms: true,
      srcSim: false,
      sent: opsFlights[cs]?.sent || { preflight: false, enroute: false, descent: false, landed: false },
    };

    if (!opsFlights[cs]?.firstSeen || phaseChanged) {
      if (phaseChanged) opsLog(`${cs} [phpVMS]: ${prevPhase} ‚Üí ${simPhase}`, 'ops');
      else opsLog(`‚úà ${cs} [phpVMS] detectado: ${pv.dep}‚Üí${pv.arr}`, 'ops');
    }
  }

  // Actualizar render
  opsRender();
}

// ‚îÄ‚îÄ Toggle desde checkbox de config ‚îÄ‚îÄ
function phpvmsOnToggle() {
  const enabled = $('phpvmsEn').checked;
  const fields  = $('phpvmsCfgFields');
  if (fields) { fields.style.opacity = enabled ? '1' : '.45'; fields.style.pointerEvents = enabled ? '' : 'none'; }
  if (enabled) {
    phpvmsActive = {};
    phpvmsPirepCache = {};
    phpvmsScanCount = 0;
    phpvmsScan(); // Scan inmediato
    const pollMs = Math.max(15, parseInt($('phpvmsPoll')?.value) || 30) * 1000;
    phpvmsInterval = setInterval(phpvmsScan, pollMs);
    phpvmsSetStatus('Activado ‚Äî primer scan en curso‚Ä¶', null);
  } else {
    clearInterval(phpvmsInterval);
    phpvmsInterval = null;
    phpvmsActive = {};
    phpvmsSetStatus('Desactivado', null);
  }
  saveCfg();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FIN M√ìDULO phpVMS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
loadCfg(); loadList('rx'); loadList('tx'); updBtn();
// Renderizar estado de API Key cifrada tras cargar config
apikeyRenderState();
$('btnSnd').textContent = soundOn ? 'üîî' : 'üîï';
if (!$('cL').value.trim()) { $('cfgP').classList.add('v'); $('btnCfg').classList.add('on'); }
else ss('ok', `Estaci√≥n ${$('cS').value||'???'} lista`);

// ‚îÄ‚îÄ PWA Service Worker ‚îÄ‚îÄ
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js')
    .then(reg => console.log('SW registrado:', reg.scope))
    .catch(err => console.log('SW error:', err));
}
</script>
</body>
</html>
